This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
tasks/
  Bot Welcome Message and Image.md
  markdown parsing issue.md
.gitignore
bot.py
config.py
database.py
handlers.py
kazabot_db.json
local_backup.json
localization.py
next-actions.md
Procfile
project-description.md
railway.json
repomix-output-stan-voo-daenahbot.xml
requirements.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="tasks/Bot Welcome Message and Image.md">
Bot Welcome Message and Image.md
Of course. Here is the extracted text, translation, and a comprehensive plan to implement the requested features, along with recommendations for your database strategy.

### **1. Bot Welcome Message and Image**

Here is the extracted text from the image and its English translation.

**Original Turkish Text:**

> **Kazayı Bildir, Kazan!**
> Bu bot üzerinden gördüğünüz trafik kazalarını bize bildirebilir ve kazanç sağlayabilirsiniz.
> 
> 🚗 Kaza yerinden bir fotoğraf çekip, konum bilgisiyle birlikte gönderin.
> ✅ Bilgiler doğrulandıktan sonra, 24 saat içinde hesabınıza 1000 TL yatırılır.
> 📞 Bilgiler doğruysa, destek ekibimiz sizinle iletişime geçecektir.
> 
> Unutmayın, hem hayat kurtarın hem de kazanç sağlayın!

**English Translation:**

> **Report an Accident, Get Rewarded!**
> You can report traffic accidents you see through this bot and earn rewards.
> 
> 🚗 Take a photo at the scene of the accident and send it along with the location information.
> ✅ After the information is verified, 1000 TL will be deposited into your account within 24 hours.
> 📞 If the information is correct, our support team will contact you.
> 
> Don't forget, you can both save lives and earn rewards!

---

### **2. Implementation Plan**

Here is a step-by-step plan to implement all the requested changes in your codebase.

#### **Part A: Add the Welcome Image and Message**

1.  **Get the Image File ID:** To send the image without re-uploading it every time, you need its `file_id`.
    *   Send the image to your bot yourself.
    *   In the bot's console logs, you will see the incoming message data. Find the `file_id` for the photo you sent. It will be a long string of characters.
    *   Copy this `file_id`.

2.  **Update the `start` function in `handlers.py`:** Modify the `start` function to send the photo and the new welcome text.

    ```python
    # handlers.py

    async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """Starts the conversation, shows a welcome message, and asks for the accident location."""
        user = update.message.from_user
        logger.info("User %s started the conversation.", user.first_name)
        
        # --- NEW: Send welcome message and image ---
        # Replace 'YOUR_FILE_ID_HERE' with the actual file_id you obtained
        photo_file_id = 'YOUR_FILE_ID_HERE' 
        welcome_caption = (
            "Welcome to KazaBot!\n\n"
            "Report an Accident, Get Rewarded!\n"
            "You can report traffic accidents you see through this bot and earn rewards.\n\n"
            "🚗 Take a photo at the scene of the accident and send it along with the location information.\n"
            "✅ After the information is verified, you will receive a reward.\n"
            "📞 If the information is correct, our support team will contact you.\n\n"
            "Don't forget, you can both save lives and earn rewards!"
        )
        await context.bot.send_photo(
            chat_id=update.effective_chat.id,
            photo=photo_file_id,
            caption=welcome_caption
        )
        # --- End of new section ---
        
        # Onboard the user if they are new and set initial balance
        get_or_create_user(user.id, user.username)

        location_keyboard = KeyboardButton(text="Share Accident Location", request_location=True)
        custom_keyboard = [[location_keyboard]]
        reply_markup = ReplyKeyboardMarkup(custom_keyboard, resize_keyboard=True, one_time_keyboard=True)

        await update.message.reply_text(
            "Please press the button below to share the accident's location.",
            reply_markup=reply_markup,
        )
        return LOCATION
    ```

#### **Part B: Implement User Balance**

1.  **Update `database.py`:** Modify the user creation function to include the balance and add a function to update it.

    ```python
    # database.py

    def get_or_create_user(user_id, username):
        """
        Retrieves a user profile or creates a new one with an initial balance.
        """
        User = Query()
        user = users_table.get(User.telegram_user_id == user_id)

        if not user:
            user_profile = {
                'telegram_user_id': user_id,
                'username': username,
                'created_at': datetime.utcnow().isoformat(),
                'courier_company': None,
                'payment_method': None,
                'report_count': 0,
                'balance': 99  # NEW: Add initial balance of 99 Lira
            }
            users_table.insert(user_profile)
            return user_profile
        return user

    def update_user_balance(user_id, amount_to_add):
        """
        Increments a user's balance by a specified amount.
        """
        User = Query()
        user = users_table.get(User.telegram_user_id == user_id)
        if user:
            # Handle cases where older users might not have a balance field
            current_balance = user.get('balance', 0) 
            new_balance = current_balance + amount_to_add
            users_table.update({'balance': new_balance}, User.telegram_user_id == user_id)
            logger.info(f"Updated balance for user {user_id}. New balance: {new_balance}")
            return new_balance
        return None
    ```    *Note: You will also need to import `logger` in `database.py` if it's not already there: `import logging` and `logger = logging.getLogger(__name__)`.*

2.  **Update `handlers.py`:** Modify the `review_handler` to award Lira for approved reports.

    ```python
    # handlers.py

    # IMPORTANT: Add the new database function to the imports
    from database import ( 
        save_report, 
        get_or_create_user, 
        update_user_profile,
        get_report_by_id, 
        update_report_status,
        update_user_balance # <-- ADD THIS
    )

    async def review_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        # ... (keep the existing code until the user notification part)

        # Update status and notify the user
        new_status = "verified" if action == "approve" else "rejected"
        update_report_status(report_id, new_status, admin_user.id)
        
        # Update the admin's message to show the result
        final_text = query.message.text + f"\n\n--- Decision ---\nStatus set to *{new_status.upper()}* by @{admin_user.username}."
        await query.edit_message_text(text=final_text, parse_mode='Markdown')

        # Notify the original user
        original_user_id = report['telegram_user_id']
        user_notification = f"UPDATE: Your report (ID: {report_id}) has been *{new_status}*."
        
        if new_status == 'verified':
            # --- NEW: Update balance and notify user ---
            reward_amount = 150 # Define your reward amount here
            new_balance = update_user_balance(original_user_id, reward_amount)
            user_notification += (
                f"\n\nCongratulations! {reward_amount} Lira has been added to your account. "
                f"Your new balance is {new_balance} Lira."
            )
            # --- End of new section ---
        
        try:
            await context.bot.send_message(
                chat_id=original_user_id,
                text=user_notification,
                parse_mode='Markdown'
            )
        except Exception as e:
            logger.error(f"Failed to send status update to user {original_user_id}: {e}")
    ```

#### **Part C: Temporarily Disable "Company Name" Question**

1.  **Update `handlers.py`:** Comment out the logic that asks for the company name.

    ```python
    # handlers.py

    async def submit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """Submits the report, saves it, and ends the conversation."""
        user = update.message.from_user
        report_data = context.user_data.get('report')
        
        if not report_data:
            await update.message.reply_text("Something went wrong. Please start over with /start.")
            return ConversationHandler.END

        # Save the report
        report_id = save_report(user.id, report_data)
        logger.info("User %s submitted report %s", user.first_name, report_id)

        # Update user's report count
        user_profile = get_or_create_user(user.id, user.username)
        new_count = user_profile.get('report_count', 0) + 1
        update_user_profile(user.id, {'report_count': new_count})
        
        # Notify admins
        await notify_admins(context, user, report_id, report_data)
        
        # --- MODIFICATION: Temporarily disable company name question ---
        # if user_profile.get('courier_company') is None:
        #     await update.message.reply_text(
        #         "✅ Success! Your report has been submitted.\n\n"
        #         "To help us, could you tell us which courier company you work for? (e.g., 'Getir', 'Trendyol Go'). This is optional.",
        #          reply_markup=ReplyKeyboardRemove(),
        #     )
        #     return COMPANY_NAME
        # else:
        #     # If company name is known, end the conversation
        #     return await finish(update, context)
        return await finish(update, context) # Always go to the finish state
        # --- End of modification ---

    # --- MODIFICATION: Comment out the unused handler ---
    # async def company_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    #     """Saves the user's courier company and ends the conversation."""
    #     user_id = update.message.from_user.id
    #     company = update.message.text
        
    #     update_user_profile(user_id, {'courier_company': company})
    #     logger.info("User %s set their company to %s", update.message.from_user.first_name, company)
        
    #     await update.message.reply_text("Thank you! Your profile has been updated.")
        
    #     return await finish(update, context)
    # --- End of modification ---
    ```

2.  **Update `bot.py`:** Comment out the unused state in the `ConversationHandler`.

    ```python
    # bot.py

    # ... (other imports)
    from handlers import (
        # ... (other handlers)
        # company_name, # Comment out
        cancel,
        review_handler,
        LOCATION,
        PHOTO,
        DESCRIPTION,
        CRASH_TIME_DELTA,
        CONFIRMATION,
        # COMPANY_NAME, # Comment out
    )

    # ...

    def main() -> None:
        # ...

        conv_handler = ConversationHandler(
            # ...
            states={
                LOCATION: [MessageHandler(filters.LOCATION, location)],
                PHOTO: [MessageHandler(filters.PHOTO, photo)],
                DESCRIPTION: [
                    MessageHandler(filters.Regex(r"(?i)^skip$"), description_skip),
                    MessageHandler(filters.TEXT & ~filters.COMMAND, description),
                ],
                CRASH_TIME_DELTA: [MessageHandler(filters.TEXT & ~filters.COMMAND, crash_time_delta)],
                CONFIRMATION: [
                    MessageHandler(filters.Regex(r"(?i)^Submit Report$"), submit),
                    MessageHandler(filters.Regex(r"(?i)^Cancel$"), cancel),
                ],
                # COMPANY_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, company_name)], # Comment out this line
            },
            fallbacks=[CommandHandler("cancel", cancel)],
            per_message=False 
        )
        # ...
    ```

---

### **3. Database Storage on Railway.app for an MVP**

For an MVP hosted on Railway, you have two excellent choices for handling your `kazabot_db.json` file. Here’s a comparison to help you decide:

#### **Option 1: Railway Persistent Volume (Recommended for MVP)**

Railway allows you to mount a persistent disk, called a "volume," to your service. This volume acts like a small, attached hard drive that doesn't get erased when you deploy new code or restart your service.

*   **How it Works:** You would configure a volume in your Railway project settings and mount it at a specific path (e.g., `/data`). You would then modify your `DATABASE_PATH` in `config.py` to point to this location (e.g., `DATABASE_PATH = '/data/kazabot_db.json'`).
*   **Pros:**
    *   **Simplicity:** It's the easiest and quickest setup. You stay entirely within the Railway ecosystem.
    *   **Low Latency:** The database file is stored on the same infrastructure as your bot, ensuring fast access.
    *   **Cost-Effective:** Using a small volume is generally included in Railway's free/hobby tier or is very inexpensive.
*   **Cons:**
    *   **Manual Backups:** You are responsible for backing up the JSON file yourself.
    *   **Scalability Limitations:** If your bot becomes extremely popular with high write volumes, a simple JSON file can become a bottleneck.

#### **Option 2: External Database Service (e.g., Supabase)**

Supabase is a "backend-as-a-service" platform that provides a full-featured PostgreSQL database, authentication, and more.

*   **How it Works:** You would create a project on Supabase, get your database connection credentials, and add them to your bot's environment variables on Railway. Your bot would then connect to Supabase over the internet. This would require replacing `TinyDB` with a PostgreSQL client library like `psycopg2-binary`.
*   **Pros:**
    *   **Highly Scalable:** A real SQL database can handle much more data and concurrent users.
    *   **Managed Service:** Supabase handles backups, security, and maintenance for you.
    *   **Powerful Features:** You get a data browser, user management, and API endpoints out of the box.
*   **Cons:**
    *   **Increased Complexity:** You would need to rewrite your entire `database.py` file to work with PostgreSQL instead of TinyDB. This is a significant code change.
    *   **Potential for Higher Latency:** The database connection happens over the network, which can be slightly slower than a local file.
    *   **Learning Curve:** Requires understanding SQL and managing a new service.

**Recommendation for Your MVP:**

**Stick with Railway's persistent volume and TinyDB.**

For an MVP, the primary goal is to test your idea quickly and with minimal complexity. The combination of TinyDB and a Railway volume is perfectly suited for this. It is robust enough to handle the initial user load, and the setup is incredibly straightforward. You can focus on building bot features rather than managing database infrastructure.

If your bot proves successful and you need to scale, migrating to a service like Supabase is a great next step, but it is unnecessary at this early stage.
</file>

<file path="tasks/markdown parsing issue.md">
# Current Task: user report fail bc of markdown render
Date: 31.07.2025

## What I Want to Fix:
When a user Saba tried to create a report, only a photo was being sent. Railway logs had this message:
2025-07-30 20:41:50,837 - handlers - INFO - User Saba Allahverdi submitted report 1793bd71-5dbb-48ce-9e73-c58973d76d6a

2025-07-30 20:41:50,897 - httpx - INFO - HTTP Request: POST https://api.telegram.org/bot7091434973:AAEdbbggzf8WQhYbZZIp4NLREfe6ajaq4OM/sendPhoto "HTTP/1.1 200 OK"

2025-07-30 20:41:50,901 - httpx - INFO - HTTP Request: POST https://api.telegram.org/bot7091434973:AAEdbbggzf8WQhYbZZIp4NLREfe6ajaq4OM/sendMessage "HTTP/1.1 400 Bad Request"

## Current Problem:
I don't know how to proceed with fixing it.

## Desired Outcome:
Saba should be able to create a crash report in the Telegram bot, and the admin should receive the full information from Saba.

## Gemini 2.5 Pro Plan:
Of course. It's frustrating when a bug like this appears. The "400 Bad Request" error is a classic sign of a specific problem, and we can fix it quickly.

Here’s a simple plan to get your bot working correctly.

### **The Problem Explained Simply**

The error `400 Bad Request` from Telegram's `sendMessage` API almost always means one thing: the text you're trying to send has formatting characters that Telegram doesn't understand.

In your `handlers.py` file, you are sending the admin notification using `parse_mode='Markdown'`. This tells Telegram to look for special characters like \` \_ \* \[ \] and treat them as formatting. Your code correctly uses backticks (\`) to format the `report_id` and `user.id`.

However, you also include the user's `username` and the report `description` directly in the message. If a user's name is `saba_a` or they write a description like "two cars, one is a mini-cooper.", the underscores (`_`) or dashes (`-`) will break Telegram's Markdown parser, causing the entire message to be rejected.

### **A Step-by-Step Plan to Fix This**

We will make a small change to the `notify_admins` function in `handlers.py`. The safest and quickest fix is to simply send the admin notification as plain text. The formatting is less important than the admin actually receiving the information.

**Step 1: Locate the Problematic Code**

1.  Open your project and find the file `handlers.py`.
2.  Inside that file, scroll down to the `notify_admins` function.
3.  Find the `await context.bot.send_message(...)` call inside the `for` loop. It looks like this:

    ```python
    # Inside notify_admins function in handlers.py

    await context.bot.send_message(
        chat_id=admin_id,
        text=admin_message,
        reply_markup=reply_markup,
        parse_mode='Markdown'  # <-- THIS IS THE PROBLEM
    )
    ```

**Step 2: Apply the Fix**

All you need to do is remove the `parse_mode` argument. The message will be sent as plain text, which will prevent any formatting errors.

1.  Change the code to look like this:

    ```python
    # Inside notify_admins function in handlers.py

    await context.bot.send_message(
        chat_id=admin_id,
        text=admin_message,
        reply_markup=reply_markup
    )
    ```
2.  Save the `handlers.py` file.
3.  Deploy the updated code to your server (e.g., Railway.app).

That's it. The bug should now be fixed.

### **What Could Go Wrong**

1.  **Admin message loses formatting**: The admin notification will now be plain text. The Report ID and User ID will no longer have the nice grey code block formatting. This is a minor trade-off for making the feature reliable.
2.  **The error persists**: This is very unlikely. If it does, it means a character in the `admin_message` text is somehow invalid for reasons other than Markdown. If this happens, the next step would be to log the `admin_message` text right before it's sent to see exactly what content is causing the failure.

### **How to Test It**

Follow these steps to ensure the fix is working as expected:

1.  **Restart the conversation**: Open your Telegram bot and type `/cancel` to clear any old session, then `/start` to begin a new report.
2.  **Submit a test report**:
    *   Send the location when prompted.
    *   Send a photo.
    *   When asked for a description, **use text with special characters**. For example, type: `A red car and a blue_car.`
3.  **Confirm submission**: Complete the final steps and submit the report.
4.  **Check the admin account**: Open the Telegram account of one of your admins.
    *   **Expected Outcome:** You should see the photo **and** the text notification arrive successfully. The text will be plain, without any bolding or code blocks, but all the information will be there.
5.  **Check your logs**: Look at your Railway.app logs. You should no longer see the `400 Bad Request` error. You should see two "200 OK" responses, one for `sendPhoto` and one for `sendMessage`.

By following this plan, you should be able to resolve the issue in less than 30 minutes.
## Implementation prompt
## What Worked:
Of course. Dealing with bugs like this can be tricky, but the plan is straightforward. Let's get your bot fixed.

### Step 1: Making the Admin Notification Robust

First, I'll address the core issue. To prevent special characters in usernames or report descriptions from crashing the bot, I will modify the `notify_admins` function. I am removing the Markdown formatting from the notification message, which includes taking out the backticks (`) around the `report_id` and `user.id` and removing the `parse_mode` argument from the `send_message` call.

This ensures the notification is sent as plain text, making it reliable.
Ran tool

Excellent. The fix has been applied to `handlers.py`. The `notify_admins` function will now send plain text messages, which resolves the `400 Bad Request` error.

Now that the main issue is resolved, I recommend we also address a related problem. The `review_handler` function, which processes admin decisions, still uses Markdown to update the admin's message. If a username contains special characters, this could cause a similar crash when an admin approves or rejects a report.

To prevent this, I will remove the Markdown formatting from the `review_handler` as well.
Ran tool

Great, that's another potential issue averted.

To complete the process and ensure the bot is fully robust against this type of error, I will make one final change. The notification sent to the original user after an admin reviews their report also uses Markdown. I'll update that to be plain text as well for consistency and to prevent any future issues.
Ran tool
That's the final change. We have now removed all instances of `parse_mode='Markdown'` that could cause issues with user-generated content. Your bot should now be much more robust.

The bug is fixed. Before you deploy, I recommend you follow the test plan outlined in `current-task.md` to be certain everything is working as expected. Let me know if you have any other questions.

## What Didn't Work:
- 

## For Next Time:
-
</file>

<file path=".gitignore">
cat > .gitignore << 'EOF'
.env
venv/
__pycache__/
*.pyc
db.json
.DS_Store
EOF
</file>

<file path="bot.py">
# bot.py - Simplified version after Railway teardown fix
import logging
import asyncio
from telegram.ext import (
    Application,
    ConversationHandler,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)
from config import TELEGRAM_BOT_TOKEN
from handlers import (
    start,
    location,
    photo,
    description,
    description_skip,
    crash_time_delta,
    submit,
    cancel,
    review_handler,
    odeme_command,
    bakiye_command,
    kurallar_command,
    destek_command, # <-- ADD THIS IMPORT
    LOCATION,
    PHOTO,
    DESCRIPTION,
    CRASH_TIME_DELTA,
    CONFIRMATION,
)
from localization import STRINGS

# Simple logging setup
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", 
    level=logging.INFO
)
logger = logging.getLogger(__name__)

def main() -> None:
    """Run the bot - simplified version."""
    
    # Create the Application with minimal timeout config
    application = (
        Application.builder()
        .token(TELEGRAM_BOT_TOKEN)
        .get_updates_read_timeout(30)
        .get_updates_write_timeout(30)
        .get_updates_connect_timeout(30)
        .build()
    )

    # Add conversation handler
    conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler("start", start),
            MessageHandler(filters.Regex(f"^{STRINGS['new_report_button']}$"), start),
        ],
        states={
            LOCATION: [MessageHandler(filters.LOCATION, location)],
            PHOTO: [MessageHandler(filters.PHOTO, photo)],
            DESCRIPTION: [
                MessageHandler(filters.Regex(f"(?i)^{STRINGS['skip_button']}$"), description_skip),
                MessageHandler(filters.TEXT & ~filters.COMMAND, description),
            ],
            CRASH_TIME_DELTA: [MessageHandler(filters.TEXT & ~filters.COMMAND, crash_time_delta)],
            CONFIRMATION: [
                MessageHandler(filters.Regex(f"(?i)^{STRINGS['submit_report_button']}$"), submit),
                MessageHandler(filters.Regex(f"(?i)^{STRINGS['cancel_button']}$"), cancel),
            ],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
        per_message=False
    )

    application.add_handler(conv_handler)
    application.add_handler(CallbackQueryHandler(review_handler))

    # --- Register command handlers ---
    application.add_handler(CommandHandler("odeme", odeme_command))
    application.add_handler(CommandHandler("bakiye", bakiye_command))
    application.add_handler(CommandHandler("kurallar", kurallar_command))
    application.add_handler(CommandHandler("destek", destek_command))

    # --- Register text button handlers ---
    application.add_handler(MessageHandler(filters.Regex(f"^{STRINGS['balance_button']}$"), bakiye_command))
    application.add_handler(MessageHandler(filters.Regex(f"^{STRINGS['rules_button']}$"), kurallar_command))
    application.add_handler(MessageHandler(filters.Regex(f"^{STRINGS['support_button']}$"), destek_command))


    logger.info("Starting KazaBot...")
    
    # Simple polling - no complex retry logic needed
    application.run_polling(
        poll_interval=2.0,
        drop_pending_updates=True
    )

if __name__ == "__main__":
    main()
</file>

<file path="config.py">
# config.py - Configuration management
import os
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Bot configuration - Changed from TELEGRAM_TOKEN to TELEGRAM_BOT_TOKEN
TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
if not TELEGRAM_BOT_TOKEN:
    raise ValueError("No TELEGRAM_BOT_TOKEN found in environment variables")

# Database configuration
# Use Railway volume for persistent storage
DATABASE_PATH = os.environ.get('RAILWAY_VOLUME_MOUNT_PATH', '')
if DATABASE_PATH:
    DATABASE_PATH = os.path.join(DATABASE_PATH, 'kazabot_db.json')
else:
    # Fallback for local development
    DATABASE_PATH = 'kazabot_db.json'

# Validation constraints
MAX_DESCRIPTION_LENGTH = 200
MIN_CRASH_TIME = 0  # minutes
MAX_CRASH_TIME = 60  # minutes
MAX_REPORTS_PER_DAY = 3
PAYOUT_THRESHOLD = 500  # TL

# --- Add these new constants for the rules ---
REWARD_AMOUNT = 100 # TL
SERVICE_ZONES_TEXT = "İzmir — Buca ve Gaziemir ilçeleri"

# Conversation states
LOCATION, PHOTO, DESCRIPTION, CRASH_TIME_DELTA, CONFIRMATION = range(5)

# --- Load Admin User IDs from .env file ---
admin_ids_str = os.getenv('ADMIN_IDS', '') # Get the comma-separated string

# Process the string into a list of integers
if admin_ids_str:
    try:
        # Split the string by commas and convert each part to an integer
        ADMIN_IDS = [int(admin_id.strip()) for admin_id in admin_ids_str.split(',')]
    except ValueError:
        print("Error: ADMIN_IDS in .env file contains non-numeric values. Please check it.")
        ADMIN_IDS = [] # Default to an empty list on error
else:
    # If the variable is not set, default to an empty list
    ADMIN_IDS = []

# It's good practice to log or print the loaded admins on startup to verify
if not ADMIN_IDS:
    print("Warning: No ADMIN_IDS found in .env file. Admin features will be disabled.")
else:
    print(f"Admin users loaded successfully: {ADMIN_IDS}")
</file>

<file path="database.py">
# database.py
import uuid
import logging
from datetime import datetime, timedelta
from tinydb import TinyDB, Query
from config import DATABASE_PATH

# Enable logging
logger = logging.getLogger(__name__)

# Initialize the database with the path from config
db = TinyDB(DATABASE_PATH, indent=4)
reports_table = db.table('reports')
users_table = db.table('users')

def save_report(user_id, report_data):
    """
    Saves a new accident report to the database.
    """
    report_id = str(uuid.uuid4())
    submitted_at = datetime.utcnow().isoformat()

    report = {
        'report_id': report_id,
        'telegram_user_id': user_id,
        'location_geo': report_data.get('location'),
        'location_time': report_data.get('location_timestamp'),
        'photo_file_id': report_data.get('photo'),
        'photo_time': report_data.get('photo_timestamp'),
        'description': report_data.get('description'),
        'crash_time_delta': report_data.get('crash_time_delta'),
        'submitted_at': submitted_at,
        'status': 'pending', # pending/verified/duplicate/rewarded
        'reward_sent': False
    }
    reports_table.insert(report)
    return report_id

def get_or_create_user(user_id, username):
    """
    Retrieves a user profile or creates a new one with an initial balance.
    """
    User = Query()
    user = users_table.get(User.telegram_user_id == user_id)

    if not user:
        user_profile = {
            'telegram_user_id': user_id,
            'username': username,
            'created_at': datetime.utcnow().isoformat(),
            'courier_company': None,
            'payment_method': None,
            'report_count': 0,
            'balance': 99  # NEW: Add initial balance of 99 Lira
        }
        users_table.insert(user_profile)
        return user_profile
    return user

def update_user_balance(user_id, amount_to_add):
    """
    Increments a user's balance by a specified amount.
    """
    User = Query()
    user = users_table.get(User.telegram_user_id == user_id)
    if user:
        # Handle cases where older users might not have a balance field
        current_balance = user.get('balance', 0) 
        new_balance = current_balance + amount_to_add
        users_table.update({'balance': new_balance}, User.telegram_user_id == user_id)
        logger.info(f"Updated balance for user {user_id}. New balance: {new_balance}")
        return new_balance
    return None

def update_user_profile(user_id, data_to_update):
    """
    Updates a user's profile with new information (e.g., company, report count).
    """
    User = Query()
    users_table.update(data_to_update, User.telegram_user_id == user_id)

def get_user_report_count_today(user_id):
    """
    Counts how many reports a user has submitted in the last 24 hours.
    """
    Report = Query()
    twenty_four_hours_ago = (datetime.utcnow() - timedelta(days=1)).isoformat()
    
    user_reports = reports_table.search(
        (Report.telegram_user_id == user_id) & 
        (Report.submitted_at >= twenty_four_hours_ago)
    )
    return len(user_reports)
    # database.py (add these functions)

def get_report_by_id(report_id):
    """Retrieves a single report by its unique ID."""
    Report = Query()
    report = reports_table.get(Report.report_id == report_id)
    return report

def update_report_status(report_id, new_status, admin_id):
    """Updates the status of a report and logs which admin did it."""
    Report = Query()
    reports_table.update(
        {'status': new_status, 'reviewed_by': admin_id}, 
        Report.report_id == report_id
    )

def get_user_by_id(user_id):
    """
    Retrieves a user profile by their Telegram user ID.
    """
    User = Query()
    user = users_table.get(User.telegram_user_id == user_id)
    return user
</file>

<file path="handlers.py">
# handlers.py
import logging
from datetime import datetime
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)
from database import ( 
    save_report, 
    get_or_create_user, 
    update_user_profile,
    get_user_report_count_today,
    get_report_by_id, 
    update_report_status,
    update_user_balance,
    get_user_by_id
)
from config import ADMIN_IDS, PAYOUT_THRESHOLD, REWARD_AMOUNT, SERVICE_ZONES_TEXT
from localization import STRINGS # <-- Import the localized strings

# Enable logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# Define states for the conversation
(
    LOCATION,
    PHOTO,
    DESCRIPTION,
    CRASH_TIME_DELTA,
    CONFIRMATION,
    COMPANY_NAME,
) = range(6)

# Reusable keyboard with localized buttons
NEW_REPORT_KEYBOARD = ReplyKeyboardMarkup(
    [
        [STRINGS['new_report_button']],
        [STRINGS['balance_button'], STRINGS['rules_button'], STRINGS['support_button']]
    ],
    resize_keyboard=True
)

# --- Start & Cancel ---

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Starts the conversation with a localized welcome message."""
    user = update.message.from_user
    logger.info("User %s started the conversation.", user.first_name)
    
    photo_file_id = 'AgACAgQAAxkBAAPCaIu8_FQu7pFVNR7X8AAB5O_shWW2AALfxzEbZKFhUOKlznwiwuHuAQADAgADeAADNgQ' 
    get_or_create_user(user.id, user.username)

    location_keyboard = KeyboardButton(text=STRINGS['share_location_button'], request_location=True)
    custom_keyboard = [[location_keyboard]]
    reply_markup = ReplyKeyboardMarkup(custom_keyboard, resize_keyboard=True, one_time_keyboard=True)

    await context.bot.send_photo(
        chat_id=update.effective_chat.id,
        photo=photo_file_id,
        caption=STRINGS['welcome_caption'],
        reply_markup=reply_markup,
        read_timeout=20,
        write_timeout=20
    )
    return LOCATION

# --- Reporting Flow ---

async def location(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the location and asks for a photo using localized text."""
    user_location = update.message.location
    context.user_data['report'] = {
        'location': (user_location.latitude, user_location.longitude),
        'location_timestamp': datetime.utcnow().isoformat()
    }
    logger.info("Location from %s: %s", update.message.from_user.first_name, user_location)
    
    await update.message.reply_text(
        STRINGS['location_received'],
        reply_markup=ReplyKeyboardRemove(),
    )
    return PHOTO

async def photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the photo and asks for a description using localized text."""
    user_photo = update.message.photo[-1]
    context.user_data['report']['photo'] = user_photo.file_id
    context.user_data['report']['photo_timestamp'] = datetime.utcnow().isoformat()
    
    logger.info("Photo received from %s", update.message.from_user.first_name)
    
    reply_keyboard = [[STRINGS['skip_button']]]
    await update.message.reply_text(
        STRINGS['photo_received'],
        reply_markup=ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True, one_time_keyboard=True),
    )
    return DESCRIPTION

async def description(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the description and asks for the time delta using localized text."""
    user_description = update.message.text
    if user_description.lower() != STRINGS['skip_button'].lower():
        if len(user_description) > 200:
            await update.message.reply_text(STRINGS['description_too_long'])
            return DESCRIPTION
        context.user_data['report']['description'] = user_description
    else:
        context.user_data['report']['description'] = None
        
    logger.info("Description from %s: %s", update.message.from_user.first_name, user_description)
    await update.message.reply_text(
        STRINGS['ask_crash_time'],
        reply_markup=ReplyKeyboardRemove(),
    )
    return CRASH_TIME_DELTA

async def description_skip(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Skips the description and asks for the time delta using localized text."""
    context.user_data['report']['description'] = None
    logger.info("User %s skipped the description.", update.message.from_user.first_name)
    await update.message.reply_text(
        STRINGS['ask_crash_time'],
        reply_markup=ReplyKeyboardRemove(),
    )
    return CRASH_TIME_DELTA

async def crash_time_delta(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the time delta and shows a localized summary."""
    text = update.message.text
    try:
        delta = int(text)
        if not (0 <= delta <= 60):
            raise ValueError
        context.user_data['report']['crash_time_delta'] = delta
    except (ValueError, TypeError):
        await update.message.reply_text(STRINGS['invalid_crash_time'])
        return CRASH_TIME_DELTA

    report = context.user_data['report']
    summary = (
        f"{STRINGS['report_summary_header']}\n"
        f"{STRINGS['summary_location']}\n"
        f"{STRINGS['summary_photo']}\n"
        f"{STRINGS['summary_description']}: {report.get('description', 'N/A')}\n"
        f"{STRINGS['summary_crash_time']}: ~{report.get('crash_time_delta')} dakika önce\n\n"
        f"{STRINGS['summary_confirm_prompt']}"
    )
    reply_keyboard = [[STRINGS['submit_report_button'], STRINGS['cancel_button']]]
    await update.message.reply_text(
        summary,
        reply_markup=ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True, one_time_keyboard=True),
    )
    return CONFIRMATION

async def submit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Submits the report and ends the conversation with localized messages."""
    user = update.message.from_user
    report_data = context.user_data.get('report')
    
    if not report_data:
        await update.message.reply_text(STRINGS['generic_error'])
        return ConversationHandler.END

    report_id = save_report(user.id, report_data)
    logger.info("User %s submitted report %s", user.first_name, report_id)

    user_profile = get_or_create_user(user.id, user.username)
    new_count = user_profile.get('report_count', 0) + 1
    update_user_profile(user.id, {'report_count': new_count})
    
    await notify_admins(context, user, report_id, report_data)
    
    await update.message.reply_text(STRINGS['report_submitted'])
    return await finish(update, context)

async def finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Clears user data and shows the final localized message."""
    context.user_data.clear()
    await update.message.reply_text(
        STRINGS['final_message'],
        reply_markup=NEW_REPORT_KEYBOARD,
    )
    return ConversationHandler.END

async def notify_admins(context: ContextTypes.DEFAULT_TYPE, user, report_id, report_data):
    """Sends a localized notification to admins."""
    lat, lon = report_data['location']
    maps_link = f"https://www.google.com/maps/search/?api=1&query={lat},{lon}"

    admin_message = (
        f"{STRINGS['admin_notification_header']}\n\n"
        f"📍 Konum (Google Haritalar):\n{maps_link}\n\n"
        f"{STRINGS['admin_report_id_label']}: {report_id}\n"
        f"{STRINGS['admin_submitted_by_label']}: @{user.username} (ID: {user.id})\n"
        f"{STRINGS['admin_description_label']}: {report_data.get('description', 'N/A')}\n"
        f"{STRINGS['admin_time_delta_label']}: ~{report_data.get('crash_time_delta')} dakika önce"
    )
    
    keyboard = [
        [
            InlineKeyboardButton("✅ Onayla", callback_data=f"approve_{report_id}"),
            InlineKeyboardButton("❌ Reddet", callback_data=f"reject_{report_id}"),
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    for admin_id in ADMIN_IDS:
        try:
            await context.bot.send_photo(chat_id=admin_id, photo=report_data['photo'])
            await context.bot.send_message(
                chat_id=admin_id,
                text=admin_message,
                reply_markup=reply_markup,
                disable_web_page_preview=True
            )
            logger.info(f"Sent notification for report {report_id} to admin {admin_id}")
        except Exception as e:
            logger.error(f"Failed to send notification to admin {admin_id}: {e}")

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancels the conversation with a localized message."""
    user = update.message.from_user
    logger.info("User %s canceled the conversation.", user.first_name)
    context.user_data.clear()
    await update.message.reply_text(
        STRINGS['report_canceled'],
        reply_markup=NEW_REPORT_KEYBOARD,
    )
    return ConversationHandler.END

async def review_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handles admin decisions with localized feedback."""
    query = update.callback_query
    await query.answer()

    admin_user = query.from_user
    action, report_id = query.data.split("_")

    report = get_report_by_id(report_id)
    new_status = "onaylandı" if action == "approve" else "reddedildi"
    update_report_status(report_id, new_status, admin_user.id)
    
    final_text = (
        f"{query.message.text}\n\n{STRINGS['admin_decision_header']}\n"
        f"{STRINGS['admin_status_label']} {new_status.upper()} "
        f"{STRINGS['admin_reviewed_by_label']} @{admin_user.username}."
    )
    await query.edit_message_text(text=final_text)

    original_user_id = report['telegram_user_id']
    user_notification = STRINGS['user_update_notification'].format(report_id=report['report_id'], status=new_status)
    
    if action == 'approve':
        reward_amount = 100
        new_balance = update_user_balance(original_user_id, reward_amount)
        user_notification += STRINGS['user_reward_notification'].format(reward_amount=reward_amount, new_balance=new_balance)
    
    try:
        await context.bot.send_message(
            chat_id=original_user_id,
            text=user_notification,
            parse_mode='Markdown'
        )
    except Exception as e:
        logger.error(f"Failed to send status update to user {original_user_id}: {e}")

async def odeme_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Admin-only payout command with localized responses."""
    admin_user_id = update.message.from_user.id
    if admin_user_id not in ADMIN_IDS:
        await update.message.reply_text(STRINGS['payout_unauthorized'])
        return

    try:
        args = context.args
        if len(args) != 2:
            raise ValueError()
        target_user_id, amount = int(args[0]), int(args[1])

        if amount <= 0:
            await update.message.reply_text(STRINGS['payout_must_be_positive'])
            return

        user = get_user_by_id(target_user_id)
        if not user:
            await update.message.reply_text(STRINGS['payout_user_not_found'].format(user_id=target_user_id))
            return

        current_balance = user.get('balance', 0)
        if current_balance < amount:
            await update.message.reply_text(STRINGS['payout_insufficient_balance'].format(user_id=target_user_id, current_balance=current_balance, amount=amount))
            return

        new_balance = update_user_balance(target_user_id, -amount)
        await update.message.reply_text(STRINGS['payout_success_admin'].format(user_id=target_user_id, amount=amount, new_balance=new_balance))
        
        try:
            await context.bot.send_message(chat_id=target_user_id, text=STRINGS['payout_success_user'].format(amount=amount, new_balance=new_balance))
        except Exception as e:
            logger.error(f"Failed to send payout notification to user {target_user_id}: {e}")
            await update.message.reply_text(STRINGS['payout_notification_failed'].format(user_id=target_user_id))

    except (IndexError, ValueError):
        await update.message.reply_text(STRINGS['payout_usage'])

async def bakiye_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Shows the user their balance using localized text."""
    user = get_or_create_user(update.message.from_user.id, update.message.from_user.username)
    balance = user.get('balance', 0)
    await update.message.reply_text(
        STRINGS['balance_info'].format(balance=balance, payout_threshold=PAYOUT_THRESHOLD),
        reply_markup=NEW_REPORT_KEYBOARD
    )

async def kurallar_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Sends the localized list of rules."""
    rules_text = STRINGS['rules_text'].format(
        reward_amount=REWARD_AMOUNT,
        payout_threshold=PAYOUT_THRESHOLD,
        service_zones=SERVICE_ZONES_TEXT
    )
    await update.message.reply_text(
        text=rules_text,
        reply_markup=NEW_REPORT_KEYBOARD,
        parse_mode='Markdown'
    )

async def destek_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Provides the localized support message."""
    await update.message.reply_text(
        text=STRINGS['support_text'],
        reply_markup=NEW_REPORT_KEYBOARD,
        parse_mode='Markdown',
        disable_web_page_preview=True
    )
</file>

<file path="kazabot_db.json">
{
    "users": {
        "1": {
            "telegram_user_id": 4462330,
            "username": "mrvooooo",
            "created_at": "2025-07-30T18:05:09.870369",
            "courier_company": "Getir",
            "payment_method": null,
            "report_count": 1
        },
        "2": {
            "telegram_user_id": 7127606451,
            "username": "rewd0glamd",
            "created_at": "2025-07-30T19:24:09.028355",
            "courier_company": "Getir",
            "payment_method": null,
            "report_count": 11,
            "balance": 300
        }
    },
    "reports": {
        "1": {
            "report_id": "2d156c1b-68eb-49cb-af1b-00f27707b32d",
            "telegram_user_id": 4462330,
            "location_geo": [
                38.432951,
                27.162072
            ],
            "location_time": "2025-07-30T18:05:31.830144",
            "photo_file_id": "AgACAgIAAxkBAAMFaIpe_EWfcVoX0NSX0mgIQAZB-t0AAqv3MRvjwlFIKRrfjwEHeEIBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T18:05:48.250580",
            "description": "masterful coding",
            "crash_time_delta": 0,
            "submitted_at": "2025-07-30T18:06:15.584885",
            "status": "pending",
            "reward_sent": false
        },
        "2": {
            "report_id": "25405c14-5629-40cf-a3ac-69dd234f499b",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:24:25.945855",
            "photo_file_id": "AgACAgQAAxkBAAMUaIpxf_Nkuum2freWHeVOEQbhdagAAs_LMRtkoVlQR0RDdOuUEjYBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:24:47.503329",
            "description": null,
            "crash_time_delta": 5,
            "submitted_at": "2025-07-30T19:25:02.912718",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "3": {
            "report_id": "e436d6c3-679f-4e35-a3e6-b9a07f362818",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:41:32.081860",
            "photo_file_id": "AgACAgQAAxkBAAMmaIp1eebMWgl_HAN88HD6dyowyPQAAtXLMRtkoVlQZxNh-hoxm-gBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:41:45.601875",
            "description": "Test3: button add",
            "crash_time_delta": 0,
            "submitted_at": "2025-07-30T19:42:04.169922",
            "status": "rejected",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "4": {
            "report_id": "1fa7e2e7-1ae0-4c94-9fa6-7c6c4eb100fc",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:42:27.204362",
            "photo_file_id": "AgACAgQAAxkBAAM0aIp1vnXSYeWzKOGGtQdTR0cerAgAAtfLMRtkoVlQVAPjHxaAMeYBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:42:54.313088",
            "description": null,
            "crash_time_delta": 9,
            "submitted_at": "2025-07-30T19:43:15.203505",
            "status": "rejected",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "5": {
            "report_id": "7faf682c-b7d4-4ff3-89ae-58531ab819b8",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:51:19.351171",
            "photo_file_id": "AgACAgQAAxkBAAMUaIpxf_Nkuum2freWHeVOEQbhdagAAs_LMRtkoVlQR0RDdOuUEjYBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:51:27.247422",
            "description": "Hello",
            "crash_time_delta": 0,
            "submitted_at": "2025-07-30T19:51:39.011673",
            "status": "pending",
            "reward_sent": false
        },
        "6": {
            "report_id": "a12c1c62-c03b-44cd-bb7d-43b5a968c6a5",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T17:45:49.427828",
            "photo_file_id": "AgACAgQAAxkBAAOjaIur2MrnF_ZZcLHVOgeFv813gcgAAsXHMRtkoWFQ5qMeDqtMKSMBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T17:46:00.486139",
            "description": "Djdhdhdhd \ud83d\udc4c//// !!! #$$",
            "crash_time_delta": 9,
            "submitted_at": "2025-07-31T17:46:22.254973",
            "status": "pending",
            "reward_sent": false
        },
        "7": {
            "report_id": "3dc52cdf-b5c6-4696-a0ec-16b3ab8cf0ee",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T17:48:28.763276",
            "photo_file_id": "AgACAgQAAxkBAAOjaIur2MrnF_ZZcLHVOgeFv813gcgAAsXHMRtkoWFQ5qMeDqtMKSMBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T17:48:35.636265",
            "description": "\ud83d\ude0d\ud83d\ude01\ud83d\ude0d\ud83d\ude01\ud83d\udc8b\ud83d\ude2d\ud83d\ude33\ud83d\ude1d",
            "crash_time_delta": 0,
            "submitted_at": "2025-07-31T17:48:57.947763",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "8": {
            "report_id": "779ed8b2-7b0e-485b-93c7-37c0592f2d03",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T18:59:01.366378",
            "photo_file_id": "AgACAgQAAxkBAAPCaIu8_FQu7pFVNR7X8AAB5O_shWW2AALfxzEbZKFhUOKlznwiwuHuAQADAgADeAADNgQ",
            "photo_time": "2025-07-31T18:59:08.259151",
            "description": null,
            "crash_time_delta": 0,
            "submitted_at": "2025-07-31T18:59:15.958670",
            "status": "pending",
            "reward_sent": false
        },
        "9": {
            "report_id": "e96c69da-4df8-46e2-b068-4134bf39c919",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T19:04:44.449882",
            "photo_file_id": "AgACAgQAAxkBAAPSaIu-X_N96rb9pqgfNtU6bBEOoWYAAufHMRtkoWFQ8E_q13bdgZIBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T19:05:03.164804",
            "description": null,
            "crash_time_delta": 5,
            "submitted_at": "2025-07-31T19:05:12.681631",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "10": {
            "report_id": "8d0be8f4-697b-4f20-9f00-68cfcad7d79c",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T19:16:28.425785",
            "photo_file_id": "AgACAgQAAxkBAAPlaIvBGGXUvtjPw3uxGmg_If7jzZIAAunHMRtkoWFQLh9zKtTjSFoBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T19:16:40.508592",
            "description": null,
            "crash_time_delta": 9,
            "submitted_at": "2025-07-31T19:16:47.984138",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "11": {
            "report_id": "a7ab3df7-f31b-4ee9-aae1-82ddf9d3c0fb",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T19:17:30.376216",
            "photo_file_id": "AgACAgQAAxkBAAP2aIvBWBOOx0qV0PiMwmlj3hH5js0AAurHMRtkoWFQ-xoM50j9h94BAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T19:17:44.301290",
            "description": "Balance check",
            "crash_time_delta": 6,
            "submitted_at": "2025-07-31T19:17:57.308006",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "12": {
            "report_id": "fe95bb76-b908-476d-919a-30a97742dbe3",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.433063,
                27.164084
            ],
            "location_time": "2025-08-04T18:51:09.113514",
            "photo_file_id": "AgACAgQAAxkBAAIBO2iRASxIb96ZzY-Wu-IxPGFi1vuXAAJEyzEb1daIUHuIEb9Ro-N4AQADAgADeQADNgQ",
            "photo_time": "2025-08-04T18:51:24.285511",
            "description": null,
            "crash_time_delta": 9,
            "submitted_at": "2025-08-04T18:51:32.320416",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        }
    }
}
</file>

<file path="local_backup.json">
{
    "users": {
        "1": {
            "telegram_user_id": 7127606451,
            "username": "rewd0_glamd",
            "created_at": "2025-08-04T19:42:00.551113",
            "courier_company": null,
            "payment_method": null,
            "report_count": 6,
            "balance": 300
        }
    },
    "reports": {
        "1": {
            "report_id": "ad418dfe-dfb8-46f4-adf8-f40083ccf09d",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.433063,
                27.164084
            ],
            "location_time": "2025-08-04T19:42:09.265550",
            "photo_file_id": "AgACAgQAAxkBAAIBemiRDRwuN1peKBYl4XiLfIwy8HRIAAKByzEb1daIUPhNq2YyYnzaAQADAgADeQADNgQ",
            "photo_time": "2025-08-04T19:42:20.465270",
            "description": "Db volume setup check",
            "crash_time_delta": 0,
            "submitted_at": "2025-08-04T19:42:38.730095",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "2": {
            "report_id": "660f1542-e4e9-4092-8453-3e7bc0b1afd0",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.433063,
                27.164084
            ],
            "location_time": "2025-08-04T19:54:37.394189",
            "photo_file_id": "AgACAgQAAxkBAAIBemiRDRwuN1peKBYl4XiLfIwy8HRIAAKByzEb1daIUPhNq2YyYnzaAQADAgADeQADNgQ",
            "photo_time": "2025-08-04T19:54:44.642142",
            "description": "Volume test 2",
            "crash_time_delta": 2,
            "submitted_at": "2025-08-04T19:54:57.891074",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "3": {
            "report_id": "46e77b99-160b-4859-8c07-71ba941253f4",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.433073,
                27.164059
            ],
            "location_time": "2025-08-04T20:53:47.641928",
            "photo_file_id": "AgACAgQAAxkBAAIBmmiRHeVLCZoOqgoeCKEpzdG8fwNAAAKkyzEb1daIUEHZo4Lh2opdAQADAgADeQADNgQ",
            "photo_time": "2025-08-04T20:53:57.120992",
            "description": "Odeme command 1",
            "crash_time_delta": 1,
            "submitted_at": "2025-08-04T20:54:13.792970",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "4": {
            "report_id": "0b81a7fb-e4d3-4237-904e-b759013e5563",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.433063,
                27.164084
            ],
            "location_time": "2025-08-04T21:19:33.028155",
            "photo_file_id": "AgACAgQAAxkBAAIBmmiRHeVLCZoOqgoeCKEpzdG8fwNAAAKkyzEb1daIUEHZo4Lh2opdAQADAgADeQADNgQ",
            "photo_time": "2025-08-04T21:19:37.340031",
            "description": "Balance check test",
            "crash_time_delta": 1,
            "submitted_at": "2025-08-04T21:19:53.543521",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "5": {
            "report_id": "ab40c22e-5891-45ff-b567-dfa883248db4",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.433063,
                27.164084
            ],
            "location_time": "2025-08-04T21:52:17.653485",
            "photo_file_id": "AgACAgQAAxkBAAIBymiRK6SVJ26WR-qrps9sGOKguEe5AAKvyzEb1daIUDqSEEJeBSkLAQADAgADeQADNgQ",
            "photo_time": "2025-08-04T21:52:36.275527",
            "description": "Rules command test",
            "crash_time_delta": 1,
            "submitted_at": "2025-08-04T21:52:49.480518",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "6": {
            "report_id": "b34e26db-2cbc-4043-aff6-51120d2686ff",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.433173,
                27.163997
            ],
            "location_time": "2025-08-04T22:02:04.271134",
            "photo_file_id": "AgACAgQAAxkBAAIB4miRLejf4DQPw5tdVnKF0vUcX5bnAAKxyzEb1daIUDCf5mGr9DNwAQADAgADeQADNgQ",
            "photo_time": "2025-08-04T22:02:16.241575",
            "description": "Support button",
            "crash_time_delta": 1,
            "submitted_at": "2025-08-04T22:02:28.126975",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        }
    }
}
</file>

<file path="localization.py">
# localization.py

STRINGS = {
    # --- Button Labels ---
    'share_location_button': "Kaza Konumunu Paylaş",
    'new_report_button': "➕ Yeni Rapor",
    'balance_button': "💰 Bakiye",
    'rules_button': "📜 Kurallar",
    'support_button': "📞 Destek",
    'skip_button': "Atla",
    'submit_report_button': "Raporu Gönder",
    'cancel_button': "İptal",

    # --- Welcome & Onboarding ---
    'welcome_caption': (
        "Kazabot'a hoş geldiniz! Bize katıldığınız için hesabınıza 99 ₺ başlangıç bakiyesi ekledik. "
        "Ekibimiz tarafından doğrulanan her kaza raporu için 100 ₺ ödül kazanacaksınız. "
        "Toplam bakiyeniz 500 ₺'ye ulaştığında kazancınızı çekebilirsiniz.\n\n"
        "Hadi başlayalım! Lütfen aşağıdaki butona basarak kazanın konumunu paylaşın."
    ),

    # --- Reporting Flow ---
    'location_received': "Harika! Şimdi, lütfen kazanın net bir fotoğrafını çekip bana gönderin.",
    'photo_received': "Fotoğraf alındı. Şimdi, lütfen kısa bir açıklama ekleyin (ör. 'iki araba, arkadan çarpma'). Bu isteğe bağlıdır. 'Atla' tuşuna basarak da geçebilirsiniz.",
    'description_too_long': "Açıklama çok uzun (en fazla 200 karakter). Lütfen tekrar deneyin.",
    'ask_crash_time': "Anlaşıldı. Kaza yaklaşık kaç dakika önce oldu? (Lütfen 0 ile 60 arasında bir sayı girin)",
    'invalid_crash_time': "Bu geçerli bir sayı değil. Lütfen 0 ile 60 arasında bir sayı girin.",
    'report_summary_header': "--- RAPORUNUZU GÖZDEN GEÇİRİN ---",
    'summary_location': "📍 Konum: Gönderildi",
    'summary_photo': "📸 Fotoğraf: Gönderildi",
    'summary_description': "📝 Açıklama",
    'summary_crash_time': "⏱️ Kaza Zamanı",
    'summary_confirm_prompt': "Her şey doğru mu?",
    'report_submitted': "✅ Başarılı! Raporunuz gönderildi.\n\n",
    'report_canceled': "Rapor iptal edildi. İstediğiniz zaman yenisini başlatabilirsiniz.",
    'generic_error': "Bir şeyler yanlış gitti. Lütfen /start ile yeniden başlayın.",
    'final_message': "Şimdi yeni bir rapor gönderebilir veya bu sohbeti kapatabilirsiniz.",

    # --- User Commands ---
    'balance_info': "💰 Mevcut Bakiyeniz: {balance} ₺\n\nÖdeme talebinde bulunabilmek için ulaşmanız gereken bakiye: {payout_threshold} ₺.",
    'rules_text': (
        "📜 **KazaBot Kuralları**\n\n"
        "• Doğrulanmış raporlar için ödül: **{reward_amount} ₺**.\n"
        "• Ödeme alt limiti: **{payout_threshold} ₺**.\n"
        "• Hizmet bölgelerimiz: **{service_zones}**.\n\n"
        "Lütfen sadece belirtilen hizmet bölgelerindeki kazaları bildirin. İşbirliğiniz için teşekkür ederiz!"
    ),
    'support_text': (
        "Yardıma mı ihtiyacınız var?\n\n"
        "Tüm sorularınız, sorunlarınız veya geri bildirimleriniz için destek ekibimizle doğrudan iletişime geçebilirsiniz. "
        "Lütfen aşağıdaki linke tıklayın:\n\n"
        "➡️ **[Destek Sohbetini Başlat](https://t.me/mrvooooo)**\n\n"
        "Ekibimiz en kısa sürede size yardımcı olacaktır."
    ),

    # --- Admin & System Messages ---
    'admin_notification_header': "🚨 Yeni Kaza Raporu Gönderildi 🚨",
    'admin_report_id_label': "Rapor ID",
    'admin_submitted_by_label': "Gönderen",
    'admin_description_label': "Açıklama",
    'admin_time_delta_label': "Geçen Süre",
    'admin_decision_header': "--- Karar ---",
    'admin_status_label': "Durum",
    'admin_reviewed_by_label': "tarafından",
    'user_update_notification': "GÜNCELLEME: Raporunuz (ID: {report_id}) *{status}* olarak işaretlendi.",
    'user_reward_notification': "\n\nTebrikler! Hesabınıza {reward_amount} TL eklendi. Yeni bakiyeniz {new_balance} TL.",

    # --- Payout Command (Admin) ---
    'payout_unauthorized': "Bu komut sadece yöneticiler içindir.",
    'payout_usage': "Kullanım: /odeme <user_id> <amount>",
    'payout_must_be_positive': "Ödeme tutarı pozitif bir sayı olmalıdır.",
    'payout_user_not_found': "ID'si {user_id} olan kullanıcı bulunamadı.",
    'payout_insufficient_balance': "Kullanıcı {user_id} için yetersiz bakiye.\nMevcut Bakiye: {current_balance} ₺\nÖdeme Tutarı: {amount} ₺",
    'payout_success_admin': "✅ Kullanıcı {user_id} için {amount} ₺ tutarındaki ödeme kaydedildi.\nYeni bakiyesi şimdi {new_balance} ₺.",
    'payout_success_user': "{amount} ₺ tutarındaki ödeme ekibimiz tarafından işlendi! Yeni bakiyeniz {new_balance} ₺.",
    'payout_notification_failed': "⚠️ Kullanıcı {user_id} tarafına bildirim gönderilemedi.",
}
</file>

<file path="next-actions.md">
# **Daenah Bot — Next Actions (Updated)**

> **What's new in this update**
>
> * ✅ Implemented payout logic with `/odeme` command
> * ✅ Added essential user commands (`/bakiye`, `/kurallar`, `/destek`)
> * ✅ Enhanced admin notifications with Google Maps links
> * 🎯 Focus shifted to Turkish localization and enhanced user experience
> * 🎯 Planning for secure payout information collection

---

## ✅ **Completed Features (Foundation Complete)**

### **1) Stable Database Using Railway Volumes**
* **Status:** ✅ Completed
* **Implementation:** Persistent volume mounted at `/data`; DB path set to `/data/kazabot_db.json`

### **2) User Balance & Reward System**
* **Status:** ✅ Completed
* **Features:** Starting balance (99 TL), reward per report (100 TL), real-time updates

### **3) Payout Logic**
* **Status:** ✅ Completed
* **Implementation:** Admin-only `/odeme <user_id> <amount>` command with balance validation

### **4) Essential User Commands**
* **Status:** ✅ Completed
* **Commands:** `/bakiye` (balance), `/kurallar` (rules), `/destek` (support)
* **UI:** Persistent keyboard buttons for easy access

### **5) Enhanced Admin Notifications**
* **Status:** ✅ Completed
* **Feature:** Google Maps link in admin notifications for easy location verification

---

## 🎯 **Current Priority: Localization & UX Enhancement**

### **A) Turkish Localization**

**Why:** Your target users are Turkish motor couriers. Full Turkish localization is essential for adoption.

**Action Plan:**
1. **Create a `localization.py` file** with all user-facing strings:
   ```python
   # localization.py
   STRINGS = {
       'welcome_new_user': (
           "Kazabot'a hoş geldiniz! Size katıldığınız için 99 ₺ başlangıç bakiyesi ekledik. "
           "Ekibimiz tarafından doğrulanan her kaza raporu için 100 ₺ ödül kazanacaksınız. "
           "Toplam bakiyeniz 500 ₺'ye ulaştığında kazançlarınızı çekebilirsiniz.\n\n"
           "Hadi başlayalım! Lütfen aşağıdaki butona basarak kazanın konumunu paylaşın."
       ),
       'welcome_returning_user': (
           "Tekrar hoş geldiniz! Yeni bir kaza raporu oluşturmak için aşağıdaki butona basarak "
           "kazanın konumunu paylaşın."
       ),
       'share_location_button': "Kaza Konumunu Paylaş",
       'location_received': "Harika! Şimdi, kazanın net bir fotoğrafını çekip bana gönderin.",
       # ... add all strings
   }
   ```

2. **Update all handlers** to use the localization strings
3. **Translate button labels** in `NEW_REPORT_KEYBOARD`

### **B) Smart Welcome Message Handling**

**Why:** Returning users shouldn't see the full welcome message when clicking "➕ Yeni Rapor"

**Implementation:**
```python
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user = update.message.from_user
    user_profile = get_or_create_user(user.id, user.username)
    
    # Check if this is a new user or returning user
    is_new_user = user_profile.get('report_count', 0) == 0
    
    # Send appropriate message
    if is_new_user:
        # Send welcome photo and full message
        await context.bot.send_photo(
            chat_id=update.effective_chat.id,
            photo=WELCOME_PHOTO_FILE_ID,
            caption=STRINGS['welcome_new_user'],
            reply_markup=location_request_keyboard
        )
    else:
        # Skip photo, send brief message
        await update.message.reply_text(
            STRINGS['welcome_returning_user'],
            reply_markup=location_request_keyboard
        )
    
    return LOCATION
```

### **C) Rejection Reason Feature**

**Why:** Users need to understand why their reports were rejected to improve future submissions

**Database Update:**
```python
# In update_report_status function
def update_report_status(report_id, new_status, admin_id, rejection_reason=None):
    Report = Query()
    update_data = {'status': new_status, 'reviewed_by': admin_id}
    if rejection_reason:
        update_data['rejection_reason'] = rejection_reason
    reports_table.update(update_data, Report.report_id == report_id)
```

**UI Implementation:**
1. **Add rejection reason buttons** in admin notification:
   ```python
   keyboard = [
       [
           InlineKeyboardButton("✅ Onayla", callback_data=f"approve_{report_id}"),
           InlineKeyboardButton("❌ Reddet", callback_data=f"reject_{report_id}")
       ],
       [
           InlineKeyboardButton("🚫 Bölge Dışı", callback_data=f"reject_zone_{report_id}"),
           InlineKeyboardButton("📸 Belirsiz Fotoğraf", callback_data=f"reject_photo_{report_id}")
       ],
       [
           InlineKeyboardButton("⏰ Geç Bildirim", callback_data=f"reject_late_{report_id}"),
           InlineKeyboardButton("🔄 Mükerrer", callback_data=f"reject_duplicate_{report_id}")
       ]
   ]
   ```

2. **Update review_handler** to process rejection reasons
3. **Include reason in user notification**

---

## 🚀 **Next Priority: Secure Payout Information Collection**

### **D) Automatic Payout Eligibility Detection**

**Implementation Plan:**

1. **Add a check after balance updates:**
   ```python
   # In review_handler, after updating balance
   if new_balance >= PAYOUT_THRESHOLD:
       # Check if we already have payout info
       if not user.get('iban') or not user.get('full_name'):
           await trigger_payout_info_collection(original_user_id, context)
   ```

2. **Create payout information collection flow:**
   ```python
   # New conversation states
   COLLECT_IBAN, COLLECT_NAME, CONFIRM_PAYOUT_INFO = range(7, 10)
   
   async def trigger_payout_info_collection(user_id, context):
       message = (
           "🎉 Tebrikler! Bakiyeniz 500 ₺'ye ulaştı ve ödeme almaya hak kazandınız!\n\n"
           "Ödemenizi işleme alabilmemiz için bazı bilgilere ihtiyacımız var.\n"
           "Lütfen IBAN numaranızı gönderin (TR ile başlamalı):"
       )
       await context.bot.send_message(chat_id=user_id, text=message)
   ```

3. **IBAN validation:**
   ```python
   def validate_iban(iban):
       # Remove spaces and convert to uppercase
       iban = iban.replace(' ', '').upper()
       # Check if it starts with TR and has correct length
       if not iban.startswith('TR') or len(iban) != 26:
           return False
       # Additional validation logic here
       return True
   ```

### **E) Secure Sensitive Data Storage**

**Critical Security Measures:**

1. **Create separate secure database for sensitive data:**
   ```python
   # config.py
   SECURE_DB_PATH = os.path.join(DATABASE_PATH, '..', '.secure_kazabot_db.json')
   
   # database.py
   secure_db = TinyDB(SECURE_DB_PATH, indent=4)
   payout_info_table = secure_db.table('payout_info')
   ```

2. **Update `.gitignore`:**
   ```
   .env
   venv/
   __pycache__/
   *.pyc
   db.json
   .DS_Store
   .secure_kazabot_db.json  # Add this
   *secure*.json            # Add this
   ```

3. **Store sensitive data separately:**
   ```python
   def save_payout_info(user_id, iban, full_name):
       PayoutInfo = Query()
       payout_data = {
           'telegram_user_id': user_id,
           'iban': iban,
           'full_name': full_name,
           'created_at': datetime.utcnow().isoformat(),
           'last_updated': datetime.utcnow().isoformat()
       }
       payout_info_table.upsert(payout_data, PayoutInfo.telegram_user_id == user_id)
   ```

4. **Admin command to view payout info:**
   ```python
   async def odeme_bilgileri_command(update, context):
       # Admin-only command to view user payout info
       if update.message.from_user.id not in ADMIN_IDS:
           return
       
       # Parse user_id from command
       # Fetch and display payout info securely
   ```

---

## 📅 **Implementation Roadmap**

### **Week 1 — Localization & UX**
1. Create `localization.py` with all Turkish translations
2. Implement smart welcome message (new vs returning users)
3. Update all user-facing text to Turkish
4. Test with Turkish-speaking users

### **Week 2 — Enhanced Rejection & Payout Flow**
1. Implement rejection reason buttons and database fields
2. Create payout information collection conversation flow
3. Add IBAN validation
4. Set up secure database for sensitive data
5. Test payout eligibility triggers

### **Week 3 — Security & Polish**
1. Implement secure data access patterns
2. Add admin commands for payout info viewing
3. Create data export functionality for admins
4. Comprehensive testing of all flows

---

## 🔒 **Security Best Practices**

1. **Never log sensitive data** - No IBANs or full names in logs
2. **Separate databases** - Keep financial data in separate, gitignored file
3. **Access control** - Only admins can view payout information
4. **Data minimization** - Only collect what's absolutely necessary
5. **Regular backups** - Implement automated secure backups for Railway

---

## 🎯 **Future Enhancements**

* **Automated IBAN validation** via Turkish bank API
* **Payout batch processing** for admins
* **Export to CSV** for accounting purposes
* **Two-factor confirmation** for large payouts
* **Automated zone checking** using geocoding APIs
* **Multi-language support** (Turkish/English toggle)
</file>

<file path="Procfile">
worker: python bot.py
</file>

<file path="project-description.md">
# **DaenahBot: A Real-Time Car Accident Reporting Telegram Bot**

DaenahBot (KazaBot) is a production-ready Telegram bot designed for motor couriers in Turkey to report minor car accidents in real-time. The bot incentivizes rapid accident reporting through a reward system, streamlining data collection for insurance or emergency response purposes.

## 1. Core Technologies

- **Programming Language:** Python 3.11+
- **Telegram Bot Framework:** `python-telegram-bot` v21.3 for comprehensive bot functionality
- **Database:** `TinyDB` - a lightweight, file-based JSON database with persistent storage
- **Deployment:** Railway.app with persistent volume for data storage
- **Process Management:** Procfile configuration for worker deployment

## 2. Project Structure

The project maintains a clean, modular architecture optimized for production deployment:

- `bot.py`: Main application entry point with simplified polling configuration
- `handlers.py`: Complete conversation flows, command handlers, and user interaction logic
- `database.py`: Database abstraction layer managing all TinyDB operations
- `config.py`: Configuration management with Railway volume integration
- `requirements.txt`: Python dependencies specification
- `Procfile`: Railway deployment configuration
- `local_backup.json`: Local database backup for remote inspection
- `.gitignore`: Git ignore rules for sensitive files
- `tasks/`: Historical development documentation
- `railway.json`: Railway-specific deployment configuration

## 3. Current Implementation Status

### **User Features**

#### **Onboarding Experience**
- **Welcome Image & Message:** Branded welcome photo with clear value proposition
- **Initial Balance:** 99 TL starting balance for new users
- **Clear Expectations:** 100 TL reward per verified report, 500 TL withdrawal threshold
- **Streamlined Flow:** Company name collection disabled for reduced friction
- **Smart Start Handler:** Differentiates between first-time users and returning users via "➕ New Report" button

#### **Report Submission Process**
- **Location Sharing:** GPS coordinates via Telegram's native location feature
- **Photo Upload:** High-resolution accident scene photography
- **Optional Description:** 200-character limit text descriptions
- **Time Recording:** Crash occurrence timing (0-60 minutes ago)
- **Confirmation Review:** Complete summary before submission
- **Persistent UI:** Main menu with "➕ New Report", "💰 Bakiye", "📜 Kurallar", and "📞 Destek" buttons

#### **User Account Management**
- **Automatic Registration:** Seamless user profile creation on first interaction
- **Balance Tracking:** Real-time balance updates with transaction history
- **Report History:** Complete submission and verification tracking
- **Reward Processing:** Automatic balance increments for verified reports
- **Balance Check Command:** `/bakiye` command and button for instant balance viewing
- **Rules Command:** `/kurallar` command displaying reward amounts, thresholds, and service zones
- **Support Command:** `/destek` command providing direct support contact

### **Admin Features**

#### **Real-Time Notification System**
- **Instant Alerts:** Immediate Telegram notifications for new reports
- **Complete Data:** Report ID, user info, description, timing, and photo
- **Google Maps Integration:** Direct clickable link to accident location on Google Maps
- **Inline Review:** Approve/Reject buttons directly in notifications
- **Admin Tracking:** Records which admin reviewed each report

#### **Review Management**
- **Status Updates:** pending → verified/rejected workflow
- **User Notifications:** Automatic feedback on report status changes
- **Balance Management:** Automatic reward distribution for approved reports
- **Audit Trail:** Complete review history with admin attribution

#### **Payout Administration**
- **Admin-Only Command:** `/odeme <user_id> <amount>` for processing payouts
- **Balance Validation:** Ensures sufficient user balance before payout
- **Dual Confirmation:** Notifies both admin and user of successful payout
- **Transaction Logging:** Complete payout history with admin attribution

### **Technical Infrastructure**

#### **Database Persistence**
- **Railway Volume:** Persistent storage at `/data/kazabot_db.json`
- **Remote Access:** Database inspection via `railway ssh -- cat /data/kazabot_db.json > local_backup.json`
- **Backup Strategy:** Local backup files for development and monitoring
- **Data Integrity:** Transaction logging and error recovery

#### **Error Handling & Reliability**
- **Markdown Safety:** Removed all parse_mode='Markdown' to prevent user-generated content crashes
- **Connection Management:** Optimized timeout configurations for Railway deployment
- **Graceful Degradation:** Robust error handling for notification failures
- **State Management:** Consistent conversation state handling across restarts

#### **Security & Configuration**
- **Environment Variables:** Secure token and admin ID management
- **Admin Authorization:** Restricted access to admin-only functions
- **Input Validation:** Comprehensive user input sanitization
- **Rate Limiting:** Built-in spam prevention (currently disabled for MVP)

## 4. Database Schema

The TinyDB database contains two optimized tables:

### **Users Table**
```json
{
  "telegram_user_id": 7127606451,
  "username": "rewd0_glamd",
  "created_at": "2025-08-04T19:42:00.551113",
  "courier_company": null,
  "payment_method": null,
  "report_count": 6,
  "balance": 300
}
```

### **Reports Table**
```json
{
  "report_id": "ad418dfe-dfb8-46f4-adf8-f40083ccf09d",
  "telegram_user_id": 7127606451,
  "location_geo": [38.433063, 27.164084],
  "location_time": "2025-08-04T19:42:09.265550",
  "photo_file_id": "AgACAgQAAxkBAAIBemiRDRwuN1peKBYl4XiLfIwy8HRIAAKByzEb1daIUPhNq2YyYnzaAQADAgADeQADNgQ",
  "photo_time": "2025-08-04T19:42:20.465270",
  "description": "Db volume setup check",
  "crash_time_delta": 0,
  "submitted_at": "2025-08-04T19:42:38.730095",
  "status": "verified",
  "reward_sent": false,
  "reviewed_by": 4462330
}
```

## 5. Production Deployment

### **Railway.app Integration**
- **Persistent Volume:** Mounted at `/data` for database storage
- **Zero-Downtime Deployment:** `RAILWAY_DEPLOYMENT_OVERLAP_SECONDS: 0`
- **Worker Process:** Dedicated bot worker with polling configuration
- **Environment Management:** Secure credential handling via Railway secrets

### **Database Management**
- **Remote Inspection:** `railway ssh -- cat /data/kazabot_db.json > local_backup.json`
- **Backup Strategy:** Regular local backups for monitoring and development
- **Data Persistence:** Survives deployments, restarts, and scaling events
- **Performance:** Optimized TinyDB configuration for production workloads

## 6. Current Metrics & Performance

Based on `local_backup.json`, the system currently manages:
- **Active Users:** 1 user with complete profile
- **Report History:** 6 verified reports
- **Balance Management:** 300 TL in user balances
- **Geographic Coverage:** İzmir, Turkey (Buca and Gaziemir districts)
- **Admin Team:** 1 active reviewer (ID: 4462330)

## 7. Key Implementation Decisions

### **Simplified Architecture**
| **Original Plan** | **Production Implementation** | **Rationale** |
|-------------------|------------------------------|---------------|
| Pydantic models in separate file | Inline validation in handlers | Reduced complexity for MVP |
| Company name mandatory | Optional/disabled | Reduced user friction |
| Complex admin dashboard | Telegram-native inline reviews | Leveraged existing admin workflows |
| PostgreSQL consideration | TinyDB with persistent volume | Optimal simplicity-to-performance ratio |
| Markdown formatting | Plain text communications | Eliminated user-generated content crashes |

### **Production Optimizations**
- **Connection Timeouts:** Optimized for Railway's network characteristics
- **Error Recovery:** Comprehensive exception handling for Telegram API calls
- **State Persistence:** Reliable conversation state management
- **Memory Efficiency:** Streamlined bot configuration for resource optimization

## 8. Current Status: Production-Ready MVP

The bot has successfully transitioned from development to a production-ready state with:

✅ **Persistent Data Storage** - Railway volume implementation complete  
✅ **User Reward System** - Balance tracking and automatic payouts functional  
✅ **Admin Review Workflow** - Complete notification and approval system with Google Maps integration  
✅ **Error-Resistant Communications** - Markdown parsing issues resolved  
✅ **Production Deployment** - Railway.app hosting with zero-downtime deploys  
✅ **Remote Database Access** - SSH-based database inspection capability  
✅ **Payout Administration** - Admin-controlled payout command with balance validation  
✅ **Essential User Commands** - Balance check, rules display, and support contact implemented  
✅ **Enhanced UX** - Persistent button interface for easy navigation  

The system is currently operational and processing real accident reports with a verified reward distribution mechanism and complete payout functionality.
</file>

<file path="railway.json">
{
  "$schema": "https://railway.app/railway.schema.json",
  "environments": {
    "production": {
      "variables": {
        "RAILWAY_DEPLOYMENT_OVERLAP_SECONDS": "0"
      }
    }
  }
}
</file>

<file path="repomix-output-stan-voo-daenahbot.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
tasks/
  Bot Welcome Message and Image.md
  markdown parsing issue.md
.gitignore
bot.py
config.py
database.py
handlers.py
kazabot_db.json
local_backup.json
next-actions.md
Procfile
project-description.md
railway.json
repomix-output-stan-voo-daenahbot.xml
requirements.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="tasks/Bot Welcome Message and Image.md">
Bot Welcome Message and Image.md
Of course. Here is the extracted text, translation, and a comprehensive plan to implement the requested features, along with recommendations for your database strategy.

### **1. Bot Welcome Message and Image**

Here is the extracted text from the image and its English translation.

**Original Turkish Text:**

> **Kazayı Bildir, Kazan!**
> Bu bot üzerinden gördüğünüz trafik kazalarını bize bildirebilir ve kazanç sağlayabilirsiniz.
> 
> 🚗 Kaza yerinden bir fotoğraf çekip, konum bilgisiyle birlikte gönderin.
> ✅ Bilgiler doğrulandıktan sonra, 24 saat içinde hesabınıza 1000 TL yatırılır.
> 📞 Bilgiler doğruysa, destek ekibimiz sizinle iletişime geçecektir.
> 
> Unutmayın, hem hayat kurtarın hem de kazanç sağlayın!

**English Translation:**

> **Report an Accident, Get Rewarded!**
> You can report traffic accidents you see through this bot and earn rewards.
> 
> 🚗 Take a photo at the scene of the accident and send it along with the location information.
> ✅ After the information is verified, 1000 TL will be deposited into your account within 24 hours.
> 📞 If the information is correct, our support team will contact you.
> 
> Don't forget, you can both save lives and earn rewards!

---

### **2. Implementation Plan**

Here is a step-by-step plan to implement all the requested changes in your codebase.

#### **Part A: Add the Welcome Image and Message**

1.  **Get the Image File ID:** To send the image without re-uploading it every time, you need its `file_id`.
    *   Send the image to your bot yourself.
    *   In the bot's console logs, you will see the incoming message data. Find the `file_id` for the photo you sent. It will be a long string of characters.
    *   Copy this `file_id`.

2.  **Update the `start` function in `handlers.py`:** Modify the `start` function to send the photo and the new welcome text.

    ```python
    # handlers.py

    async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """Starts the conversation, shows a welcome message, and asks for the accident location."""
        user = update.message.from_user
        logger.info("User %s started the conversation.", user.first_name)
        
        # --- NEW: Send welcome message and image ---
        # Replace 'YOUR_FILE_ID_HERE' with the actual file_id you obtained
        photo_file_id = 'YOUR_FILE_ID_HERE' 
        welcome_caption = (
            "Welcome to KazaBot!\n\n"
            "Report an Accident, Get Rewarded!\n"
            "You can report traffic accidents you see through this bot and earn rewards.\n\n"
            "🚗 Take a photo at the scene of the accident and send it along with the location information.\n"
            "✅ After the information is verified, you will receive a reward.\n"
            "📞 If the information is correct, our support team will contact you.\n\n"
            "Don't forget, you can both save lives and earn rewards!"
        )
        await context.bot.send_photo(
            chat_id=update.effective_chat.id,
            photo=photo_file_id,
            caption=welcome_caption
        )
        # --- End of new section ---
        
        # Onboard the user if they are new and set initial balance
        get_or_create_user(user.id, user.username)

        location_keyboard = KeyboardButton(text="Share Accident Location", request_location=True)
        custom_keyboard = [[location_keyboard]]
        reply_markup = ReplyKeyboardMarkup(custom_keyboard, resize_keyboard=True, one_time_keyboard=True)

        await update.message.reply_text(
            "Please press the button below to share the accident's location.",
            reply_markup=reply_markup,
        )
        return LOCATION
    ```

#### **Part B: Implement User Balance**

1.  **Update `database.py`:** Modify the user creation function to include the balance and add a function to update it.

    ```python
    # database.py

    def get_or_create_user(user_id, username):
        """
        Retrieves a user profile or creates a new one with an initial balance.
        """
        User = Query()
        user = users_table.get(User.telegram_user_id == user_id)

        if not user:
            user_profile = {
                'telegram_user_id': user_id,
                'username': username,
                'created_at': datetime.utcnow().isoformat(),
                'courier_company': None,
                'payment_method': None,
                'report_count': 0,
                'balance': 99  # NEW: Add initial balance of 99 Lira
            }
            users_table.insert(user_profile)
            return user_profile
        return user

    def update_user_balance(user_id, amount_to_add):
        """
        Increments a user's balance by a specified amount.
        """
        User = Query()
        user = users_table.get(User.telegram_user_id == user_id)
        if user:
            # Handle cases where older users might not have a balance field
            current_balance = user.get('balance', 0) 
            new_balance = current_balance + amount_to_add
            users_table.update({'balance': new_balance}, User.telegram_user_id == user_id)
            logger.info(f"Updated balance for user {user_id}. New balance: {new_balance}")
            return new_balance
        return None
    ```    *Note: You will also need to import `logger` in `database.py` if it's not already there: `import logging` and `logger = logging.getLogger(__name__)`.*

2.  **Update `handlers.py`:** Modify the `review_handler` to award Lira for approved reports.

    ```python
    # handlers.py

    # IMPORTANT: Add the new database function to the imports
    from database import ( 
        save_report, 
        get_or_create_user, 
        update_user_profile,
        get_report_by_id, 
        update_report_status,
        update_user_balance # <-- ADD THIS
    )

    async def review_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        # ... (keep the existing code until the user notification part)

        # Update status and notify the user
        new_status = "verified" if action == "approve" else "rejected"
        update_report_status(report_id, new_status, admin_user.id)
        
        # Update the admin's message to show the result
        final_text = query.message.text + f"\n\n--- Decision ---\nStatus set to *{new_status.upper()}* by @{admin_user.username}."
        await query.edit_message_text(text=final_text, parse_mode='Markdown')

        # Notify the original user
        original_user_id = report['telegram_user_id']
        user_notification = f"UPDATE: Your report (ID: {report_id}) has been *{new_status}*."
        
        if new_status == 'verified':
            # --- NEW: Update balance and notify user ---
            reward_amount = 150 # Define your reward amount here
            new_balance = update_user_balance(original_user_id, reward_amount)
            user_notification += (
                f"\n\nCongratulations! {reward_amount} Lira has been added to your account. "
                f"Your new balance is {new_balance} Lira."
            )
            # --- End of new section ---
        
        try:
            await context.bot.send_message(
                chat_id=original_user_id,
                text=user_notification,
                parse_mode='Markdown'
            )
        except Exception as e:
            logger.error(f"Failed to send status update to user {original_user_id}: {e}")
    ```

#### **Part C: Temporarily Disable "Company Name" Question**

1.  **Update `handlers.py`:** Comment out the logic that asks for the company name.

    ```python
    # handlers.py

    async def submit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """Submits the report, saves it, and ends the conversation."""
        user = update.message.from_user
        report_data = context.user_data.get('report')
        
        if not report_data:
            await update.message.reply_text("Something went wrong. Please start over with /start.")
            return ConversationHandler.END

        # Save the report
        report_id = save_report(user.id, report_data)
        logger.info("User %s submitted report %s", user.first_name, report_id)

        # Update user's report count
        user_profile = get_or_create_user(user.id, user.username)
        new_count = user_profile.get('report_count', 0) + 1
        update_user_profile(user.id, {'report_count': new_count})
        
        # Notify admins
        await notify_admins(context, user, report_id, report_data)
        
        # --- MODIFICATION: Temporarily disable company name question ---
        # if user_profile.get('courier_company') is None:
        #     await update.message.reply_text(
        #         "✅ Success! Your report has been submitted.\n\n"
        #         "To help us, could you tell us which courier company you work for? (e.g., 'Getir', 'Trendyol Go'). This is optional.",
        #          reply_markup=ReplyKeyboardRemove(),
        #     )
        #     return COMPANY_NAME
        # else:
        #     # If company name is known, end the conversation
        #     return await finish(update, context)
        return await finish(update, context) # Always go to the finish state
        # --- End of modification ---

    # --- MODIFICATION: Comment out the unused handler ---
    # async def company_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    #     """Saves the user's courier company and ends the conversation."""
    #     user_id = update.message.from_user.id
    #     company = update.message.text
        
    #     update_user_profile(user_id, {'courier_company': company})
    #     logger.info("User %s set their company to %s", update.message.from_user.first_name, company)
        
    #     await update.message.reply_text("Thank you! Your profile has been updated.")
        
    #     return await finish(update, context)
    # --- End of modification ---
    ```

2.  **Update `bot.py`:** Comment out the unused state in the `ConversationHandler`.

    ```python
    # bot.py

    # ... (other imports)
    from handlers import (
        # ... (other handlers)
        # company_name, # Comment out
        cancel,
        review_handler,
        LOCATION,
        PHOTO,
        DESCRIPTION,
        CRASH_TIME_DELTA,
        CONFIRMATION,
        # COMPANY_NAME, # Comment out
    )

    # ...

    def main() -> None:
        # ...

        conv_handler = ConversationHandler(
            # ...
            states={
                LOCATION: [MessageHandler(filters.LOCATION, location)],
                PHOTO: [MessageHandler(filters.PHOTO, photo)],
                DESCRIPTION: [
                    MessageHandler(filters.Regex(r"(?i)^skip$"), description_skip),
                    MessageHandler(filters.TEXT & ~filters.COMMAND, description),
                ],
                CRASH_TIME_DELTA: [MessageHandler(filters.TEXT & ~filters.COMMAND, crash_time_delta)],
                CONFIRMATION: [
                    MessageHandler(filters.Regex(r"(?i)^Submit Report$"), submit),
                    MessageHandler(filters.Regex(r"(?i)^Cancel$"), cancel),
                ],
                # COMPANY_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, company_name)], # Comment out this line
            },
            fallbacks=[CommandHandler("cancel", cancel)],
            per_message=False 
        )
        # ...
    ```

---

### **3. Database Storage on Railway.app for an MVP**

For an MVP hosted on Railway, you have two excellent choices for handling your `kazabot_db.json` file. Here’s a comparison to help you decide:

#### **Option 1: Railway Persistent Volume (Recommended for MVP)**

Railway allows you to mount a persistent disk, called a "volume," to your service. This volume acts like a small, attached hard drive that doesn't get erased when you deploy new code or restart your service.

*   **How it Works:** You would configure a volume in your Railway project settings and mount it at a specific path (e.g., `/data`). You would then modify your `DATABASE_PATH` in `config.py` to point to this location (e.g., `DATABASE_PATH = '/data/kazabot_db.json'`).
*   **Pros:**
    *   **Simplicity:** It's the easiest and quickest setup. You stay entirely within the Railway ecosystem.
    *   **Low Latency:** The database file is stored on the same infrastructure as your bot, ensuring fast access.
    *   **Cost-Effective:** Using a small volume is generally included in Railway's free/hobby tier or is very inexpensive.
*   **Cons:**
    *   **Manual Backups:** You are responsible for backing up the JSON file yourself.
    *   **Scalability Limitations:** If your bot becomes extremely popular with high write volumes, a simple JSON file can become a bottleneck.

#### **Option 2: External Database Service (e.g., Supabase)**

Supabase is a "backend-as-a-service" platform that provides a full-featured PostgreSQL database, authentication, and more.

*   **How it Works:** You would create a project on Supabase, get your database connection credentials, and add them to your bot's environment variables on Railway. Your bot would then connect to Supabase over the internet. This would require replacing `TinyDB` with a PostgreSQL client library like `psycopg2-binary`.
*   **Pros:**
    *   **Highly Scalable:** A real SQL database can handle much more data and concurrent users.
    *   **Managed Service:** Supabase handles backups, security, and maintenance for you.
    *   **Powerful Features:** You get a data browser, user management, and API endpoints out of the box.
*   **Cons:**
    *   **Increased Complexity:** You would need to rewrite your entire `database.py` file to work with PostgreSQL instead of TinyDB. This is a significant code change.
    *   **Potential for Higher Latency:** The database connection happens over the network, which can be slightly slower than a local file.
    *   **Learning Curve:** Requires understanding SQL and managing a new service.

**Recommendation for Your MVP:**

**Stick with Railway's persistent volume and TinyDB.**

For an MVP, the primary goal is to test your idea quickly and with minimal complexity. The combination of TinyDB and a Railway volume is perfectly suited for this. It is robust enough to handle the initial user load, and the setup is incredibly straightforward. You can focus on building bot features rather than managing database infrastructure.

If your bot proves successful and you need to scale, migrating to a service like Supabase is a great next step, but it is unnecessary at this early stage.
</file>

<file path="tasks/markdown parsing issue.md">
# Current Task: user report fail bc of markdown render
Date: 31.07.2025

## What I Want to Fix:
When a user Saba tried to create a report, only a photo was being sent. Railway logs had this message:
2025-07-30 20:41:50,837 - handlers - INFO - User Saba Allahverdi submitted report 1793bd71-5dbb-48ce-9e73-c58973d76d6a

2025-07-30 20:41:50,897 - httpx - INFO - HTTP Request: POST https://api.telegram.org/bot7091434973:AAEdbbggzf8WQhYbZZIp4NLREfe6ajaq4OM/sendPhoto "HTTP/1.1 200 OK"

2025-07-30 20:41:50,901 - httpx - INFO - HTTP Request: POST https://api.telegram.org/bot7091434973:AAEdbbggzf8WQhYbZZIp4NLREfe6ajaq4OM/sendMessage "HTTP/1.1 400 Bad Request"

## Current Problem:
I don't know how to proceed with fixing it.

## Desired Outcome:
Saba should be able to create a crash report in the Telegram bot, and the admin should receive the full information from Saba.

## Gemini 2.5 Pro Plan:
Of course. It's frustrating when a bug like this appears. The "400 Bad Request" error is a classic sign of a specific problem, and we can fix it quickly.

Here’s a simple plan to get your bot working correctly.

### **The Problem Explained Simply**

The error `400 Bad Request` from Telegram's `sendMessage` API almost always means one thing: the text you're trying to send has formatting characters that Telegram doesn't understand.

In your `handlers.py` file, you are sending the admin notification using `parse_mode='Markdown'`. This tells Telegram to look for special characters like \` \_ \* \[ \] and treat them as formatting. Your code correctly uses backticks (\`) to format the `report_id` and `user.id`.

However, you also include the user's `username` and the report `description` directly in the message. If a user's name is `saba_a` or they write a description like "two cars, one is a mini-cooper.", the underscores (`_`) or dashes (`-`) will break Telegram's Markdown parser, causing the entire message to be rejected.

### **A Step-by-Step Plan to Fix This**

We will make a small change to the `notify_admins` function in `handlers.py`. The safest and quickest fix is to simply send the admin notification as plain text. The formatting is less important than the admin actually receiving the information.

**Step 1: Locate the Problematic Code**

1.  Open your project and find the file `handlers.py`.
2.  Inside that file, scroll down to the `notify_admins` function.
3.  Find the `await context.bot.send_message(...)` call inside the `for` loop. It looks like this:

    ```python
    # Inside notify_admins function in handlers.py

    await context.bot.send_message(
        chat_id=admin_id,
        text=admin_message,
        reply_markup=reply_markup,
        parse_mode='Markdown'  # <-- THIS IS THE PROBLEM
    )
    ```

**Step 2: Apply the Fix**

All you need to do is remove the `parse_mode` argument. The message will be sent as plain text, which will prevent any formatting errors.

1.  Change the code to look like this:

    ```python
    # Inside notify_admins function in handlers.py

    await context.bot.send_message(
        chat_id=admin_id,
        text=admin_message,
        reply_markup=reply_markup
    )
    ```
2.  Save the `handlers.py` file.
3.  Deploy the updated code to your server (e.g., Railway.app).

That's it. The bug should now be fixed.

### **What Could Go Wrong**

1.  **Admin message loses formatting**: The admin notification will now be plain text. The Report ID and User ID will no longer have the nice grey code block formatting. This is a minor trade-off for making the feature reliable.
2.  **The error persists**: This is very unlikely. If it does, it means a character in the `admin_message` text is somehow invalid for reasons other than Markdown. If this happens, the next step would be to log the `admin_message` text right before it's sent to see exactly what content is causing the failure.

### **How to Test It**

Follow these steps to ensure the fix is working as expected:

1.  **Restart the conversation**: Open your Telegram bot and type `/cancel` to clear any old session, then `/start` to begin a new report.
2.  **Submit a test report**:
    *   Send the location when prompted.
    *   Send a photo.
    *   When asked for a description, **use text with special characters**. For example, type: `A red car and a blue_car.`
3.  **Confirm submission**: Complete the final steps and submit the report.
4.  **Check the admin account**: Open the Telegram account of one of your admins.
    *   **Expected Outcome:** You should see the photo **and** the text notification arrive successfully. The text will be plain, without any bolding or code blocks, but all the information will be there.
5.  **Check your logs**: Look at your Railway.app logs. You should no longer see the `400 Bad Request` error. You should see two "200 OK" responses, one for `sendPhoto` and one for `sendMessage`.

By following this plan, you should be able to resolve the issue in less than 30 minutes.
## Implementation prompt
## What Worked:
Of course. Dealing with bugs like this can be tricky, but the plan is straightforward. Let's get your bot fixed.

### Step 1: Making the Admin Notification Robust

First, I'll address the core issue. To prevent special characters in usernames or report descriptions from crashing the bot, I will modify the `notify_admins` function. I am removing the Markdown formatting from the notification message, which includes taking out the backticks (`) around the `report_id` and `user.id` and removing the `parse_mode` argument from the `send_message` call.

This ensures the notification is sent as plain text, making it reliable.
Ran tool

Excellent. The fix has been applied to `handlers.py`. The `notify_admins` function will now send plain text messages, which resolves the `400 Bad Request` error.

Now that the main issue is resolved, I recommend we also address a related problem. The `review_handler` function, which processes admin decisions, still uses Markdown to update the admin's message. If a username contains special characters, this could cause a similar crash when an admin approves or rejects a report.

To prevent this, I will remove the Markdown formatting from the `review_handler` as well.
Ran tool

Great, that's another potential issue averted.

To complete the process and ensure the bot is fully robust against this type of error, I will make one final change. The notification sent to the original user after an admin reviews their report also uses Markdown. I'll update that to be plain text as well for consistency and to prevent any future issues.
Ran tool
That's the final change. We have now removed all instances of `parse_mode='Markdown'` that could cause issues with user-generated content. Your bot should now be much more robust.

The bug is fixed. Before you deploy, I recommend you follow the test plan outlined in `current-task.md` to be certain everything is working as expected. Let me know if you have any other questions.

## What Didn't Work:
- 

## For Next Time:
-
</file>

<file path=".gitignore">
cat > .gitignore << 'EOF'
.env
venv/
__pycache__/
*.pyc
db.json
.DS_Store
EOF
</file>

<file path="bot.py">
# bot.py - Simplified version after Railway teardown fix
import logging
import asyncio
from telegram.ext import (
    Application,
    ConversationHandler,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)
from config import TELEGRAM_BOT_TOKEN
from handlers import (
    start,
    location,
    photo,
    description,
    description_skip,
    crash_time_delta,
    submit,
    cancel,
    review_handler,
    odeme_command,
    bakiye_command,
    kurallar_command,
    destek_command, # <-- ADD THIS IMPORT
    LOCATION,
    PHOTO,
    DESCRIPTION,
    CRASH_TIME_DELTA,
    CONFIRMATION,
)

# Simple logging setup
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", 
    level=logging.INFO
)
logger = logging.getLogger(__name__)

def main() -> None:
    """Run the bot - simplified version."""
    
    # Create the Application with minimal timeout config
    application = (
        Application.builder()
        .token(TELEGRAM_BOT_TOKEN)
        .get_updates_read_timeout(30)
        .get_updates_write_timeout(30)
        .get_updates_connect_timeout(30)
        .build()
    )

    # Add conversation handler
    conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler("start", start),
            MessageHandler(filters.Regex(r"^➕ New Report$"), start),
        ],
        states={
            LOCATION: [MessageHandler(filters.LOCATION, location)],
            PHOTO: [MessageHandler(filters.PHOTO, photo)],
            DESCRIPTION: [
                MessageHandler(filters.Regex(r"(?i)^skip$"), description_skip),
                MessageHandler(filters.TEXT & ~filters.COMMAND, description),
            ],
            CRASH_TIME_DELTA: [MessageHandler(filters.TEXT & ~filters.COMMAND, crash_time_delta)],
            CONFIRMATION: [
                MessageHandler(filters.Regex(r"(?i)^Submit Report$"), submit),
                MessageHandler(filters.Regex(r"(?i)^Cancel$"), cancel),
            ],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
        per_message=False
    )

    application.add_handler(conv_handler)
    application.add_handler(CallbackQueryHandler(review_handler))

    # --- Register command handlers ---
    application.add_handler(CommandHandler("odeme", odeme_command))
    application.add_handler(CommandHandler("bakiye", bakiye_command))
    application.add_handler(CommandHandler("kurallar", kurallar_command))
    application.add_handler(CommandHandler("destek", destek_command)) # <-- ADD THIS

    # --- Register text button handlers ---
    application.add_handler(MessageHandler(filters.Regex(r"^💰 Bakiye$"), bakiye_command))
    application.add_handler(MessageHandler(filters.Regex(r"^📜 Kurallar$"), kurallar_command))
    application.add_handler(MessageHandler(filters.Regex(r"^📞 Destek$"), destek_command)) # <-- ADD THIS


    logger.info("Starting KazaBot...")
    
    # Simple polling - no complex retry logic needed
    application.run_polling(
        poll_interval=2.0,
        drop_pending_updates=True
    )

if __name__ == "__main__":
    main()
</file>

<file path="config.py">
# config.py - Configuration management
import os
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Bot configuration - Changed from TELEGRAM_TOKEN to TELEGRAM_BOT_TOKEN
TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
if not TELEGRAM_BOT_TOKEN:
    raise ValueError("No TELEGRAM_BOT_TOKEN found in environment variables")

# Database configuration
# Use Railway volume for persistent storage
DATABASE_PATH = os.environ.get('RAILWAY_VOLUME_MOUNT_PATH', '')
if DATABASE_PATH:
    DATABASE_PATH = os.path.join(DATABASE_PATH, 'kazabot_db.json')
else:
    # Fallback for local development
    DATABASE_PATH = 'kazabot_db.json'

# Validation constraints
MAX_DESCRIPTION_LENGTH = 200
MIN_CRASH_TIME = 0  # minutes
MAX_CRASH_TIME = 60  # minutes
MAX_REPORTS_PER_DAY = 3
PAYOUT_THRESHOLD = 500  # TL

# --- Add these new constants for the rules ---
REWARD_AMOUNT = 100 # TL
SERVICE_ZONES_TEXT = "İzmir — Buca ve Gaziemir ilçeleri"

# Conversation states
LOCATION, PHOTO, DESCRIPTION, CRASH_TIME_DELTA, CONFIRMATION = range(5)

# --- Load Admin User IDs from .env file ---
admin_ids_str = os.getenv('ADMIN_IDS', '') # Get the comma-separated string

# Process the string into a list of integers
if admin_ids_str:
    try:
        # Split the string by commas and convert each part to an integer
        ADMIN_IDS = [int(admin_id.strip()) for admin_id in admin_ids_str.split(',')]
    except ValueError:
        print("Error: ADMIN_IDS in .env file contains non-numeric values. Please check it.")
        ADMIN_IDS = [] # Default to an empty list on error
else:
    # If the variable is not set, default to an empty list
    ADMIN_IDS = []

# It's good practice to log or print the loaded admins on startup to verify
if not ADMIN_IDS:
    print("Warning: No ADMIN_IDS found in .env file. Admin features will be disabled.")
else:
    print(f"Admin users loaded successfully: {ADMIN_IDS}")
</file>

<file path="database.py">
# database.py
import uuid
import logging
from datetime import datetime, timedelta
from tinydb import TinyDB, Query
from config import DATABASE_PATH

# Enable logging
logger = logging.getLogger(__name__)

# Initialize the database with the path from config
db = TinyDB(DATABASE_PATH, indent=4)
reports_table = db.table('reports')
users_table = db.table('users')

def save_report(user_id, report_data):
    """
    Saves a new accident report to the database.
    """
    report_id = str(uuid.uuid4())
    submitted_at = datetime.utcnow().isoformat()

    report = {
        'report_id': report_id,
        'telegram_user_id': user_id,
        'location_geo': report_data.get('location'),
        'location_time': report_data.get('location_timestamp'),
        'photo_file_id': report_data.get('photo'),
        'photo_time': report_data.get('photo_timestamp'),
        'description': report_data.get('description'),
        'crash_time_delta': report_data.get('crash_time_delta'),
        'submitted_at': submitted_at,
        'status': 'pending', # pending/verified/duplicate/rewarded
        'reward_sent': False
    }
    reports_table.insert(report)
    return report_id

def get_or_create_user(user_id, username):
    """
    Retrieves a user profile or creates a new one with an initial balance.
    """
    User = Query()
    user = users_table.get(User.telegram_user_id == user_id)

    if not user:
        user_profile = {
            'telegram_user_id': user_id,
            'username': username,
            'created_at': datetime.utcnow().isoformat(),
            'courier_company': None,
            'payment_method': None,
            'report_count': 0,
            'balance': 99  # NEW: Add initial balance of 99 Lira
        }
        users_table.insert(user_profile)
        return user_profile
    return user

def update_user_balance(user_id, amount_to_add):
    """
    Increments a user's balance by a specified amount.
    """
    User = Query()
    user = users_table.get(User.telegram_user_id == user_id)
    if user:
        # Handle cases where older users might not have a balance field
        current_balance = user.get('balance', 0) 
        new_balance = current_balance + amount_to_add
        users_table.update({'balance': new_balance}, User.telegram_user_id == user_id)
        logger.info(f"Updated balance for user {user_id}. New balance: {new_balance}")
        return new_balance
    return None

def update_user_profile(user_id, data_to_update):
    """
    Updates a user's profile with new information (e.g., company, report count).
    """
    User = Query()
    users_table.update(data_to_update, User.telegram_user_id == user_id)

def get_user_report_count_today(user_id):
    """
    Counts how many reports a user has submitted in the last 24 hours.
    """
    Report = Query()
    twenty_four_hours_ago = (datetime.utcnow() - timedelta(days=1)).isoformat()
    
    user_reports = reports_table.search(
        (Report.telegram_user_id == user_id) & 
        (Report.submitted_at >= twenty_four_hours_ago)
    )
    return len(user_reports)
    # database.py (add these functions)

def get_report_by_id(report_id):
    """Retrieves a single report by its unique ID."""
    Report = Query()
    report = reports_table.get(Report.report_id == report_id)
    return report

def update_report_status(report_id, new_status, admin_id):
    """Updates the status of a report and logs which admin did it."""
    Report = Query()
    reports_table.update(
        {'status': new_status, 'reviewed_by': admin_id}, 
        Report.report_id == report_id
    )

def get_user_by_id(user_id):
    """
    Retrieves a user profile by their Telegram user ID.
    """
    User = Query()
    user = users_table.get(User.telegram_user_id == user_id)
    return user
</file>

<file path="handlers.py">
# handlers.py
import logging
from datetime import datetime
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)
from database import ( 
    save_report, 
    get_or_create_user, 
    update_user_profile,
    get_user_report_count_today,
    get_report_by_id, 
    update_report_status,
    update_user_balance,
    get_user_by_id
)
from config import ADMIN_IDS, PAYOUT_THRESHOLD, REWARD_AMOUNT, SERVICE_ZONES_TEXT

# Enable logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# Define states for the conversation
(
    LOCATION,
    PHOTO,
    DESCRIPTION,
    CRASH_TIME_DELTA,
    CONFIRMATION,
    COMPANY_NAME,
) = range(6)
# --- Reusable keyboard for main actions ---
NEW_REPORT_KEYBOARD = ReplyKeyboardMarkup(
    [
        ["➕ New Report"],
        ["💰 Bakiye", "📜 Kurallar", "📞 Destek"] # <-- ADDED "Destek"
    ],
    resize_keyboard=True
)

# --- NEW: Define the rules text ---
RULES_TEXT = (
    "📜 **KazaBot Kuralları**\n\n"
    f" We are rewarding verified reports with **{REWARD_AMOUNT} ₺**.\n"
    f" The payout threshold is **{PAYOUT_THRESHOLD} ₺**.\n"
    f" We are currently only servicing **{SERVICE_ZONES_TEXT}**.\n\n"
    "Please only report accidents within the specified service zones. Thank you for your cooperation!"
)

# --- Start & Cancel ---

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Starts the conversation, shows a welcome message, and asks for the accident location."""
    user = update.message.from_user
    logger.info("User %s started the conversation.", user.first_name)
    
    # --- NEW: Send welcome message and image ---
    # Replace 'YOUR_FILE_ID_HERE' with the actual file_id you obtained
    photo_file_id = 'AgACAgQAAxkBAAPCaIu8_FQu7pFVNR7X8AAB5O_shWW2AALfxzEbZKFhUOKlznwiwuHuAQADAgADeAADNgQ' 
    welcome_caption = (
        "Welcome to Kazabot! We've added a starting balance of 99 ₺ to your account for joining us. "
        "For every accident report you submit that is verified by our team, you will earn a 100 ₺ reward. "
        "You can withdraw your earnings once your total balance reaches 500 ₺.\n\n"
        "Let's get started! Please share the accident's location by pressing the button below."
    )
    get_or_create_user(user.id, user.username)

    location_keyboard = KeyboardButton(text="Share Accident Location", request_location=True)
    custom_keyboard = [[location_keyboard]]
    reply_markup = ReplyKeyboardMarkup(custom_keyboard, resize_keyboard=True, one_time_keyboard=True)

    await context.bot.send_photo(
        chat_id=update.effective_chat.id,
        photo=photo_file_id,
        caption=welcome_caption,
        reply_markup=reply_markup,
        read_timeout=20,
        write_timeout=20
    )
    # --- End of new section ---
    
    # Onboard the user if they are new and set initial balance
    

    return LOCATION

# --- Reporting Flow ---

async def location(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the location and asks for a photo."""
    user_location = update.message.location
    context.user_data['report'] = {
        'location': (user_location.latitude, user_location.longitude),
        'location_timestamp': datetime.utcnow().isoformat()
    }
    logger.info("Location from %s: %s", update.message.from_user.first_name, user_location)
    
    await update.message.reply_text(
        "Great! Now, please take a clear photo of the accident and send it to me.",
        reply_markup=ReplyKeyboardRemove(),
    )
    return PHOTO

async def photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the photo and asks for a description."""
    user_photo = update.message.photo[-1] # Get the highest resolution photo
    context.user_data['report']['photo'] = user_photo.file_id
    context.user_data['report']['photo_timestamp'] = datetime.utcnow().isoformat()
    
    logger.info("Photo received from %s", update.message.from_user.first_name)
    
    reply_keyboard = [["Skip"]]
    await update.message.reply_text(
        "Photo received. Now, please add a short description (e.g., 'two cars, rear-end'). "
        "This is optional. You can also type 'Skip'.",
        reply_markup=ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True, one_time_keyboard=True),
    )
    return DESCRIPTION

async def description(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the description and asks for the time delta."""
    user_description = update.message.text
    if user_description.lower() != 'skip':
        if len(user_description) > 200:
            await update.message.reply_text("The description is too long (max 200 characters). Please try again.")
            return DESCRIPTION
        context.user_data['report']['description'] = user_description
    else:
        context.user_data['report']['description'] = None
        
    logger.info("Description from %s: %s", update.message.from_user.first_name, user_description)
    await update.message.reply_text(
        "Got it. Roughly how many minutes ago did the crash happen? (Please enter a number from 0 to 60)",
        reply_markup=ReplyKeyboardRemove(),
    )
    return CRASH_TIME_DELTA

async def description_skip(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Skips the description and asks for the time delta."""
    context.user_data['report']['description'] = None
    logger.info("User %s skipped the description.", update.message.from_user.first_name)
    await update.message.reply_text(
        "Description skipped. Roughly how many minutes ago did the crash happen? (Please enter a number from 0 to 60)",
        reply_markup=ReplyKeyboardRemove(),
    )
    return CRASH_TIME_DELTA


async def crash_time_delta(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the time delta and asks for final confirmation."""
    text = update.message.text
    try:
        delta = int(text)
        if not (0 <= delta <= 60):
            raise ValueError
        context.user_data['report']['crash_time_delta'] = delta
    except (ValueError, TypeError):
        await update.message.reply_text("That's not a valid number. Please enter a number between 0 and 60.")
        return CRASH_TIME_DELTA

    # Show summary
    report = context.user_data['report']
    summary = (
        f"--- REVIEW YOUR REPORT ---\n"
        f"📍 Location: Sent\n"
        f"📸 Photo: Sent\n"
        f"📝 Description: {report.get('description', 'N/A')}\n"
        f"⏱️ Time Since Crash: ~{report.get('crash_time_delta')} minutes ago\n\n"
        "Is everything correct?"
    )
    reply_keyboard = [["Submit Report", "Cancel"]]
    await update.message.reply_text(
        summary,
        reply_markup=ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True, one_time_keyboard=True),
    )
    return CONFIRMATION

async def submit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Submits the report, saves it, and transitions to the final steps."""
    user = update.message.from_user
    report_data = context.user_data.get('report')
    
    if not report_data:
        await update.message.reply_text("Something went wrong. Please start over with /start.")
        return ConversationHandler.END

    # Save the report
    report_id = save_report(user.id, report_data)
    logger.info("User %s submitted report %s", user.first_name, report_id)

    # Update user's report count
    user_profile = get_or_create_user(user.id, user.username)
    new_count = user_profile.get('report_count', 0) + 1
    update_user_profile(user.id, {'report_count': new_count})
    
    # Notify admins
    await notify_admins(context, user, report_id, report_data)
    
    # --- MODIFICATION: Temporarily disable company name question ---
    # if user_profile.get('courier_company') is None:
    #     await update.message.reply_text(
    #         "✅ Success! Your report has been submitted.\n\n"
    #         "To help us, could you tell us which courier company you work for? (e.g., 'Getir', 'Trendyol Go'). This is optional.",
    #          reply_markup=ReplyKeyboardRemove(),
    #     )
    #     return COMPANY_NAME
    # else:
    #     # If company name is known, end the conversation
    #     return await finish(update, context)
    await update.message.reply_text("✅ Success! Your report has been submitted.\n\n")
    return await finish(update, context) # Always go to the finish state
    # --- End of modification ---


# --- MODIFICATION: Comment out the unused handler ---
# async def company_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
#     """Saves the user's courier company and ends the conversation."""
#     user_id = update.message.from_user.id
#     company = update.message.text
    
#     update_user_profile(user_id, {'courier_company': company})
#     logger.info("User %s set their company to %s", update.message.from_user.first_name, company)
    
#     await update.message.reply_text("Thank you! Your profile has been updated.")
    
#     return await finish(update, context)
# --- End of modification ---


async def finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Clears user data and shows the final message with the 'New Report' button."""
    context.user_data.clear()
    await update.message.reply_text(
        "You can now submit a new report or close this chat.",
        reply_markup=NEW_REPORT_KEYBOARD,
    )
    return ConversationHandler.END


async def notify_admins(context: ContextTypes.DEFAULT_TYPE, user, report_id, report_data):
    """Sends a notification with a map link to all admins about a new report."""
    
    # --- NEW: Generate Google Maps link ---
    lat, lon = report_data['location']
    maps_link = f"https://www.google.com/maps/search/?api=1&query={lat},{lon}"
    # --- End of new section ---

    # --- MODIFIED: Updated message text ---
    admin_message = (
        f"🚨 New Accident Report Submitted 🚨\n\n"
        f"📍 Location (Google Maps):\n{maps_link}\n\n" # The link is on its own line for better readability
        f"Report ID: {report_id}\n"
        f"Submitted By: @{user.username} (ID: {user.id})\n"
        f"Description: {report_data.get('description', 'N/A')}\n"
        f"Time Delta: ~{report_data.get('crash_time_delta')} minutes ago"
    )
    # --- End of modification ---
    
    keyboard = [
        [
            InlineKeyboardButton("✅ Approve", callback_data=f"approve_{report_id}"),
            InlineKeyboardButton("❌ Reject", callback_data=f"reject_{report_id}"),
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    for admin_id in ADMIN_IDS:
        try:
            # First, send the photo as before
            await context.bot.send_photo(chat_id=admin_id, photo=report_data['photo'])
            
            # Then, send the updated message with the map link
            await context.bot.send_message(
                chat_id=admin_id,
                text=admin_message,
                reply_markup=reply_markup,
                # No parse_mode needed, Telegram makes links clickable automatically
                disable_web_page_preview=True # Optional: keeps the message compact
            )
            logger.info(f"Sent notification with map link for report {report_id} to admin {admin_id}")
        except Exception as e:
            logger.error(f"Failed to send notification to admin {admin_id}: {e}")


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancels the conversation and shows the 'New Report' button."""
    user = update.message.from_user
    logger.info("User %s canceled the conversation.", user.first_name)
    context.user_data.clear()
    await update.message.reply_text(
        "Report canceled. You can start a new one anytime.",
        reply_markup=NEW_REPORT_KEYBOARD, # Use our new keyboard
    )
    return ConversationHandler.END


async def review_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handles admin decisions from inline keyboard buttons."""
    query = update.callback_query
    await query.answer() # Acknowledge the button press

    admin_user = query.from_user
    action, report_id = query.data.split("_")

    if admin_user.id not in ADMIN_IDS:
        await query.edit_message_text(text="Sorry, you are not authorized to perform this action.")
        return

    report = get_report_by_id(report_id)
    if not report:
        await query.edit_message_text(text=f"Error: Report {report_id} not found.")
        return
    
    if report['status'] != 'pending':
        await query.edit_message_text(text=f"This report has already been reviewed. Status: {report['status']}.")
        return

    # Update status and notify the user
    new_status = "verified" if action == "approve" else "rejected"
    update_report_status(report_id, new_status, admin_user.id)
    
    # Update the admin's message to show the result
    final_text = query.message.text + f"\n\n--- Decision ---\nStatus set to {new_status.upper()} by @{admin_user.username}."
    await query.edit_message_text(text=final_text)

    # Notify the original user
    original_user_id = report['telegram_user_id']
    user_notification = f"UPDATE: Your report (ID: {report['report_id']}) has been {new_status}."
    
    if new_status == 'verified':
        # --- NEW: Update balance and notify user ---
        reward_amount = 100 # Define your reward amount here
        new_balance = update_user_balance(original_user_id, reward_amount)
        user_notification += (
            f"\n\nCongratulations! {reward_amount} TL has been added to your account. "
            f"Your new balance is {new_balance} TL."
        )
        # --- End of new section ---
    
    try:
        await context.bot.send_message(
            chat_id=original_user_id,
            text=user_notification
        )
    except Exception as e:
        logger.error(f"Failed to send status update to user {original_user_id}: {e}")


# --- ADMIN PAYOUT COMMAND ---
async def odeme_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Admin-only command to process a payout: /odeme <user_id> <amount>"""
    admin_user_id = update.message.from_user.id
    if admin_user_id not in ADMIN_IDS:
        await update.message.reply_text("This command is for admins only.")
        logger.warning(f"Unauthorized /odeme attempt by user {admin_user_id}.")
        return

    try:
        args = context.args
        if len(args) != 2:
            raise ValueError("Incorrect number of arguments.")

        target_user_id = int(args[0])
        amount = int(args[1])

        if amount <= 0:
            await update.message.reply_text("Payout amount must be a positive number.")
            return

        user = get_user_by_id(target_user_id)
        if not user:
            await update.message.reply_text(f"User with ID {target_user_id} not found.")
            return

        current_balance = user.get('balance', 0)
        if current_balance < amount:
            await update.message.reply_text(
                f"Insufficient balance for user {target_user_id}.\n"
                f"Current Balance: {current_balance} ₺\n"
                f"Payout Amount: {amount} ₺"
            )
            return

        # Subtract from balance by providing a negative amount
        new_balance = update_user_balance(target_user_id, -amount)

        # Confirmation message to the admin
        await update.message.reply_text(
            f"✅ Payout of {amount} ₺ for user {target_user_id} has been recorded.\n"
            f"Their new balance is now {new_balance} ₺."
        )
        logger.info(f"Admin {admin_user_id} processed a payout of {amount} ₺ for user {target_user_id}.")

        # Notification message to the user
        try:
            await context.bot.send_message(
                chat_id=target_user_id,
                text=f"A payout of {amount} ₺ has been processed by our team! Your new balance is {new_balance} ₺."
            )
        except Exception as e:
            logger.error(f"Failed to send payout notification to user {target_user_id}: {e}")
            await update.message.reply_text(f"⚠️ Could not send notification to user {target_user_id}.")

    except (IndexError, ValueError):
        await update.message.reply_text("Usage: /odeme <user_id> <amount>")

# --- NEW: USER BALANCE COMMAND ---
async def bakiye_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Shows the user their current balance and the payout threshold."""
    user_id = update.message.from_user.id
    # get_or_create_user handles new and existing users perfectly here
    user = get_or_create_user(user_id, update.message.from_user.username)
    balance = user.get('balance', 0)

    # Use the keyboard we defined earlier for a consistent experience
    await update.message.reply_text(
        f"💰 Mevcut Bakiyeniz: {balance} ₺\n\n"
        f"Ödeme talebinde bulunabilmek için ulaşmanız gereken bakiye: {PAYOUT_THRESHOLD} ₺.",
        reply_markup=NEW_REPORT_KEYBOARD
    )

# --- NEW: USER RULES COMMAND ---
async def kurallar_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Sends the user the predefined list of rules."""
    await update.message.reply_text(
        text=RULES_TEXT,
        reply_markup=NEW_REPORT_KEYBOARD, # Keep the main keyboard visible
        parse_mode='Markdown' # Use Markdown to make it look nicer
    )

# --- NEW: USER SUPPORT COMMAND ---
async def destek_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Provides the user with a direct link to the support chat."""
    support_username = "DaenahSupport"  # <-- Your actual support account username
    support_message = (
        "Yardıma mı ihtiyacınız var?\n\n"
        "Tüm sorularınız, sorunlarınız veya geri bildirimleriniz için destek ekibimizle doğrudan iletişime geçebilirsiniz. "
        f"Lütfen aşağıdaki linke tıklayın:\n\n"
        f"➡️ **[Destek Sohbetini Başlat](https://t.me/mrvooooo)**\n\n"
        "Ekibimiz en kısa sürede size yardımcı olacaktır."
    )
    await update.message.reply_text(
        text=support_message,
        reply_markup=NEW_REPORT_KEYBOARD,
        parse_mode='Markdown',
        disable_web_page_preview=True # Keeps the message clean
    )
</file>

<file path="kazabot_db.json">
{
    "users": {
        "1": {
            "telegram_user_id": 4462330,
            "username": "mrvooooo",
            "created_at": "2025-07-30T18:05:09.870369",
            "courier_company": "Getir",
            "payment_method": null,
            "report_count": 1
        },
        "2": {
            "telegram_user_id": 7127606451,
            "username": "rewd0glamd",
            "created_at": "2025-07-30T19:24:09.028355",
            "courier_company": "Getir",
            "payment_method": null,
            "report_count": 11,
            "balance": 300
        }
    },
    "reports": {
        "1": {
            "report_id": "2d156c1b-68eb-49cb-af1b-00f27707b32d",
            "telegram_user_id": 4462330,
            "location_geo": [
                38.432951,
                27.162072
            ],
            "location_time": "2025-07-30T18:05:31.830144",
            "photo_file_id": "AgACAgIAAxkBAAMFaIpe_EWfcVoX0NSX0mgIQAZB-t0AAqv3MRvjwlFIKRrfjwEHeEIBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T18:05:48.250580",
            "description": "masterful coding",
            "crash_time_delta": 0,
            "submitted_at": "2025-07-30T18:06:15.584885",
            "status": "pending",
            "reward_sent": false
        },
        "2": {
            "report_id": "25405c14-5629-40cf-a3ac-69dd234f499b",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:24:25.945855",
            "photo_file_id": "AgACAgQAAxkBAAMUaIpxf_Nkuum2freWHeVOEQbhdagAAs_LMRtkoVlQR0RDdOuUEjYBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:24:47.503329",
            "description": null,
            "crash_time_delta": 5,
            "submitted_at": "2025-07-30T19:25:02.912718",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "3": {
            "report_id": "e436d6c3-679f-4e35-a3e6-b9a07f362818",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:41:32.081860",
            "photo_file_id": "AgACAgQAAxkBAAMmaIp1eebMWgl_HAN88HD6dyowyPQAAtXLMRtkoVlQZxNh-hoxm-gBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:41:45.601875",
            "description": "Test3: button add",
            "crash_time_delta": 0,
            "submitted_at": "2025-07-30T19:42:04.169922",
            "status": "rejected",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "4": {
            "report_id": "1fa7e2e7-1ae0-4c94-9fa6-7c6c4eb100fc",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:42:27.204362",
            "photo_file_id": "AgACAgQAAxkBAAM0aIp1vnXSYeWzKOGGtQdTR0cerAgAAtfLMRtkoVlQVAPjHxaAMeYBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:42:54.313088",
            "description": null,
            "crash_time_delta": 9,
            "submitted_at": "2025-07-30T19:43:15.203505",
            "status": "rejected",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "5": {
            "report_id": "7faf682c-b7d4-4ff3-89ae-58531ab819b8",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:51:19.351171",
            "photo_file_id": "AgACAgQAAxkBAAMUaIpxf_Nkuum2freWHeVOEQbhdagAAs_LMRtkoVlQR0RDdOuUEjYBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:51:27.247422",
            "description": "Hello",
            "crash_time_delta": 0,
            "submitted_at": "2025-07-30T19:51:39.011673",
            "status": "pending",
            "reward_sent": false
        },
        "6": {
            "report_id": "a12c1c62-c03b-44cd-bb7d-43b5a968c6a5",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T17:45:49.427828",
            "photo_file_id": "AgACAgQAAxkBAAOjaIur2MrnF_ZZcLHVOgeFv813gcgAAsXHMRtkoWFQ5qMeDqtMKSMBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T17:46:00.486139",
            "description": "Djdhdhdhd \ud83d\udc4c//// !!! #$$",
            "crash_time_delta": 9,
            "submitted_at": "2025-07-31T17:46:22.254973",
            "status": "pending",
            "reward_sent": false
        },
        "7": {
            "report_id": "3dc52cdf-b5c6-4696-a0ec-16b3ab8cf0ee",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T17:48:28.763276",
            "photo_file_id": "AgACAgQAAxkBAAOjaIur2MrnF_ZZcLHVOgeFv813gcgAAsXHMRtkoWFQ5qMeDqtMKSMBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T17:48:35.636265",
            "description": "\ud83d\ude0d\ud83d\ude01\ud83d\ude0d\ud83d\ude01\ud83d\udc8b\ud83d\ude2d\ud83d\ude33\ud83d\ude1d",
            "crash_time_delta": 0,
            "submitted_at": "2025-07-31T17:48:57.947763",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "8": {
            "report_id": "779ed8b2-7b0e-485b-93c7-37c0592f2d03",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T18:59:01.366378",
            "photo_file_id": "AgACAgQAAxkBAAPCaIu8_FQu7pFVNR7X8AAB5O_shWW2AALfxzEbZKFhUOKlznwiwuHuAQADAgADeAADNgQ",
            "photo_time": "2025-07-31T18:59:08.259151",
            "description": null,
            "crash_time_delta": 0,
            "submitted_at": "2025-07-31T18:59:15.958670",
            "status": "pending",
            "reward_sent": false
        },
        "9": {
            "report_id": "e96c69da-4df8-46e2-b068-4134bf39c919",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T19:04:44.449882",
            "photo_file_id": "AgACAgQAAxkBAAPSaIu-X_N96rb9pqgfNtU6bBEOoWYAAufHMRtkoWFQ8E_q13bdgZIBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T19:05:03.164804",
            "description": null,
            "crash_time_delta": 5,
            "submitted_at": "2025-07-31T19:05:12.681631",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "10": {
            "report_id": "8d0be8f4-697b-4f20-9f00-68cfcad7d79c",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T19:16:28.425785",
            "photo_file_id": "AgACAgQAAxkBAAPlaIvBGGXUvtjPw3uxGmg_If7jzZIAAunHMRtkoWFQLh9zKtTjSFoBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T19:16:40.508592",
            "description": null,
            "crash_time_delta": 9,
            "submitted_at": "2025-07-31T19:16:47.984138",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "11": {
            "report_id": "a7ab3df7-f31b-4ee9-aae1-82ddf9d3c0fb",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T19:17:30.376216",
            "photo_file_id": "AgACAgQAAxkBAAP2aIvBWBOOx0qV0PiMwmlj3hH5js0AAurHMRtkoWFQ-xoM50j9h94BAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T19:17:44.301290",
            "description": "Balance check",
            "crash_time_delta": 6,
            "submitted_at": "2025-07-31T19:17:57.308006",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "12": {
            "report_id": "fe95bb76-b908-476d-919a-30a97742dbe3",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.433063,
                27.164084
            ],
            "location_time": "2025-08-04T18:51:09.113514",
            "photo_file_id": "AgACAgQAAxkBAAIBO2iRASxIb96ZzY-Wu-IxPGFi1vuXAAJEyzEb1daIUHuIEb9Ro-N4AQADAgADeQADNgQ",
            "photo_time": "2025-08-04T18:51:24.285511",
            "description": null,
            "crash_time_delta": 9,
            "submitted_at": "2025-08-04T18:51:32.320416",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        }
    }
}
</file>

<file path="local_backup.json">
{
    "users": {
        "1": {
            "telegram_user_id": 7127606451,
            "username": "rewd0_glamd",
            "created_at": "2025-08-04T19:42:00.551113",
            "courier_company": null,
            "payment_method": null,
            "report_count": 6,
            "balance": 300
        }
    },
    "reports": {
        "1": {
            "report_id": "ad418dfe-dfb8-46f4-adf8-f40083ccf09d",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.433063,
                27.164084
            ],
            "location_time": "2025-08-04T19:42:09.265550",
            "photo_file_id": "AgACAgQAAxkBAAIBemiRDRwuN1peKBYl4XiLfIwy8HRIAAKByzEb1daIUPhNq2YyYnzaAQADAgADeQADNgQ",
            "photo_time": "2025-08-04T19:42:20.465270",
            "description": "Db volume setup check",
            "crash_time_delta": 0,
            "submitted_at": "2025-08-04T19:42:38.730095",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "2": {
            "report_id": "660f1542-e4e9-4092-8453-3e7bc0b1afd0",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.433063,
                27.164084
            ],
            "location_time": "2025-08-04T19:54:37.394189",
            "photo_file_id": "AgACAgQAAxkBAAIBemiRDRwuN1peKBYl4XiLfIwy8HRIAAKByzEb1daIUPhNq2YyYnzaAQADAgADeQADNgQ",
            "photo_time": "2025-08-04T19:54:44.642142",
            "description": "Volume test 2",
            "crash_time_delta": 2,
            "submitted_at": "2025-08-04T19:54:57.891074",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "3": {
            "report_id": "46e77b99-160b-4859-8c07-71ba941253f4",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.433073,
                27.164059
            ],
            "location_time": "2025-08-04T20:53:47.641928",
            "photo_file_id": "AgACAgQAAxkBAAIBmmiRHeVLCZoOqgoeCKEpzdG8fwNAAAKkyzEb1daIUEHZo4Lh2opdAQADAgADeQADNgQ",
            "photo_time": "2025-08-04T20:53:57.120992",
            "description": "Odeme command 1",
            "crash_time_delta": 1,
            "submitted_at": "2025-08-04T20:54:13.792970",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "4": {
            "report_id": "0b81a7fb-e4d3-4237-904e-b759013e5563",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.433063,
                27.164084
            ],
            "location_time": "2025-08-04T21:19:33.028155",
            "photo_file_id": "AgACAgQAAxkBAAIBmmiRHeVLCZoOqgoeCKEpzdG8fwNAAAKkyzEb1daIUEHZo4Lh2opdAQADAgADeQADNgQ",
            "photo_time": "2025-08-04T21:19:37.340031",
            "description": "Balance check test",
            "crash_time_delta": 1,
            "submitted_at": "2025-08-04T21:19:53.543521",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "5": {
            "report_id": "ab40c22e-5891-45ff-b567-dfa883248db4",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.433063,
                27.164084
            ],
            "location_time": "2025-08-04T21:52:17.653485",
            "photo_file_id": "AgACAgQAAxkBAAIBymiRK6SVJ26WR-qrps9sGOKguEe5AAKvyzEb1daIUDqSEEJeBSkLAQADAgADeQADNgQ",
            "photo_time": "2025-08-04T21:52:36.275527",
            "description": "Rules command test",
            "crash_time_delta": 1,
            "submitted_at": "2025-08-04T21:52:49.480518",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "6": {
            "report_id": "b34e26db-2cbc-4043-aff6-51120d2686ff",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.433173,
                27.163997
            ],
            "location_time": "2025-08-04T22:02:04.271134",
            "photo_file_id": "AgACAgQAAxkBAAIB4miRLejf4DQPw5tdVnKF0vUcX5bnAAKxyzEb1daIUDCf5mGr9DNwAQADAgADeQADNgQ",
            "photo_time": "2025-08-04T22:02:16.241575",
            "description": "Support button",
            "crash_time_delta": 1,
            "submitted_at": "2025-08-04T22:02:28.126975",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        }
    }
}
</file>

<file path="next-actions.md">
# **Daenah Bot — Next Actions (Updated)**

> **What's new in this update**
>
> * ✅ Implemented payout logic with `/odeme` command
> * ✅ Added essential user commands (`/bakiye`, `/kurallar`, `/destek`)
> * ✅ Enhanced admin notifications with Google Maps links
> * 🎯 Focus shifted to Turkish localization and enhanced user experience
> * 🎯 Planning for secure payout information collection

---

## ✅ **Completed Features (Foundation Complete)**

### **1) Stable Database Using Railway Volumes**
* **Status:** ✅ Completed
* **Implementation:** Persistent volume mounted at `/data`; DB path set to `/data/kazabot_db.json`

### **2) User Balance & Reward System**
* **Status:** ✅ Completed
* **Features:** Starting balance (99 TL), reward per report (100 TL), real-time updates

### **3) Payout Logic**
* **Status:** ✅ Completed
* **Implementation:** Admin-only `/odeme <user_id> <amount>` command with balance validation

### **4) Essential User Commands**
* **Status:** ✅ Completed
* **Commands:** `/bakiye` (balance), `/kurallar` (rules), `/destek` (support)
* **UI:** Persistent keyboard buttons for easy access

### **5) Enhanced Admin Notifications**
* **Status:** ✅ Completed
* **Feature:** Google Maps link in admin notifications for easy location verification

---

## 🎯 **Current Priority: Localization & UX Enhancement**

### **A) Turkish Localization**

**Why:** Your target users are Turkish motor couriers. Full Turkish localization is essential for adoption.

**Action Plan:**
1. **Create a `localization.py` file** with all user-facing strings:
   ```python
   # localization.py
   STRINGS = {
       'welcome_new_user': (
           "Kazabot'a hoş geldiniz! Size katıldığınız için 99 ₺ başlangıç bakiyesi ekledik. "
           "Ekibimiz tarafından doğrulanan her kaza raporu için 100 ₺ ödül kazanacaksınız. "
           "Toplam bakiyeniz 500 ₺'ye ulaştığında kazançlarınızı çekebilirsiniz.\n\n"
           "Hadi başlayalım! Lütfen aşağıdaki butona basarak kazanın konumunu paylaşın."
       ),
       'welcome_returning_user': (
           "Tekrar hoş geldiniz! Yeni bir kaza raporu oluşturmak için aşağıdaki butona basarak "
           "kazanın konumunu paylaşın."
       ),
       'share_location_button': "Kaza Konumunu Paylaş",
       'location_received': "Harika! Şimdi, kazanın net bir fotoğrafını çekip bana gönderin.",
       # ... add all strings
   }
   ```

2. **Update all handlers** to use the localization strings
3. **Translate button labels** in `NEW_REPORT_KEYBOARD`

### **B) Smart Welcome Message Handling**

**Why:** Returning users shouldn't see the full welcome message when clicking "➕ Yeni Rapor"

**Implementation:**
```python
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user = update.message.from_user
    user_profile = get_or_create_user(user.id, user.username)
    
    # Check if this is a new user or returning user
    is_new_user = user_profile.get('report_count', 0) == 0
    
    # Send appropriate message
    if is_new_user:
        # Send welcome photo and full message
        await context.bot.send_photo(
            chat_id=update.effective_chat.id,
            photo=WELCOME_PHOTO_FILE_ID,
            caption=STRINGS['welcome_new_user'],
            reply_markup=location_request_keyboard
        )
    else:
        # Skip photo, send brief message
        await update.message.reply_text(
            STRINGS['welcome_returning_user'],
            reply_markup=location_request_keyboard
        )
    
    return LOCATION
```

### **C) Rejection Reason Feature**

**Why:** Users need to understand why their reports were rejected to improve future submissions

**Database Update:**
```python
# In update_report_status function
def update_report_status(report_id, new_status, admin_id, rejection_reason=None):
    Report = Query()
    update_data = {'status': new_status, 'reviewed_by': admin_id}
    if rejection_reason:
        update_data['rejection_reason'] = rejection_reason
    reports_table.update(update_data, Report.report_id == report_id)
```

**UI Implementation:**
1. **Add rejection reason buttons** in admin notification:
   ```python
   keyboard = [
       [
           InlineKeyboardButton("✅ Onayla", callback_data=f"approve_{report_id}"),
           InlineKeyboardButton("❌ Reddet", callback_data=f"reject_{report_id}")
       ],
       [
           InlineKeyboardButton("🚫 Bölge Dışı", callback_data=f"reject_zone_{report_id}"),
           InlineKeyboardButton("📸 Belirsiz Fotoğraf", callback_data=f"reject_photo_{report_id}")
       ],
       [
           InlineKeyboardButton("⏰ Geç Bildirim", callback_data=f"reject_late_{report_id}"),
           InlineKeyboardButton("🔄 Mükerrer", callback_data=f"reject_duplicate_{report_id}")
       ]
   ]
   ```

2. **Update review_handler** to process rejection reasons
3. **Include reason in user notification**

---

## 🚀 **Next Priority: Secure Payout Information Collection**

### **D) Automatic Payout Eligibility Detection**

**Implementation Plan:**

1. **Add a check after balance updates:**
   ```python
   # In review_handler, after updating balance
   if new_balance >= PAYOUT_THRESHOLD:
       # Check if we already have payout info
       if not user.get('iban') or not user.get('full_name'):
           await trigger_payout_info_collection(original_user_id, context)
   ```

2. **Create payout information collection flow:**
   ```python
   # New conversation states
   COLLECT_IBAN, COLLECT_NAME, CONFIRM_PAYOUT_INFO = range(7, 10)
   
   async def trigger_payout_info_collection(user_id, context):
       message = (
           "🎉 Tebrikler! Bakiyeniz 500 ₺'ye ulaştı ve ödeme almaya hak kazandınız!\n\n"
           "Ödemenizi işleme alabilmemiz için bazı bilgilere ihtiyacımız var.\n"
           "Lütfen IBAN numaranızı gönderin (TR ile başlamalı):"
       )
       await context.bot.send_message(chat_id=user_id, text=message)
   ```

3. **IBAN validation:**
   ```python
   def validate_iban(iban):
       # Remove spaces and convert to uppercase
       iban = iban.replace(' ', '').upper()
       # Check if it starts with TR and has correct length
       if not iban.startswith('TR') or len(iban) != 26:
           return False
       # Additional validation logic here
       return True
   ```

### **E) Secure Sensitive Data Storage**

**Critical Security Measures:**

1. **Create separate secure database for sensitive data:**
   ```python
   # config.py
   SECURE_DB_PATH = os.path.join(DATABASE_PATH, '..', '.secure_kazabot_db.json')
   
   # database.py
   secure_db = TinyDB(SECURE_DB_PATH, indent=4)
   payout_info_table = secure_db.table('payout_info')
   ```

2. **Update `.gitignore`:**
   ```
   .env
   venv/
   __pycache__/
   *.pyc
   db.json
   .DS_Store
   .secure_kazabot_db.json  # Add this
   *secure*.json            # Add this
   ```

3. **Store sensitive data separately:**
   ```python
   def save_payout_info(user_id, iban, full_name):
       PayoutInfo = Query()
       payout_data = {
           'telegram_user_id': user_id,
           'iban': iban,
           'full_name': full_name,
           'created_at': datetime.utcnow().isoformat(),
           'last_updated': datetime.utcnow().isoformat()
       }
       payout_info_table.upsert(payout_data, PayoutInfo.telegram_user_id == user_id)
   ```

4. **Admin command to view payout info:**
   ```python
   async def odeme_bilgileri_command(update, context):
       # Admin-only command to view user payout info
       if update.message.from_user.id not in ADMIN_IDS:
           return
       
       # Parse user_id from command
       # Fetch and display payout info securely
   ```

---

## 📅 **Implementation Roadmap**

### **Week 1 — Localization & UX**
1. Create `localization.py` with all Turkish translations
2. Implement smart welcome message (new vs returning users)
3. Update all user-facing text to Turkish
4. Test with Turkish-speaking users

### **Week 2 — Enhanced Rejection & Payout Flow**
1. Implement rejection reason buttons and database fields
2. Create payout information collection conversation flow
3. Add IBAN validation
4. Set up secure database for sensitive data
5. Test payout eligibility triggers

### **Week 3 — Security & Polish**
1. Implement secure data access patterns
2. Add admin commands for payout info viewing
3. Create data export functionality for admins
4. Comprehensive testing of all flows

---

## 🔒 **Security Best Practices**

1. **Never log sensitive data** - No IBANs or full names in logs
2. **Separate databases** - Keep financial data in separate, gitignored file
3. **Access control** - Only admins can view payout information
4. **Data minimization** - Only collect what's absolutely necessary
5. **Regular backups** - Implement automated secure backups for Railway

---

## 🎯 **Future Enhancements**

* **Automated IBAN validation** via Turkish bank API
* **Payout batch processing** for admins
* **Export to CSV** for accounting purposes
* **Two-factor confirmation** for large payouts
* **Automated zone checking** using geocoding APIs
* **Multi-language support** (Turkish/English toggle)
</file>

<file path="Procfile">
worker: python bot.py
</file>

<file path="project-description.md">
# **DaenahBot: A Real-Time Car Accident Reporting Telegram Bot**

DaenahBot (KazaBot) is a production-ready Telegram bot designed for motor couriers in Turkey to report minor car accidents in real-time. The bot incentivizes rapid accident reporting through a reward system, streamlining data collection for insurance or emergency response purposes.

## 1. Core Technologies

- **Programming Language:** Python 3.11+
- **Telegram Bot Framework:** `python-telegram-bot` v21.3 for comprehensive bot functionality
- **Database:** `TinyDB` - a lightweight, file-based JSON database with persistent storage
- **Deployment:** Railway.app with persistent volume for data storage
- **Process Management:** Procfile configuration for worker deployment

## 2. Project Structure

The project maintains a clean, modular architecture optimized for production deployment:

- `bot.py`: Main application entry point with simplified polling configuration
- `handlers.py`: Complete conversation flows, command handlers, and user interaction logic
- `database.py`: Database abstraction layer managing all TinyDB operations
- `config.py`: Configuration management with Railway volume integration
- `requirements.txt`: Python dependencies specification
- `Procfile`: Railway deployment configuration
- `local_backup.json`: Local database backup for remote inspection
- `.gitignore`: Git ignore rules for sensitive files
- `tasks/`: Historical development documentation
- `railway.json`: Railway-specific deployment configuration

## 3. Current Implementation Status

### **User Features**

#### **Onboarding Experience**
- **Welcome Image & Message:** Branded welcome photo with clear value proposition
- **Initial Balance:** 99 TL starting balance for new users
- **Clear Expectations:** 100 TL reward per verified report, 500 TL withdrawal threshold
- **Streamlined Flow:** Company name collection disabled for reduced friction
- **Smart Start Handler:** Differentiates between first-time users and returning users via "➕ New Report" button

#### **Report Submission Process**
- **Location Sharing:** GPS coordinates via Telegram's native location feature
- **Photo Upload:** High-resolution accident scene photography
- **Optional Description:** 200-character limit text descriptions
- **Time Recording:** Crash occurrence timing (0-60 minutes ago)
- **Confirmation Review:** Complete summary before submission
- **Persistent UI:** Main menu with "➕ New Report", "💰 Bakiye", "📜 Kurallar", and "📞 Destek" buttons

#### **User Account Management**
- **Automatic Registration:** Seamless user profile creation on first interaction
- **Balance Tracking:** Real-time balance updates with transaction history
- **Report History:** Complete submission and verification tracking
- **Reward Processing:** Automatic balance increments for verified reports
- **Balance Check Command:** `/bakiye` command and button for instant balance viewing
- **Rules Command:** `/kurallar` command displaying reward amounts, thresholds, and service zones
- **Support Command:** `/destek` command providing direct support contact

### **Admin Features**

#### **Real-Time Notification System**
- **Instant Alerts:** Immediate Telegram notifications for new reports
- **Complete Data:** Report ID, user info, description, timing, and photo
- **Google Maps Integration:** Direct clickable link to accident location on Google Maps
- **Inline Review:** Approve/Reject buttons directly in notifications
- **Admin Tracking:** Records which admin reviewed each report

#### **Review Management**
- **Status Updates:** pending → verified/rejected workflow
- **User Notifications:** Automatic feedback on report status changes
- **Balance Management:** Automatic reward distribution for approved reports
- **Audit Trail:** Complete review history with admin attribution

#### **Payout Administration**
- **Admin-Only Command:** `/odeme <user_id> <amount>` for processing payouts
- **Balance Validation:** Ensures sufficient user balance before payout
- **Dual Confirmation:** Notifies both admin and user of successful payout
- **Transaction Logging:** Complete payout history with admin attribution

### **Technical Infrastructure**

#### **Database Persistence**
- **Railway Volume:** Persistent storage at `/data/kazabot_db.json`
- **Remote Access:** Database inspection via `railway ssh -- cat /data/kazabot_db.json > local_backup.json`
- **Backup Strategy:** Local backup files for development and monitoring
- **Data Integrity:** Transaction logging and error recovery

#### **Error Handling & Reliability**
- **Markdown Safety:** Removed all parse_mode='Markdown' to prevent user-generated content crashes
- **Connection Management:** Optimized timeout configurations for Railway deployment
- **Graceful Degradation:** Robust error handling for notification failures
- **State Management:** Consistent conversation state handling across restarts

#### **Security & Configuration**
- **Environment Variables:** Secure token and admin ID management
- **Admin Authorization:** Restricted access to admin-only functions
- **Input Validation:** Comprehensive user input sanitization
- **Rate Limiting:** Built-in spam prevention (currently disabled for MVP)

## 4. Database Schema

The TinyDB database contains two optimized tables:

### **Users Table**
```json
{
  "telegram_user_id": 7127606451,
  "username": "rewd0_glamd",
  "created_at": "2025-08-04T19:42:00.551113",
  "courier_company": null,
  "payment_method": null,
  "report_count": 6,
  "balance": 300
}
```

### **Reports Table**
```json
{
  "report_id": "ad418dfe-dfb8-46f4-adf8-f40083ccf09d",
  "telegram_user_id": 7127606451,
  "location_geo": [38.433063, 27.164084],
  "location_time": "2025-08-04T19:42:09.265550",
  "photo_file_id": "AgACAgQAAxkBAAIBemiRDRwuN1peKBYl4XiLfIwy8HRIAAKByzEb1daIUPhNq2YyYnzaAQADAgADeQADNgQ",
  "photo_time": "2025-08-04T19:42:20.465270",
  "description": "Db volume setup check",
  "crash_time_delta": 0,
  "submitted_at": "2025-08-04T19:42:38.730095",
  "status": "verified",
  "reward_sent": false,
  "reviewed_by": 4462330
}
```

## 5. Production Deployment

### **Railway.app Integration**
- **Persistent Volume:** Mounted at `/data` for database storage
- **Zero-Downtime Deployment:** `RAILWAY_DEPLOYMENT_OVERLAP_SECONDS: 0`
- **Worker Process:** Dedicated bot worker with polling configuration
- **Environment Management:** Secure credential handling via Railway secrets

### **Database Management**
- **Remote Inspection:** `railway ssh -- cat /data/kazabot_db.json > local_backup.json`
- **Backup Strategy:** Regular local backups for monitoring and development
- **Data Persistence:** Survives deployments, restarts, and scaling events
- **Performance:** Optimized TinyDB configuration for production workloads

## 6. Current Metrics & Performance

Based on `local_backup.json`, the system currently manages:
- **Active Users:** 1 user with complete profile
- **Report History:** 6 verified reports
- **Balance Management:** 300 TL in user balances
- **Geographic Coverage:** İzmir, Turkey (Buca and Gaziemir districts)
- **Admin Team:** 1 active reviewer (ID: 4462330)

## 7. Key Implementation Decisions

### **Simplified Architecture**
| **Original Plan** | **Production Implementation** | **Rationale** |
|-------------------|------------------------------|---------------|
| Pydantic models in separate file | Inline validation in handlers | Reduced complexity for MVP |
| Company name mandatory | Optional/disabled | Reduced user friction |
| Complex admin dashboard | Telegram-native inline reviews | Leveraged existing admin workflows |
| PostgreSQL consideration | TinyDB with persistent volume | Optimal simplicity-to-performance ratio |
| Markdown formatting | Plain text communications | Eliminated user-generated content crashes |

### **Production Optimizations**
- **Connection Timeouts:** Optimized for Railway's network characteristics
- **Error Recovery:** Comprehensive exception handling for Telegram API calls
- **State Persistence:** Reliable conversation state management
- **Memory Efficiency:** Streamlined bot configuration for resource optimization

## 8. Current Status: Production-Ready MVP

The bot has successfully transitioned from development to a production-ready state with:

✅ **Persistent Data Storage** - Railway volume implementation complete  
✅ **User Reward System** - Balance tracking and automatic payouts functional  
✅ **Admin Review Workflow** - Complete notification and approval system with Google Maps integration  
✅ **Error-Resistant Communications** - Markdown parsing issues resolved  
✅ **Production Deployment** - Railway.app hosting with zero-downtime deploys  
✅ **Remote Database Access** - SSH-based database inspection capability  
✅ **Payout Administration** - Admin-controlled payout command with balance validation  
✅ **Essential User Commands** - Balance check, rules display, and support contact implemented  
✅ **Enhanced UX** - Persistent button interface for easy navigation  

The system is currently operational and processing real accident reports with a verified reward distribution mechanism and complete payout functionality.
</file>

<file path="railway.json">
{
  "$schema": "https://railway.app/railway.schema.json",
  "environments": {
    "production": {
      "variables": {
        "RAILWAY_DEPLOYMENT_OVERLAP_SECONDS": "0"
      }
    }
  }
}
</file>

<file path="repomix-output-stan-voo-daenahbot.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
tasks/
  Bot Welcome Message and Image.md
  markdown parsing issue.md
.gitignore
bot.py
config.py
database.py
handlers.py
kazabot_db.json
local_backup.json
next-actions.md
Procfile
project-description.md
railway.json
repomix-output-stan-voo-daenahbot.xml
requirements.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="tasks/Bot Welcome Message and Image.md">
Bot Welcome Message and Image.md
Of course. Here is the extracted text, translation, and a comprehensive plan to implement the requested features, along with recommendations for your database strategy.

### **1. Bot Welcome Message and Image**

Here is the extracted text from the image and its English translation.

**Original Turkish Text:**

> **Kazayı Bildir, Kazan!**
> Bu bot üzerinden gördüğünüz trafik kazalarını bize bildirebilir ve kazanç sağlayabilirsiniz.
> 
> 🚗 Kaza yerinden bir fotoğraf çekip, konum bilgisiyle birlikte gönderin.
> ✅ Bilgiler doğrulandıktan sonra, 24 saat içinde hesabınıza 1000 TL yatırılır.
> 📞 Bilgiler doğruysa, destek ekibimiz sizinle iletişime geçecektir.
> 
> Unutmayın, hem hayat kurtarın hem de kazanç sağlayın!

**English Translation:**

> **Report an Accident, Get Rewarded!**
> You can report traffic accidents you see through this bot and earn rewards.
> 
> 🚗 Take a photo at the scene of the accident and send it along with the location information.
> ✅ After the information is verified, 1000 TL will be deposited into your account within 24 hours.
> 📞 If the information is correct, our support team will contact you.
> 
> Don't forget, you can both save lives and earn rewards!

---

### **2. Implementation Plan**

Here is a step-by-step plan to implement all the requested changes in your codebase.

#### **Part A: Add the Welcome Image and Message**

1.  **Get the Image File ID:** To send the image without re-uploading it every time, you need its `file_id`.
    *   Send the image to your bot yourself.
    *   In the bot's console logs, you will see the incoming message data. Find the `file_id` for the photo you sent. It will be a long string of characters.
    *   Copy this `file_id`.

2.  **Update the `start` function in `handlers.py`:** Modify the `start` function to send the photo and the new welcome text.

    ```python
    # handlers.py

    async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """Starts the conversation, shows a welcome message, and asks for the accident location."""
        user = update.message.from_user
        logger.info("User %s started the conversation.", user.first_name)
        
        # --- NEW: Send welcome message and image ---
        # Replace 'YOUR_FILE_ID_HERE' with the actual file_id you obtained
        photo_file_id = 'YOUR_FILE_ID_HERE' 
        welcome_caption = (
            "Welcome to KazaBot!\n\n"
            "Report an Accident, Get Rewarded!\n"
            "You can report traffic accidents you see through this bot and earn rewards.\n\n"
            "🚗 Take a photo at the scene of the accident and send it along with the location information.\n"
            "✅ After the information is verified, you will receive a reward.\n"
            "📞 If the information is correct, our support team will contact you.\n\n"
            "Don't forget, you can both save lives and earn rewards!"
        )
        await context.bot.send_photo(
            chat_id=update.effective_chat.id,
            photo=photo_file_id,
            caption=welcome_caption
        )
        # --- End of new section ---
        
        # Onboard the user if they are new and set initial balance
        get_or_create_user(user.id, user.username)

        location_keyboard = KeyboardButton(text="Share Accident Location", request_location=True)
        custom_keyboard = [[location_keyboard]]
        reply_markup = ReplyKeyboardMarkup(custom_keyboard, resize_keyboard=True, one_time_keyboard=True)

        await update.message.reply_text(
            "Please press the button below to share the accident's location.",
            reply_markup=reply_markup,
        )
        return LOCATION
    ```

#### **Part B: Implement User Balance**

1.  **Update `database.py`:** Modify the user creation function to include the balance and add a function to update it.

    ```python
    # database.py

    def get_or_create_user(user_id, username):
        """
        Retrieves a user profile or creates a new one with an initial balance.
        """
        User = Query()
        user = users_table.get(User.telegram_user_id == user_id)

        if not user:
            user_profile = {
                'telegram_user_id': user_id,
                'username': username,
                'created_at': datetime.utcnow().isoformat(),
                'courier_company': None,
                'payment_method': None,
                'report_count': 0,
                'balance': 99  # NEW: Add initial balance of 99 Lira
            }
            users_table.insert(user_profile)
            return user_profile
        return user

    def update_user_balance(user_id, amount_to_add):
        """
        Increments a user's balance by a specified amount.
        """
        User = Query()
        user = users_table.get(User.telegram_user_id == user_id)
        if user:
            # Handle cases where older users might not have a balance field
            current_balance = user.get('balance', 0) 
            new_balance = current_balance + amount_to_add
            users_table.update({'balance': new_balance}, User.telegram_user_id == user_id)
            logger.info(f"Updated balance for user {user_id}. New balance: {new_balance}")
            return new_balance
        return None
    ```    *Note: You will also need to import `logger` in `database.py` if it's not already there: `import logging` and `logger = logging.getLogger(__name__)`.*

2.  **Update `handlers.py`:** Modify the `review_handler` to award Lira for approved reports.

    ```python
    # handlers.py

    # IMPORTANT: Add the new database function to the imports
    from database import ( 
        save_report, 
        get_or_create_user, 
        update_user_profile,
        get_report_by_id, 
        update_report_status,
        update_user_balance # <-- ADD THIS
    )

    async def review_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        # ... (keep the existing code until the user notification part)

        # Update status and notify the user
        new_status = "verified" if action == "approve" else "rejected"
        update_report_status(report_id, new_status, admin_user.id)
        
        # Update the admin's message to show the result
        final_text = query.message.text + f"\n\n--- Decision ---\nStatus set to *{new_status.upper()}* by @{admin_user.username}."
        await query.edit_message_text(text=final_text, parse_mode='Markdown')

        # Notify the original user
        original_user_id = report['telegram_user_id']
        user_notification = f"UPDATE: Your report (ID: {report_id}) has been *{new_status}*."
        
        if new_status == 'verified':
            # --- NEW: Update balance and notify user ---
            reward_amount = 150 # Define your reward amount here
            new_balance = update_user_balance(original_user_id, reward_amount)
            user_notification += (
                f"\n\nCongratulations! {reward_amount} Lira has been added to your account. "
                f"Your new balance is {new_balance} Lira."
            )
            # --- End of new section ---
        
        try:
            await context.bot.send_message(
                chat_id=original_user_id,
                text=user_notification,
                parse_mode='Markdown'
            )
        except Exception as e:
            logger.error(f"Failed to send status update to user {original_user_id}: {e}")
    ```

#### **Part C: Temporarily Disable "Company Name" Question**

1.  **Update `handlers.py`:** Comment out the logic that asks for the company name.

    ```python
    # handlers.py

    async def submit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """Submits the report, saves it, and ends the conversation."""
        user = update.message.from_user
        report_data = context.user_data.get('report')
        
        if not report_data:
            await update.message.reply_text("Something went wrong. Please start over with /start.")
            return ConversationHandler.END

        # Save the report
        report_id = save_report(user.id, report_data)
        logger.info("User %s submitted report %s", user.first_name, report_id)

        # Update user's report count
        user_profile = get_or_create_user(user.id, user.username)
        new_count = user_profile.get('report_count', 0) + 1
        update_user_profile(user.id, {'report_count': new_count})
        
        # Notify admins
        await notify_admins(context, user, report_id, report_data)
        
        # --- MODIFICATION: Temporarily disable company name question ---
        # if user_profile.get('courier_company') is None:
        #     await update.message.reply_text(
        #         "✅ Success! Your report has been submitted.\n\n"
        #         "To help us, could you tell us which courier company you work for? (e.g., 'Getir', 'Trendyol Go'). This is optional.",
        #          reply_markup=ReplyKeyboardRemove(),
        #     )
        #     return COMPANY_NAME
        # else:
        #     # If company name is known, end the conversation
        #     return await finish(update, context)
        return await finish(update, context) # Always go to the finish state
        # --- End of modification ---

    # --- MODIFICATION: Comment out the unused handler ---
    # async def company_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    #     """Saves the user's courier company and ends the conversation."""
    #     user_id = update.message.from_user.id
    #     company = update.message.text
        
    #     update_user_profile(user_id, {'courier_company': company})
    #     logger.info("User %s set their company to %s", update.message.from_user.first_name, company)
        
    #     await update.message.reply_text("Thank you! Your profile has been updated.")
        
    #     return await finish(update, context)
    # --- End of modification ---
    ```

2.  **Update `bot.py`:** Comment out the unused state in the `ConversationHandler`.

    ```python
    # bot.py

    # ... (other imports)
    from handlers import (
        # ... (other handlers)
        # company_name, # Comment out
        cancel,
        review_handler,
        LOCATION,
        PHOTO,
        DESCRIPTION,
        CRASH_TIME_DELTA,
        CONFIRMATION,
        # COMPANY_NAME, # Comment out
    )

    # ...

    def main() -> None:
        # ...

        conv_handler = ConversationHandler(
            # ...
            states={
                LOCATION: [MessageHandler(filters.LOCATION, location)],
                PHOTO: [MessageHandler(filters.PHOTO, photo)],
                DESCRIPTION: [
                    MessageHandler(filters.Regex(r"(?i)^skip$"), description_skip),
                    MessageHandler(filters.TEXT & ~filters.COMMAND, description),
                ],
                CRASH_TIME_DELTA: [MessageHandler(filters.TEXT & ~filters.COMMAND, crash_time_delta)],
                CONFIRMATION: [
                    MessageHandler(filters.Regex(r"(?i)^Submit Report$"), submit),
                    MessageHandler(filters.Regex(r"(?i)^Cancel$"), cancel),
                ],
                # COMPANY_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, company_name)], # Comment out this line
            },
            fallbacks=[CommandHandler("cancel", cancel)],
            per_message=False 
        )
        # ...
    ```

---

### **3. Database Storage on Railway.app for an MVP**

For an MVP hosted on Railway, you have two excellent choices for handling your `kazabot_db.json` file. Here’s a comparison to help you decide:

#### **Option 1: Railway Persistent Volume (Recommended for MVP)**

Railway allows you to mount a persistent disk, called a "volume," to your service. This volume acts like a small, attached hard drive that doesn't get erased when you deploy new code or restart your service.

*   **How it Works:** You would configure a volume in your Railway project settings and mount it at a specific path (e.g., `/data`). You would then modify your `DATABASE_PATH` in `config.py` to point to this location (e.g., `DATABASE_PATH = '/data/kazabot_db.json'`).
*   **Pros:**
    *   **Simplicity:** It's the easiest and quickest setup. You stay entirely within the Railway ecosystem.
    *   **Low Latency:** The database file is stored on the same infrastructure as your bot, ensuring fast access.
    *   **Cost-Effective:** Using a small volume is generally included in Railway's free/hobby tier or is very inexpensive.
*   **Cons:**
    *   **Manual Backups:** You are responsible for backing up the JSON file yourself.
    *   **Scalability Limitations:** If your bot becomes extremely popular with high write volumes, a simple JSON file can become a bottleneck.

#### **Option 2: External Database Service (e.g., Supabase)**

Supabase is a "backend-as-a-service" platform that provides a full-featured PostgreSQL database, authentication, and more.

*   **How it Works:** You would create a project on Supabase, get your database connection credentials, and add them to your bot's environment variables on Railway. Your bot would then connect to Supabase over the internet. This would require replacing `TinyDB` with a PostgreSQL client library like `psycopg2-binary`.
*   **Pros:**
    *   **Highly Scalable:** A real SQL database can handle much more data and concurrent users.
    *   **Managed Service:** Supabase handles backups, security, and maintenance for you.
    *   **Powerful Features:** You get a data browser, user management, and API endpoints out of the box.
*   **Cons:**
    *   **Increased Complexity:** You would need to rewrite your entire `database.py` file to work with PostgreSQL instead of TinyDB. This is a significant code change.
    *   **Potential for Higher Latency:** The database connection happens over the network, which can be slightly slower than a local file.
    *   **Learning Curve:** Requires understanding SQL and managing a new service.

**Recommendation for Your MVP:**

**Stick with Railway's persistent volume and TinyDB.**

For an MVP, the primary goal is to test your idea quickly and with minimal complexity. The combination of TinyDB and a Railway volume is perfectly suited for this. It is robust enough to handle the initial user load, and the setup is incredibly straightforward. You can focus on building bot features rather than managing database infrastructure.

If your bot proves successful and you need to scale, migrating to a service like Supabase is a great next step, but it is unnecessary at this early stage.
</file>

<file path="tasks/markdown parsing issue.md">
# Current Task: user report fail bc of markdown render
Date: 31.07.2025

## What I Want to Fix:
When a user Saba tried to create a report, only a photo was being sent. Railway logs had this message:
2025-07-30 20:41:50,837 - handlers - INFO - User Saba Allahverdi submitted report 1793bd71-5dbb-48ce-9e73-c58973d76d6a

2025-07-30 20:41:50,897 - httpx - INFO - HTTP Request: POST https://api.telegram.org/bot7091434973:AAEdbbggzf8WQhYbZZIp4NLREfe6ajaq4OM/sendPhoto "HTTP/1.1 200 OK"

2025-07-30 20:41:50,901 - httpx - INFO - HTTP Request: POST https://api.telegram.org/bot7091434973:AAEdbbggzf8WQhYbZZIp4NLREfe6ajaq4OM/sendMessage "HTTP/1.1 400 Bad Request"

## Current Problem:
I don't know how to proceed with fixing it.

## Desired Outcome:
Saba should be able to create a crash report in the Telegram bot, and the admin should receive the full information from Saba.

## Gemini 2.5 Pro Plan:
Of course. It's frustrating when a bug like this appears. The "400 Bad Request" error is a classic sign of a specific problem, and we can fix it quickly.

Here’s a simple plan to get your bot working correctly.

### **The Problem Explained Simply**

The error `400 Bad Request` from Telegram's `sendMessage` API almost always means one thing: the text you're trying to send has formatting characters that Telegram doesn't understand.

In your `handlers.py` file, you are sending the admin notification using `parse_mode='Markdown'`. This tells Telegram to look for special characters like \` \_ \* \[ \] and treat them as formatting. Your code correctly uses backticks (\`) to format the `report_id` and `user.id`.

However, you also include the user's `username` and the report `description` directly in the message. If a user's name is `saba_a` or they write a description like "two cars, one is a mini-cooper.", the underscores (`_`) or dashes (`-`) will break Telegram's Markdown parser, causing the entire message to be rejected.

### **A Step-by-Step Plan to Fix This**

We will make a small change to the `notify_admins` function in `handlers.py`. The safest and quickest fix is to simply send the admin notification as plain text. The formatting is less important than the admin actually receiving the information.

**Step 1: Locate the Problematic Code**

1.  Open your project and find the file `handlers.py`.
2.  Inside that file, scroll down to the `notify_admins` function.
3.  Find the `await context.bot.send_message(...)` call inside the `for` loop. It looks like this:

    ```python
    # Inside notify_admins function in handlers.py

    await context.bot.send_message(
        chat_id=admin_id,
        text=admin_message,
        reply_markup=reply_markup,
        parse_mode='Markdown'  # <-- THIS IS THE PROBLEM
    )
    ```

**Step 2: Apply the Fix**

All you need to do is remove the `parse_mode` argument. The message will be sent as plain text, which will prevent any formatting errors.

1.  Change the code to look like this:

    ```python
    # Inside notify_admins function in handlers.py

    await context.bot.send_message(
        chat_id=admin_id,
        text=admin_message,
        reply_markup=reply_markup
    )
    ```
2.  Save the `handlers.py` file.
3.  Deploy the updated code to your server (e.g., Railway.app).

That's it. The bug should now be fixed.

### **What Could Go Wrong**

1.  **Admin message loses formatting**: The admin notification will now be plain text. The Report ID and User ID will no longer have the nice grey code block formatting. This is a minor trade-off for making the feature reliable.
2.  **The error persists**: This is very unlikely. If it does, it means a character in the `admin_message` text is somehow invalid for reasons other than Markdown. If this happens, the next step would be to log the `admin_message` text right before it's sent to see exactly what content is causing the failure.

### **How to Test It**

Follow these steps to ensure the fix is working as expected:

1.  **Restart the conversation**: Open your Telegram bot and type `/cancel` to clear any old session, then `/start` to begin a new report.
2.  **Submit a test report**:
    *   Send the location when prompted.
    *   Send a photo.
    *   When asked for a description, **use text with special characters**. For example, type: `A red car and a blue_car.`
3.  **Confirm submission**: Complete the final steps and submit the report.
4.  **Check the admin account**: Open the Telegram account of one of your admins.
    *   **Expected Outcome:** You should see the photo **and** the text notification arrive successfully. The text will be plain, without any bolding or code blocks, but all the information will be there.
5.  **Check your logs**: Look at your Railway.app logs. You should no longer see the `400 Bad Request` error. You should see two "200 OK" responses, one for `sendPhoto` and one for `sendMessage`.

By following this plan, you should be able to resolve the issue in less than 30 minutes.
## Implementation prompt
## What Worked:
Of course. Dealing with bugs like this can be tricky, but the plan is straightforward. Let's get your bot fixed.

### Step 1: Making the Admin Notification Robust

First, I'll address the core issue. To prevent special characters in usernames or report descriptions from crashing the bot, I will modify the `notify_admins` function. I am removing the Markdown formatting from the notification message, which includes taking out the backticks (`) around the `report_id` and `user.id` and removing the `parse_mode` argument from the `send_message` call.

This ensures the notification is sent as plain text, making it reliable.
Ran tool

Excellent. The fix has been applied to `handlers.py`. The `notify_admins` function will now send plain text messages, which resolves the `400 Bad Request` error.

Now that the main issue is resolved, I recommend we also address a related problem. The `review_handler` function, which processes admin decisions, still uses Markdown to update the admin's message. If a username contains special characters, this could cause a similar crash when an admin approves or rejects a report.

To prevent this, I will remove the Markdown formatting from the `review_handler` as well.
Ran tool

Great, that's another potential issue averted.

To complete the process and ensure the bot is fully robust against this type of error, I will make one final change. The notification sent to the original user after an admin reviews their report also uses Markdown. I'll update that to be plain text as well for consistency and to prevent any future issues.
Ran tool
That's the final change. We have now removed all instances of `parse_mode='Markdown'` that could cause issues with user-generated content. Your bot should now be much more robust.

The bug is fixed. Before you deploy, I recommend you follow the test plan outlined in `current-task.md` to be certain everything is working as expected. Let me know if you have any other questions.

## What Didn't Work:
- 

## For Next Time:
-
</file>

<file path=".gitignore">
cat > .gitignore << 'EOF'
.env
venv/
__pycache__/
*.pyc
db.json
.DS_Store
EOF
</file>

<file path="bot.py">
# bot.py - Simplified version after Railway teardown fix
import logging
import asyncio
from telegram.ext import (
    Application,
    ConversationHandler,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)
from config import TELEGRAM_BOT_TOKEN
from handlers import (
    start,
    location,
    photo,
    description,
    description_skip,
    crash_time_delta,
    submit,
    cancel,
    review_handler,
    odeme_command,
    bakiye_command,
    kurallar_command,
    destek_command, # <-- ADD THIS IMPORT
    LOCATION,
    PHOTO,
    DESCRIPTION,
    CRASH_TIME_DELTA,
    CONFIRMATION,
)

# Simple logging setup
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", 
    level=logging.INFO
)
logger = logging.getLogger(__name__)

def main() -> None:
    """Run the bot - simplified version."""
    
    # Create the Application with minimal timeout config
    application = (
        Application.builder()
        .token(TELEGRAM_BOT_TOKEN)
        .get_updates_read_timeout(30)
        .get_updates_write_timeout(30)
        .get_updates_connect_timeout(30)
        .build()
    )

    # Add conversation handler
    conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler("start", start),
            MessageHandler(filters.Regex(r"^➕ New Report$"), start),
        ],
        states={
            LOCATION: [MessageHandler(filters.LOCATION, location)],
            PHOTO: [MessageHandler(filters.PHOTO, photo)],
            DESCRIPTION: [
                MessageHandler(filters.Regex(r"(?i)^skip$"), description_skip),
                MessageHandler(filters.TEXT & ~filters.COMMAND, description),
            ],
            CRASH_TIME_DELTA: [MessageHandler(filters.TEXT & ~filters.COMMAND, crash_time_delta)],
            CONFIRMATION: [
                MessageHandler(filters.Regex(r"(?i)^Submit Report$"), submit),
                MessageHandler(filters.Regex(r"(?i)^Cancel$"), cancel),
            ],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
        per_message=False
    )

    application.add_handler(conv_handler)
    application.add_handler(CallbackQueryHandler(review_handler))

    # --- Register command handlers ---
    application.add_handler(CommandHandler("odeme", odeme_command))
    application.add_handler(CommandHandler("bakiye", bakiye_command))
    application.add_handler(CommandHandler("kurallar", kurallar_command))
    application.add_handler(CommandHandler("destek", destek_command)) # <-- ADD THIS

    # --- Register text button handlers ---
    application.add_handler(MessageHandler(filters.Regex(r"^💰 Bakiye$"), bakiye_command))
    application.add_handler(MessageHandler(filters.Regex(r"^📜 Kurallar$"), kurallar_command))
    application.add_handler(MessageHandler(filters.Regex(r"^📞 Destek$"), destek_command)) # <-- ADD THIS


    logger.info("Starting KazaBot...")
    
    # Simple polling - no complex retry logic needed
    application.run_polling(
        poll_interval=2.0,
        drop_pending_updates=True
    )

if __name__ == "__main__":
    main()
</file>

<file path="config.py">
# config.py - Configuration management
import os
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Bot configuration - Changed from TELEGRAM_TOKEN to TELEGRAM_BOT_TOKEN
TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
if not TELEGRAM_BOT_TOKEN:
    raise ValueError("No TELEGRAM_BOT_TOKEN found in environment variables")

# Database configuration
# Use Railway volume for persistent storage
DATABASE_PATH = os.environ.get('RAILWAY_VOLUME_MOUNT_PATH', '')
if DATABASE_PATH:
    DATABASE_PATH = os.path.join(DATABASE_PATH, 'kazabot_db.json')
else:
    # Fallback for local development
    DATABASE_PATH = 'kazabot_db.json'

# Validation constraints
MAX_DESCRIPTION_LENGTH = 200
MIN_CRASH_TIME = 0  # minutes
MAX_CRASH_TIME = 60  # minutes
MAX_REPORTS_PER_DAY = 3
PAYOUT_THRESHOLD = 500  # TL

# --- Add these new constants for the rules ---
REWARD_AMOUNT = 100 # TL
SERVICE_ZONES_TEXT = "İzmir — Buca ve Gaziemir ilçeleri"

# Conversation states
LOCATION, PHOTO, DESCRIPTION, CRASH_TIME_DELTA, CONFIRMATION = range(5)

# --- Load Admin User IDs from .env file ---
admin_ids_str = os.getenv('ADMIN_IDS', '') # Get the comma-separated string

# Process the string into a list of integers
if admin_ids_str:
    try:
        # Split the string by commas and convert each part to an integer
        ADMIN_IDS = [int(admin_id.strip()) for admin_id in admin_ids_str.split(',')]
    except ValueError:
        print("Error: ADMIN_IDS in .env file contains non-numeric values. Please check it.")
        ADMIN_IDS = [] # Default to an empty list on error
else:
    # If the variable is not set, default to an empty list
    ADMIN_IDS = []

# It's good practice to log or print the loaded admins on startup to verify
if not ADMIN_IDS:
    print("Warning: No ADMIN_IDS found in .env file. Admin features will be disabled.")
else:
    print(f"Admin users loaded successfully: {ADMIN_IDS}")
</file>

<file path="database.py">
# database.py
import uuid
import logging
from datetime import datetime, timedelta
from tinydb import TinyDB, Query
from config import DATABASE_PATH

# Enable logging
logger = logging.getLogger(__name__)

# Initialize the database with the path from config
db = TinyDB(DATABASE_PATH, indent=4)
reports_table = db.table('reports')
users_table = db.table('users')

def save_report(user_id, report_data):
    """
    Saves a new accident report to the database.
    """
    report_id = str(uuid.uuid4())
    submitted_at = datetime.utcnow().isoformat()

    report = {
        'report_id': report_id,
        'telegram_user_id': user_id,
        'location_geo': report_data.get('location'),
        'location_time': report_data.get('location_timestamp'),
        'photo_file_id': report_data.get('photo'),
        'photo_time': report_data.get('photo_timestamp'),
        'description': report_data.get('description'),
        'crash_time_delta': report_data.get('crash_time_delta'),
        'submitted_at': submitted_at,
        'status': 'pending', # pending/verified/duplicate/rewarded
        'reward_sent': False
    }
    reports_table.insert(report)
    return report_id

def get_or_create_user(user_id, username):
    """
    Retrieves a user profile or creates a new one with an initial balance.
    """
    User = Query()
    user = users_table.get(User.telegram_user_id == user_id)

    if not user:
        user_profile = {
            'telegram_user_id': user_id,
            'username': username,
            'created_at': datetime.utcnow().isoformat(),
            'courier_company': None,
            'payment_method': None,
            'report_count': 0,
            'balance': 99  # NEW: Add initial balance of 99 Lira
        }
        users_table.insert(user_profile)
        return user_profile
    return user

def update_user_balance(user_id, amount_to_add):
    """
    Increments a user's balance by a specified amount.
    """
    User = Query()
    user = users_table.get(User.telegram_user_id == user_id)
    if user:
        # Handle cases where older users might not have a balance field
        current_balance = user.get('balance', 0) 
        new_balance = current_balance + amount_to_add
        users_table.update({'balance': new_balance}, User.telegram_user_id == user_id)
        logger.info(f"Updated balance for user {user_id}. New balance: {new_balance}")
        return new_balance
    return None

def update_user_profile(user_id, data_to_update):
    """
    Updates a user's profile with new information (e.g., company, report count).
    """
    User = Query()
    users_table.update(data_to_update, User.telegram_user_id == user_id)

def get_user_report_count_today(user_id):
    """
    Counts how many reports a user has submitted in the last 24 hours.
    """
    Report = Query()
    twenty_four_hours_ago = (datetime.utcnow() - timedelta(days=1)).isoformat()
    
    user_reports = reports_table.search(
        (Report.telegram_user_id == user_id) & 
        (Report.submitted_at >= twenty_four_hours_ago)
    )
    return len(user_reports)
    # database.py (add these functions)

def get_report_by_id(report_id):
    """Retrieves a single report by its unique ID."""
    Report = Query()
    report = reports_table.get(Report.report_id == report_id)
    return report

def update_report_status(report_id, new_status, admin_id):
    """Updates the status of a report and logs which admin did it."""
    Report = Query()
    reports_table.update(
        {'status': new_status, 'reviewed_by': admin_id}, 
        Report.report_id == report_id
    )

def get_user_by_id(user_id):
    """
    Retrieves a user profile by their Telegram user ID.
    """
    User = Query()
    user = users_table.get(User.telegram_user_id == user_id)
    return user
</file>

<file path="handlers.py">
# handlers.py
import logging
from datetime import datetime
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)
from database import ( 
    save_report, 
    get_or_create_user, 
    update_user_profile,
    get_user_report_count_today,
    get_report_by_id, 
    update_report_status,
    update_user_balance,
    get_user_by_id
)
from config import ADMIN_IDS, PAYOUT_THRESHOLD, REWARD_AMOUNT, SERVICE_ZONES_TEXT

# Enable logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# Define states for the conversation
(
    LOCATION,
    PHOTO,
    DESCRIPTION,
    CRASH_TIME_DELTA,
    CONFIRMATION,
    COMPANY_NAME,
) = range(6)
# --- Reusable keyboard for main actions ---
NEW_REPORT_KEYBOARD = ReplyKeyboardMarkup(
    [
        ["➕ New Report"],
        ["💰 Bakiye", "📜 Kurallar", "📞 Destek"] # <-- ADDED "Destek"
    ],
    resize_keyboard=True
)

# --- NEW: Define the rules text ---
RULES_TEXT = (
    "📜 **KazaBot Kuralları**\n\n"
    f" We are rewarding verified reports with **{REWARD_AMOUNT} ₺**.\n"
    f" The payout threshold is **{PAYOUT_THRESHOLD} ₺**.\n"
    f" We are currently only servicing **{SERVICE_ZONES_TEXT}**.\n\n"
    "Please only report accidents within the specified service zones. Thank you for your cooperation!"
)

# --- Start & Cancel ---

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Starts the conversation, shows a welcome message, and asks for the accident location."""
    user = update.message.from_user
    logger.info("User %s started the conversation.", user.first_name)
    
    # --- NEW: Send welcome message and image ---
    # Replace 'YOUR_FILE_ID_HERE' with the actual file_id you obtained
    photo_file_id = 'AgACAgQAAxkBAAPCaIu8_FQu7pFVNR7X8AAB5O_shWW2AALfxzEbZKFhUOKlznwiwuHuAQADAgADeAADNgQ' 
    welcome_caption = (
        "Welcome to Kazabot! We've added a starting balance of 99 ₺ to your account for joining us. "
        "For every accident report you submit that is verified by our team, you will earn a 100 ₺ reward. "
        "You can withdraw your earnings once your total balance reaches 500 ₺.\n\n"
        "Let's get started! Please share the accident's location by pressing the button below."
    )
    get_or_create_user(user.id, user.username)

    location_keyboard = KeyboardButton(text="Share Accident Location", request_location=True)
    custom_keyboard = [[location_keyboard]]
    reply_markup = ReplyKeyboardMarkup(custom_keyboard, resize_keyboard=True, one_time_keyboard=True)

    await context.bot.send_photo(
        chat_id=update.effective_chat.id,
        photo=photo_file_id,
        caption=welcome_caption,
        reply_markup=reply_markup,
        read_timeout=20,
        write_timeout=20
    )
    # --- End of new section ---
    
    # Onboard the user if they are new and set initial balance
    

    return LOCATION

# --- Reporting Flow ---

async def location(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the location and asks for a photo."""
    user_location = update.message.location
    context.user_data['report'] = {
        'location': (user_location.latitude, user_location.longitude),
        'location_timestamp': datetime.utcnow().isoformat()
    }
    logger.info("Location from %s: %s", update.message.from_user.first_name, user_location)
    
    await update.message.reply_text(
        "Great! Now, please take a clear photo of the accident and send it to me.",
        reply_markup=ReplyKeyboardRemove(),
    )
    return PHOTO

async def photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the photo and asks for a description."""
    user_photo = update.message.photo[-1] # Get the highest resolution photo
    context.user_data['report']['photo'] = user_photo.file_id
    context.user_data['report']['photo_timestamp'] = datetime.utcnow().isoformat()
    
    logger.info("Photo received from %s", update.message.from_user.first_name)
    
    reply_keyboard = [["Skip"]]
    await update.message.reply_text(
        "Photo received. Now, please add a short description (e.g., 'two cars, rear-end'). "
        "This is optional. You can also type 'Skip'.",
        reply_markup=ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True, one_time_keyboard=True),
    )
    return DESCRIPTION

async def description(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the description and asks for the time delta."""
    user_description = update.message.text
    if user_description.lower() != 'skip':
        if len(user_description) > 200:
            await update.message.reply_text("The description is too long (max 200 characters). Please try again.")
            return DESCRIPTION
        context.user_data['report']['description'] = user_description
    else:
        context.user_data['report']['description'] = None
        
    logger.info("Description from %s: %s", update.message.from_user.first_name, user_description)
    await update.message.reply_text(
        "Got it. Roughly how many minutes ago did the crash happen? (Please enter a number from 0 to 60)",
        reply_markup=ReplyKeyboardRemove(),
    )
    return CRASH_TIME_DELTA

async def description_skip(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Skips the description and asks for the time delta."""
    context.user_data['report']['description'] = None
    logger.info("User %s skipped the description.", update.message.from_user.first_name)
    await update.message.reply_text(
        "Description skipped. Roughly how many minutes ago did the crash happen? (Please enter a number from 0 to 60)",
        reply_markup=ReplyKeyboardRemove(),
    )
    return CRASH_TIME_DELTA


async def crash_time_delta(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the time delta and asks for final confirmation."""
    text = update.message.text
    try:
        delta = int(text)
        if not (0 <= delta <= 60):
            raise ValueError
        context.user_data['report']['crash_time_delta'] = delta
    except (ValueError, TypeError):
        await update.message.reply_text("That's not a valid number. Please enter a number between 0 and 60.")
        return CRASH_TIME_DELTA

    # Show summary
    report = context.user_data['report']
    summary = (
        f"--- REVIEW YOUR REPORT ---\n"
        f"📍 Location: Sent\n"
        f"📸 Photo: Sent\n"
        f"📝 Description: {report.get('description', 'N/A')}\n"
        f"⏱️ Time Since Crash: ~{report.get('crash_time_delta')} minutes ago\n\n"
        "Is everything correct?"
    )
    reply_keyboard = [["Submit Report", "Cancel"]]
    await update.message.reply_text(
        summary,
        reply_markup=ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True, one_time_keyboard=True),
    )
    return CONFIRMATION

async def submit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Submits the report, saves it, and transitions to the final steps."""
    user = update.message.from_user
    report_data = context.user_data.get('report')
    
    if not report_data:
        await update.message.reply_text("Something went wrong. Please start over with /start.")
        return ConversationHandler.END

    # Save the report
    report_id = save_report(user.id, report_data)
    logger.info("User %s submitted report %s", user.first_name, report_id)

    # Update user's report count
    user_profile = get_or_create_user(user.id, user.username)
    new_count = user_profile.get('report_count', 0) + 1
    update_user_profile(user.id, {'report_count': new_count})
    
    # Notify admins
    await notify_admins(context, user, report_id, report_data)
    
    # --- MODIFICATION: Temporarily disable company name question ---
    # if user_profile.get('courier_company') is None:
    #     await update.message.reply_text(
    #         "✅ Success! Your report has been submitted.\n\n"
    #         "To help us, could you tell us which courier company you work for? (e.g., 'Getir', 'Trendyol Go'). This is optional.",
    #          reply_markup=ReplyKeyboardRemove(),
    #     )
    #     return COMPANY_NAME
    # else:
    #     # If company name is known, end the conversation
    #     return await finish(update, context)
    await update.message.reply_text("✅ Success! Your report has been submitted.\n\n")
    return await finish(update, context) # Always go to the finish state
    # --- End of modification ---


# --- MODIFICATION: Comment out the unused handler ---
# async def company_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
#     """Saves the user's courier company and ends the conversation."""
#     user_id = update.message.from_user.id
#     company = update.message.text
    
#     update_user_profile(user_id, {'courier_company': company})
#     logger.info("User %s set their company to %s", update.message.from_user.first_name, company)
    
#     await update.message.reply_text("Thank you! Your profile has been updated.")
    
#     return await finish(update, context)
# --- End of modification ---


async def finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Clears user data and shows the final message with the 'New Report' button."""
    context.user_data.clear()
    await update.message.reply_text(
        "You can now submit a new report or close this chat.",
        reply_markup=NEW_REPORT_KEYBOARD,
    )
    return ConversationHandler.END


async def notify_admins(context: ContextTypes.DEFAULT_TYPE, user, report_id, report_data):
    """Sends a notification with a map link to all admins about a new report."""
    
    # --- NEW: Generate Google Maps link ---
    lat, lon = report_data['location']
    maps_link = f"https://www.google.com/maps/search/?api=1&query={lat},{lon}"
    # --- End of new section ---

    # --- MODIFIED: Updated message text ---
    admin_message = (
        f"🚨 New Accident Report Submitted 🚨\n\n"
        f"📍 Location (Google Maps):\n{maps_link}\n\n" # The link is on its own line for better readability
        f"Report ID: {report_id}\n"
        f"Submitted By: @{user.username} (ID: {user.id})\n"
        f"Description: {report_data.get('description', 'N/A')}\n"
        f"Time Delta: ~{report_data.get('crash_time_delta')} minutes ago"
    )
    # --- End of modification ---
    
    keyboard = [
        [
            InlineKeyboardButton("✅ Approve", callback_data=f"approve_{report_id}"),
            InlineKeyboardButton("❌ Reject", callback_data=f"reject_{report_id}"),
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    for admin_id in ADMIN_IDS:
        try:
            # First, send the photo as before
            await context.bot.send_photo(chat_id=admin_id, photo=report_data['photo'])
            
            # Then, send the updated message with the map link
            await context.bot.send_message(
                chat_id=admin_id,
                text=admin_message,
                reply_markup=reply_markup,
                # No parse_mode needed, Telegram makes links clickable automatically
                disable_web_page_preview=True # Optional: keeps the message compact
            )
            logger.info(f"Sent notification with map link for report {report_id} to admin {admin_id}")
        except Exception as e:
            logger.error(f"Failed to send notification to admin {admin_id}: {e}")


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancels the conversation and shows the 'New Report' button."""
    user = update.message.from_user
    logger.info("User %s canceled the conversation.", user.first_name)
    context.user_data.clear()
    await update.message.reply_text(
        "Report canceled. You can start a new one anytime.",
        reply_markup=NEW_REPORT_KEYBOARD, # Use our new keyboard
    )
    return ConversationHandler.END


async def review_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handles admin decisions from inline keyboard buttons."""
    query = update.callback_query
    await query.answer() # Acknowledge the button press

    admin_user = query.from_user
    action, report_id = query.data.split("_")

    if admin_user.id not in ADMIN_IDS:
        await query.edit_message_text(text="Sorry, you are not authorized to perform this action.")
        return

    report = get_report_by_id(report_id)
    if not report:
        await query.edit_message_text(text=f"Error: Report {report_id} not found.")
        return
    
    if report['status'] != 'pending':
        await query.edit_message_text(text=f"This report has already been reviewed. Status: {report['status']}.")
        return

    # Update status and notify the user
    new_status = "verified" if action == "approve" else "rejected"
    update_report_status(report_id, new_status, admin_user.id)
    
    # Update the admin's message to show the result
    final_text = query.message.text + f"\n\n--- Decision ---\nStatus set to {new_status.upper()} by @{admin_user.username}."
    await query.edit_message_text(text=final_text)

    # Notify the original user
    original_user_id = report['telegram_user_id']
    user_notification = f"UPDATE: Your report (ID: {report['report_id']}) has been {new_status}."
    
    if new_status == 'verified':
        # --- NEW: Update balance and notify user ---
        reward_amount = 100 # Define your reward amount here
        new_balance = update_user_balance(original_user_id, reward_amount)
        user_notification += (
            f"\n\nCongratulations! {reward_amount} TL has been added to your account. "
            f"Your new balance is {new_balance} TL."
        )
        # --- End of new section ---
    
    try:
        await context.bot.send_message(
            chat_id=original_user_id,
            text=user_notification
        )
    except Exception as e:
        logger.error(f"Failed to send status update to user {original_user_id}: {e}")


# --- ADMIN PAYOUT COMMAND ---
async def odeme_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Admin-only command to process a payout: /odeme <user_id> <amount>"""
    admin_user_id = update.message.from_user.id
    if admin_user_id not in ADMIN_IDS:
        await update.message.reply_text("This command is for admins only.")
        logger.warning(f"Unauthorized /odeme attempt by user {admin_user_id}.")
        return

    try:
        args = context.args
        if len(args) != 2:
            raise ValueError("Incorrect number of arguments.")

        target_user_id = int(args[0])
        amount = int(args[1])

        if amount <= 0:
            await update.message.reply_text("Payout amount must be a positive number.")
            return

        user = get_user_by_id(target_user_id)
        if not user:
            await update.message.reply_text(f"User with ID {target_user_id} not found.")
            return

        current_balance = user.get('balance', 0)
        if current_balance < amount:
            await update.message.reply_text(
                f"Insufficient balance for user {target_user_id}.\n"
                f"Current Balance: {current_balance} ₺\n"
                f"Payout Amount: {amount} ₺"
            )
            return

        # Subtract from balance by providing a negative amount
        new_balance = update_user_balance(target_user_id, -amount)

        # Confirmation message to the admin
        await update.message.reply_text(
            f"✅ Payout of {amount} ₺ for user {target_user_id} has been recorded.\n"
            f"Their new balance is now {new_balance} ₺."
        )
        logger.info(f"Admin {admin_user_id} processed a payout of {amount} ₺ for user {target_user_id}.")

        # Notification message to the user
        try:
            await context.bot.send_message(
                chat_id=target_user_id,
                text=f"A payout of {amount} ₺ has been processed by our team! Your new balance is {new_balance} ₺."
            )
        except Exception as e:
            logger.error(f"Failed to send payout notification to user {target_user_id}: {e}")
            await update.message.reply_text(f"⚠️ Could not send notification to user {target_user_id}.")

    except (IndexError, ValueError):
        await update.message.reply_text("Usage: /odeme <user_id> <amount>")

# --- NEW: USER BALANCE COMMAND ---
async def bakiye_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Shows the user their current balance and the payout threshold."""
    user_id = update.message.from_user.id
    # get_or_create_user handles new and existing users perfectly here
    user = get_or_create_user(user_id, update.message.from_user.username)
    balance = user.get('balance', 0)

    # Use the keyboard we defined earlier for a consistent experience
    await update.message.reply_text(
        f"💰 Mevcut Bakiyeniz: {balance} ₺\n\n"
        f"Ödeme talebinde bulunabilmek için ulaşmanız gereken bakiye: {PAYOUT_THRESHOLD} ₺.",
        reply_markup=NEW_REPORT_KEYBOARD
    )

# --- NEW: USER RULES COMMAND ---
async def kurallar_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Sends the user the predefined list of rules."""
    await update.message.reply_text(
        text=RULES_TEXT,
        reply_markup=NEW_REPORT_KEYBOARD, # Keep the main keyboard visible
        parse_mode='Markdown' # Use Markdown to make it look nicer
    )

# --- NEW: USER SUPPORT COMMAND ---
async def destek_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Provides the user with a direct link to the support chat."""
    support_username = "DaenahSupport"  # <-- Your actual support account username
    support_message = (
        "Yardıma mı ihtiyacınız var?\n\n"
        "Tüm sorularınız, sorunlarınız veya geri bildirimleriniz için destek ekibimizle doğrudan iletişime geçebilirsiniz. "
        f"Lütfen aşağıdaki linke tıklayın:\n\n"
        f"➡️ **[Destek Sohbetini Başlat](https://t.me/mrvooooo)**\n\n"
        "Ekibimiz en kısa sürede size yardımcı olacaktır."
    )
    await update.message.reply_text(
        text=support_message,
        reply_markup=NEW_REPORT_KEYBOARD,
        parse_mode='Markdown',
        disable_web_page_preview=True # Keeps the message clean
    )
</file>

<file path="kazabot_db.json">
{
    "users": {
        "1": {
            "telegram_user_id": 4462330,
            "username": "mrvooooo",
            "created_at": "2025-07-30T18:05:09.870369",
            "courier_company": "Getir",
            "payment_method": null,
            "report_count": 1
        },
        "2": {
            "telegram_user_id": 7127606451,
            "username": "rewd0glamd",
            "created_at": "2025-07-30T19:24:09.028355",
            "courier_company": "Getir",
            "payment_method": null,
            "report_count": 11,
            "balance": 300
        }
    },
    "reports": {
        "1": {
            "report_id": "2d156c1b-68eb-49cb-af1b-00f27707b32d",
            "telegram_user_id": 4462330,
            "location_geo": [
                38.432951,
                27.162072
            ],
            "location_time": "2025-07-30T18:05:31.830144",
            "photo_file_id": "AgACAgIAAxkBAAMFaIpe_EWfcVoX0NSX0mgIQAZB-t0AAqv3MRvjwlFIKRrfjwEHeEIBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T18:05:48.250580",
            "description": "masterful coding",
            "crash_time_delta": 0,
            "submitted_at": "2025-07-30T18:06:15.584885",
            "status": "pending",
            "reward_sent": false
        },
        "2": {
            "report_id": "25405c14-5629-40cf-a3ac-69dd234f499b",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:24:25.945855",
            "photo_file_id": "AgACAgQAAxkBAAMUaIpxf_Nkuum2freWHeVOEQbhdagAAs_LMRtkoVlQR0RDdOuUEjYBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:24:47.503329",
            "description": null,
            "crash_time_delta": 5,
            "submitted_at": "2025-07-30T19:25:02.912718",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "3": {
            "report_id": "e436d6c3-679f-4e35-a3e6-b9a07f362818",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:41:32.081860",
            "photo_file_id": "AgACAgQAAxkBAAMmaIp1eebMWgl_HAN88HD6dyowyPQAAtXLMRtkoVlQZxNh-hoxm-gBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:41:45.601875",
            "description": "Test3: button add",
            "crash_time_delta": 0,
            "submitted_at": "2025-07-30T19:42:04.169922",
            "status": "rejected",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "4": {
            "report_id": "1fa7e2e7-1ae0-4c94-9fa6-7c6c4eb100fc",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:42:27.204362",
            "photo_file_id": "AgACAgQAAxkBAAM0aIp1vnXSYeWzKOGGtQdTR0cerAgAAtfLMRtkoVlQVAPjHxaAMeYBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:42:54.313088",
            "description": null,
            "crash_time_delta": 9,
            "submitted_at": "2025-07-30T19:43:15.203505",
            "status": "rejected",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "5": {
            "report_id": "7faf682c-b7d4-4ff3-89ae-58531ab819b8",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:51:19.351171",
            "photo_file_id": "AgACAgQAAxkBAAMUaIpxf_Nkuum2freWHeVOEQbhdagAAs_LMRtkoVlQR0RDdOuUEjYBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:51:27.247422",
            "description": "Hello",
            "crash_time_delta": 0,
            "submitted_at": "2025-07-30T19:51:39.011673",
            "status": "pending",
            "reward_sent": false
        },
        "6": {
            "report_id": "a12c1c62-c03b-44cd-bb7d-43b5a968c6a5",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T17:45:49.427828",
            "photo_file_id": "AgACAgQAAxkBAAOjaIur2MrnF_ZZcLHVOgeFv813gcgAAsXHMRtkoWFQ5qMeDqtMKSMBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T17:46:00.486139",
            "description": "Djdhdhdhd \ud83d\udc4c//// !!! #$$",
            "crash_time_delta": 9,
            "submitted_at": "2025-07-31T17:46:22.254973",
            "status": "pending",
            "reward_sent": false
        },
        "7": {
            "report_id": "3dc52cdf-b5c6-4696-a0ec-16b3ab8cf0ee",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T17:48:28.763276",
            "photo_file_id": "AgACAgQAAxkBAAOjaIur2MrnF_ZZcLHVOgeFv813gcgAAsXHMRtkoWFQ5qMeDqtMKSMBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T17:48:35.636265",
            "description": "\ud83d\ude0d\ud83d\ude01\ud83d\ude0d\ud83d\ude01\ud83d\udc8b\ud83d\ude2d\ud83d\ude33\ud83d\ude1d",
            "crash_time_delta": 0,
            "submitted_at": "2025-07-31T17:48:57.947763",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "8": {
            "report_id": "779ed8b2-7b0e-485b-93c7-37c0592f2d03",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T18:59:01.366378",
            "photo_file_id": "AgACAgQAAxkBAAPCaIu8_FQu7pFVNR7X8AAB5O_shWW2AALfxzEbZKFhUOKlznwiwuHuAQADAgADeAADNgQ",
            "photo_time": "2025-07-31T18:59:08.259151",
            "description": null,
            "crash_time_delta": 0,
            "submitted_at": "2025-07-31T18:59:15.958670",
            "status": "pending",
            "reward_sent": false
        },
        "9": {
            "report_id": "e96c69da-4df8-46e2-b068-4134bf39c919",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T19:04:44.449882",
            "photo_file_id": "AgACAgQAAxkBAAPSaIu-X_N96rb9pqgfNtU6bBEOoWYAAufHMRtkoWFQ8E_q13bdgZIBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T19:05:03.164804",
            "description": null,
            "crash_time_delta": 5,
            "submitted_at": "2025-07-31T19:05:12.681631",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "10": {
            "report_id": "8d0be8f4-697b-4f20-9f00-68cfcad7d79c",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T19:16:28.425785",
            "photo_file_id": "AgACAgQAAxkBAAPlaIvBGGXUvtjPw3uxGmg_If7jzZIAAunHMRtkoWFQLh9zKtTjSFoBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T19:16:40.508592",
            "description": null,
            "crash_time_delta": 9,
            "submitted_at": "2025-07-31T19:16:47.984138",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "11": {
            "report_id": "a7ab3df7-f31b-4ee9-aae1-82ddf9d3c0fb",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T19:17:30.376216",
            "photo_file_id": "AgACAgQAAxkBAAP2aIvBWBOOx0qV0PiMwmlj3hH5js0AAurHMRtkoWFQ-xoM50j9h94BAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T19:17:44.301290",
            "description": "Balance check",
            "crash_time_delta": 6,
            "submitted_at": "2025-07-31T19:17:57.308006",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "12": {
            "report_id": "fe95bb76-b908-476d-919a-30a97742dbe3",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.433063,
                27.164084
            ],
            "location_time": "2025-08-04T18:51:09.113514",
            "photo_file_id": "AgACAgQAAxkBAAIBO2iRASxIb96ZzY-Wu-IxPGFi1vuXAAJEyzEb1daIUHuIEb9Ro-N4AQADAgADeQADNgQ",
            "photo_time": "2025-08-04T18:51:24.285511",
            "description": null,
            "crash_time_delta": 9,
            "submitted_at": "2025-08-04T18:51:32.320416",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        }
    }
}
</file>

<file path="local_backup.json">
{
    "users": {
        "1": {
            "telegram_user_id": 7127606451,
            "username": "rewd0_glamd",
            "created_at": "2025-08-04T19:42:00.551113",
            "courier_company": null,
            "payment_method": null,
            "report_count": 6,
            "balance": 300
        }
    },
    "reports": {
        "1": {
            "report_id": "ad418dfe-dfb8-46f4-adf8-f40083ccf09d",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.433063,
                27.164084
            ],
            "location_time": "2025-08-04T19:42:09.265550",
            "photo_file_id": "AgACAgQAAxkBAAIBemiRDRwuN1peKBYl4XiLfIwy8HRIAAKByzEb1daIUPhNq2YyYnzaAQADAgADeQADNgQ",
            "photo_time": "2025-08-04T19:42:20.465270",
            "description": "Db volume setup check",
            "crash_time_delta": 0,
            "submitted_at": "2025-08-04T19:42:38.730095",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "2": {
            "report_id": "660f1542-e4e9-4092-8453-3e7bc0b1afd0",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.433063,
                27.164084
            ],
            "location_time": "2025-08-04T19:54:37.394189",
            "photo_file_id": "AgACAgQAAxkBAAIBemiRDRwuN1peKBYl4XiLfIwy8HRIAAKByzEb1daIUPhNq2YyYnzaAQADAgADeQADNgQ",
            "photo_time": "2025-08-04T19:54:44.642142",
            "description": "Volume test 2",
            "crash_time_delta": 2,
            "submitted_at": "2025-08-04T19:54:57.891074",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "3": {
            "report_id": "46e77b99-160b-4859-8c07-71ba941253f4",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.433073,
                27.164059
            ],
            "location_time": "2025-08-04T20:53:47.641928",
            "photo_file_id": "AgACAgQAAxkBAAIBmmiRHeVLCZoOqgoeCKEpzdG8fwNAAAKkyzEb1daIUEHZo4Lh2opdAQADAgADeQADNgQ",
            "photo_time": "2025-08-04T20:53:57.120992",
            "description": "Odeme command 1",
            "crash_time_delta": 1,
            "submitted_at": "2025-08-04T20:54:13.792970",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "4": {
            "report_id": "0b81a7fb-e4d3-4237-904e-b759013e5563",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.433063,
                27.164084
            ],
            "location_time": "2025-08-04T21:19:33.028155",
            "photo_file_id": "AgACAgQAAxkBAAIBmmiRHeVLCZoOqgoeCKEpzdG8fwNAAAKkyzEb1daIUEHZo4Lh2opdAQADAgADeQADNgQ",
            "photo_time": "2025-08-04T21:19:37.340031",
            "description": "Balance check test",
            "crash_time_delta": 1,
            "submitted_at": "2025-08-04T21:19:53.543521",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "5": {
            "report_id": "ab40c22e-5891-45ff-b567-dfa883248db4",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.433063,
                27.164084
            ],
            "location_time": "2025-08-04T21:52:17.653485",
            "photo_file_id": "AgACAgQAAxkBAAIBymiRK6SVJ26WR-qrps9sGOKguEe5AAKvyzEb1daIUDqSEEJeBSkLAQADAgADeQADNgQ",
            "photo_time": "2025-08-04T21:52:36.275527",
            "description": "Rules command test",
            "crash_time_delta": 1,
            "submitted_at": "2025-08-04T21:52:49.480518",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "6": {
            "report_id": "b34e26db-2cbc-4043-aff6-51120d2686ff",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.433173,
                27.163997
            ],
            "location_time": "2025-08-04T22:02:04.271134",
            "photo_file_id": "AgACAgQAAxkBAAIB4miRLejf4DQPw5tdVnKF0vUcX5bnAAKxyzEb1daIUDCf5mGr9DNwAQADAgADeQADNgQ",
            "photo_time": "2025-08-04T22:02:16.241575",
            "description": "Support button",
            "crash_time_delta": 1,
            "submitted_at": "2025-08-04T22:02:28.126975",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        }
    }
}
</file>

<file path="next-actions.md">
# **Daenah Bot — Next Actions (Updated)**

> **What’s new in this update**
>
> * Added **/kurallar (Rules)** command that was missing.
> * Reinstated the explicit decision: **do not collect phone numbers** in the MVP.
> * Documented that **Telegram ********`user.id`******** is stable** (no action required).
> * Clarified **admin notification link** format to avoid `parse_mode` issues.

---

## ✅ **Completed Foundation (Tier 1)**

### **1) Stable Database Using Railway Volumes**

* **Status:** ✅ Completed
* **Implementation:** Persistent volume mounted at `/data`; DB path set to `/data/kazabot_db.json`.
* **Remote Read (one-liner):**

  ```bash
  railway ssh -- cat /data/kazabot_db.json > local_backup.json
  ```
* **Result:** Data persists across deploys/restarts.

### **2) User Balance & Reward System**

* **Status:** ✅ Completed
* **Notes:**

  * Starting balance for new users (configurable)
  * +100 ₺ (configurable) for each verified report
  * Real‑time balance updates

### **3) Remove Company Name Flow & UX Cleanup**

* **Status:** ✅ Completed
* **Impact:** Fewer fields → higher completion rate

### **4) Error-Resistant Communications**

* **Status:** ✅ Completed
* **Decision:** Avoid `parse_mode` to prevent crashes from user input; prefer plain text/URLs.

---

## 🎯 **Current Priority (Tier 2)**

### **A) Implement Payout Logic**

* **Why:** Core loop is *Report → Verify → Get Paid*.
* **Command:** Admin-only `/odeme <user_id> <amount>`
* **Spec:**

  * Reject if caller is not in `ADMIN_IDS`.
  * Subtract `<amount>` from user balance (insist on sufficient funds).
  * Confirm to admin; notify the user.
* **Sample (python-telegram-bot v20 async):**

  ```python
  async def odeme_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
      if update.message.from_user.id not in ADMIN_IDS:
          await update.message.reply_text("Unauthorized command.")
          return
      try:
          user_id, amount = int(context.args[0]), int(context.args[1])
      except (IndexError, ValueError):
          await update.message.reply_text("Usage: /odeme <user_id> <amount>")
          return

      user = get_user_by_id(user_id)
      if not user:
          await update.message.reply_text("User not found.")
          return

      if user.get('balance', 0) < amount:
          await update.message.reply_text("Insufficient balance for payout.")
          return

      new_balance = update_user_balance(user_id, -amount)
      await update.message.reply_text(
          f"Payout of {amount} ₺ for user {user_id} recorded. New balance: {new_balance} ₺"
      )
      await context.bot.send_message(
          chat_id=user_id,
          text=f"A payout of {amount} ₺ has been processed! Your new balance is {new_balance} ₺."
      )
  ```

### **B) Add Essential User Commands**

#### **1. ********`/bakiye`******** — Balance Check**

```python
async def bakiye_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    user = get_or_create_user(user_id, update.message.from_user.username)
    balance = user.get('balance', 0)
    await update.message.reply_text(
        f"💰 Bakiye: {balance} ₺\n\n" \
        f"Ödeme talebi için eşik: {PAYOUT_THRESHOLD} ₺."
    )
```

#### **2. ********`/kurallar`******** — Rules (MISSING → ADDED)**

> Communicate the 3 key constraints clearly and consistently: **reward amount**, **payout threshold**, **serviceable zones**.

```python
RULES_TEXT = (
    "📜 Kurallar\n\n"
    f"• Doğrulanan rapor ödülü: {REWARD_AMOUNT} ₺\n"
    f"• Ödeme talebi eşiği: {PAYOUT_THRESHOLD} ₺\n"
    f"• Hizmet bölgeleri: {SERVICE_ZONES_TEXT}\n\n"
    "Lütfen sadece hizmet bölgeleri içindeki kazaları bildirin.\n"
)

async def kurallar_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(RULES_TEXT)
```

* **Config suggestions:**

  ```python
  REWARD_AMOUNT = 100
  PAYOUT_THRESHOLD = 500
  SERVICE_ZONES_TEXT = "İzmir — Konak ve Bornova ilçeleri"
  ```

#### **3. ********`/destek`******** — Support Contact**

```python
async def destek_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "📞 Destek: support@daenah.com\nTelegram: @DaenahSupport\nYanıt süresi: 24 saat içinde"
    )
```

### **C) Service Zone Management**

* **Welcome Message:** Add explicit zone notice (same text as in `/kurallar`).
* **BotFather ********`/setdescription`********:** Include the zone restriction line.
* **Admin Notifications:** Include a **plain URL** to Google Maps to keep `parse_mode` off.

```python
lat, lon = report_data['location']
maps_link = f"https://www.google.com/maps/search/?api=1&query={lat},{lon}"
admin_message = (
    "🚨 New Accident Report Submitted 🚨\n\n"
    f"📍 Location (Google Maps): {maps_link}\n"
    f"Report ID: {report_id}\n"
    f"Submitted By: @{user.username} (ID: {user.id})\n"
    f"Description: {report_data.get('description', 'N/A')}\n"
    f"Time Delta: ~{report_data.get('crash_time_delta')} minutes ago"
)
```

### **D) Enable Spam Prevention**

```python
report_count = get_user_report_count_today(user.id)
if report_count >= MAX_REPORTS_PER_DAY:
    await update.message.reply_text(
        f"Günlük rapor limitinize ({MAX_REPORTS_PER_DAY}) ulaştınız. Lütfen yarın tekrar deneyin."
    )
    return ConversationHandler.END
```

---

## 🧭 **Clarifications That Avoid Wasted Work**

### **1) User Identity Handling — No Action Needed**

* Using `update.message.from_user.id` as the primary key is **correct and stable**. It does **not** change if the user deletes the chat, changes @username, or blocks/unblocks the bot.

### **2) Phone Number Collection — Postponed (MVP)**

* Additional fields create friction and reduce conversion.
* Current needs (payouts via IBAN, support via Telegram/email) do **not** require phone numbers.
* **Revisit** only if a **clear, validated** business need emerges.

---

## 🚀 **Future Enhancements (Tier 3)**

* **Automated QA:** Service zone auto-check; duplicate detection; basic photo quality checks
* **Analytics:** Submission patterns, cohort retention; geographic heatmaps
* **Scaling:** TinyDB → PostgreSQL (>1,000 active users); multi‑language; potential external API integrations

---

## 📅 **Immediate Plan (Next 2 Weeks)**

### **Week 1 — Core Commands**

1. Implement `/odeme` (admin payouts)
2. Add `/bakiye` (balance)
3. **Add ********`/kurallar`******** (rules)** ← *new*
4. Add `/destek` (support)
5. E2E test payout flow

### **Week 2 — UX & Governance**

1. Update welcome message with zone notice
2. Update BotFather description with zone notice
3. Switch admin notification to **plain URL** maps link
4. Enable spam prevention block
</file>

<file path="Procfile">
worker: python bot.py
</file>

<file path="project-description.md">
# **DaenahBot: A Real-Time Car Accident Reporting Telegram Bot**

DaenahBot (KazaBot) is a production-ready Telegram bot designed for motor couriers in Turkey to report minor car accidents in real-time. The bot incentivizes rapid accident reporting through a reward system, streamlining data collection for insurance or emergency response purposes.

## 1. Core Technologies

- **Programming Language:** Python 3.11+
- **Telegram Bot Framework:** `python-telegram-bot` v21.3 for comprehensive bot functionality
- **Database:** `TinyDB` - a lightweight, file-based JSON database with persistent storage
- **Deployment:** Railway.app with persistent volume for data storage
- **Process Management:** Procfile configuration for worker deployment

## 2. Project Structure

The project maintains a clean, modular architecture optimized for production deployment:

- `bot.py`: Main application entry point with simplified polling configuration
- `handlers.py`: Complete conversation flows, command handlers, and user interaction logic
- `database.py`: Database abstraction layer managing all TinyDB operations
- `config.py`: Configuration management with Railway volume integration
- `requirements.txt`: Python dependencies specification
- `Procfile`: Railway deployment configuration
- `local_backup.json`: Local database backup for remote inspection
- `.gitignore`: Git ignore rules for sensitive files
- `tasks/`: Historical development documentation
- `railway.json`: Railway-specific deployment configuration

## 3. Current Implementation Status

### **User Features**

#### **Onboarding Experience**
- **Welcome Image & Message:** Branded welcome photo with clear value proposition
- **Initial Balance:** 99 TL starting balance for new users
- **Clear Expectations:** 100 TL reward per verified report, 500 TL withdrawal threshold
- **Streamlined Flow:** Company name collection disabled for reduced friction

#### **Report Submission Process**
- **Location Sharing:** GPS coordinates via Telegram's native location feature
- **Photo Upload:** High-resolution accident scene photography
- **Optional Description:** 200-character limit text descriptions
- **Time Recording:** Crash occurrence timing (0-60 minutes ago)
- **Confirmation Review:** Complete summary before submission
- **Persistent UI:** "➕ New Report" button for easy subsequent reports

#### **User Account Management**
- **Automatic Registration:** Seamless user profile creation on first interaction
- **Balance Tracking:** Real-time balance updates with transaction history
- **Report History:** Complete submission and verification tracking
- **Reward Processing:** Automatic balance increments for verified reports

### **Admin Features**

#### **Real-Time Notification System**
- **Instant Alerts:** Immediate Telegram notifications for new reports
- **Complete Data:** Report ID, user info, description, timing, and photo
- **Inline Review:** Approve/Reject buttons directly in notifications
- **Admin Tracking:** Records which admin reviewed each report

#### **Review Management**
- **Status Updates:** pending → verified/rejected workflow
- **User Notifications:** Automatic feedback on report status changes
- **Balance Management:** Automatic reward distribution for approved reports
- **Audit Trail:** Complete review history with admin attribution

### **Technical Infrastructure**

#### **Database Persistence**
- **Railway Volume:** Persistent storage at `/data/kazabot_db.json`
- **Remote Access:** Database inspection via `railway ssh -- cat /data/kazabot_db.json > local_backup.json`
- **Backup Strategy:** Local backup files for development and monitoring
- **Data Integrity:** Transaction logging and error recovery

#### **Error Handling & Reliability**
- **Markdown Safety:** Removed all parse_mode='Markdown' to prevent user-generated content crashes
- **Connection Management:** Optimized timeout configurations for Railway deployment
- **Graceful Degradation:** Robust error handling for notification failures
- **State Management:** Consistent conversation state handling across restarts

#### **Security & Configuration**
- **Environment Variables:** Secure token and admin ID management
- **Admin Authorization:** Restricted access to admin-only functions
- **Input Validation:** Comprehensive user input sanitization
- **Rate Limiting:** Built-in spam prevention (currently disabled for MVP)

## 4. Database Schema

The TinyDB database contains two optimized tables:

### **Users Table**
```json
{
  "telegram_user_id": 7127606451,
  "username": "rewd0_glamd",
  "created_at": "2025-08-04T19:42:00.551113",
  "courier_company": null,
  "payment_method": null,
  "report_count": 2,
  "balance": 299
}
```

### **Reports Table**
```json
{
  "report_id": "ad418dfe-dfb8-46f4-adf8-f40083ccf09d",
  "telegram_user_id": 7127606451,
  "location_geo": [38.433063, 27.164084],
  "location_time": "2025-08-04T19:42:09.265550",
  "photo_file_id": "AgACAgQAAxkBAAIBemiRDRwuN1peKBYl4XiLfIwy8HRIAAKByzEb1daIUPhNq2YyYnzaAQADAgADeQADNgQ",
  "photo_time": "2025-08-04T19:42:20.465270",
  "description": "Db volume setup check",
  "crash_time_delta": 0,
  "submitted_at": "2025-08-04T19:42:38.730095",
  "status": "verified",
  "reward_sent": false,
  "reviewed_by": 4462330
}
```

## 5. Production Deployment

### **Railway.app Integration**
- **Persistent Volume:** Mounted at `/data` for database storage
- **Zero-Downtime Deployment:** `RAILWAY_DEPLOYMENT_OVERLAP_SECONDS: 0`
- **Worker Process:** Dedicated bot worker with polling configuration
- **Environment Management:** Secure credential handling via Railway secrets

### **Database Management**
- **Remote Inspection:** `railway ssh -- cat /data/kazabot_db.json > local_backup.json`
- **Backup Strategy:** Regular local backups for monitoring and development
- **Data Persistence:** Survives deployments, restarts, and scaling events
- **Performance:** Optimized TinyDB configuration for production workloads

## 6. Current Metrics & Performance

Based on `local_backup.json`, the system currently manages:
- **Active Users:** 1 user with complete profile
- **Report History:** 2 verified reports
- **Balance Management:** 299 TL in user balances
- **Geographic Coverage:** İzmir, Turkey (Konak/Bornova districts)
- **Admin Team:** 1 active reviewer (ID: 4462330)

## 7. Key Implementation Decisions

### **Simplified Architecture**
| **Original Plan** | **Production Implementation** | **Rationale** |
|-------------------|------------------------------|---------------|
| Pydantic models in separate file | Inline validation in handlers | Reduced complexity for MVP |
| Company name mandatory | Optional/disabled | Reduced user friction |
| Complex admin dashboard | Telegram-native inline reviews | Leveraged existing admin workflows |
| PostgreSQL consideration | TinyDB with persistent volume | Optimal simplicity-to-performance ratio |
| Markdown formatting | Plain text communications | Eliminated user-generated content crashes |

### **Production Optimizations**
- **Connection Timeouts:** Optimized for Railway's network characteristics
- **Error Recovery:** Comprehensive exception handling for Telegram API calls
- **State Persistence:** Reliable conversation state management
- **Memory Efficiency:** Streamlined bot configuration for resource optimization

## 8. Current Status: Production-Ready MVP

The bot has successfully transitioned from development to a production-ready state with:

✅ **Persistent Data Storage** - Railway volume implementation complete  
✅ **User Reward System** - Balance tracking and automatic payouts functional  
✅ **Admin Review Workflow** - Complete notification and approval system  
✅ **Error-Resistant Communications** - Markdown parsing issues resolved  
✅ **Production Deployment** - Railway.app hosting with zero-downtime deploys  
✅ **Remote Database Access** - SSH-based database inspection capability  

The system is currently operational and processing real accident reports with a verified reward distribution mechanism.
</file>

<file path="railway.json">
{
  "$schema": "https://railway.app/railway.schema.json",
  "environments": {
    "production": {
      "variables": {
        "RAILWAY_DEPLOYMENT_OVERLAP_SECONDS": "0"
      }
    }
  }
}
</file>

<file path="repomix-output-stan-voo-daenahbot.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
tasks/
  Bot Welcome Message and Image.md
  markdown parsing issue.md
.gitignore
bot.py
config.py
database.py
handlers.py
kazabot_db.json
next-actions.md
Procfile
project-description.md
railway.json
repomix-output-stan-voo-daenahbot.xml
requirements.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="tasks/Bot Welcome Message and Image.md">
Bot Welcome Message and Image.md
Of course. Here is the extracted text, translation, and a comprehensive plan to implement the requested features, along with recommendations for your database strategy.

### **1. Bot Welcome Message and Image**

Here is the extracted text from the image and its English translation.

**Original Turkish Text:**

> **Kazayı Bildir, Kazan!**
> Bu bot üzerinden gördüğünüz trafik kazalarını bize bildirebilir ve kazanç sağlayabilirsiniz.
> 
> 🚗 Kaza yerinden bir fotoğraf çekip, konum bilgisiyle birlikte gönderin.
> ✅ Bilgiler doğrulandıktan sonra, 24 saat içinde hesabınıza 1000 TL yatırılır.
> 📞 Bilgiler doğruysa, destek ekibimiz sizinle iletişime geçecektir.
> 
> Unutmayın, hem hayat kurtarın hem de kazanç sağlayın!

**English Translation:**

> **Report an Accident, Get Rewarded!**
> You can report traffic accidents you see through this bot and earn rewards.
> 
> 🚗 Take a photo at the scene of the accident and send it along with the location information.
> ✅ After the information is verified, 1000 TL will be deposited into your account within 24 hours.
> 📞 If the information is correct, our support team will contact you.
> 
> Don't forget, you can both save lives and earn rewards!

---

### **2. Implementation Plan**

Here is a step-by-step plan to implement all the requested changes in your codebase.

#### **Part A: Add the Welcome Image and Message**

1.  **Get the Image File ID:** To send the image without re-uploading it every time, you need its `file_id`.
    *   Send the image to your bot yourself.
    *   In the bot's console logs, you will see the incoming message data. Find the `file_id` for the photo you sent. It will be a long string of characters.
    *   Copy this `file_id`.

2.  **Update the `start` function in `handlers.py`:** Modify the `start` function to send the photo and the new welcome text.

    ```python
    # handlers.py

    async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """Starts the conversation, shows a welcome message, and asks for the accident location."""
        user = update.message.from_user
        logger.info("User %s started the conversation.", user.first_name)
        
        # --- NEW: Send welcome message and image ---
        # Replace 'YOUR_FILE_ID_HERE' with the actual file_id you obtained
        photo_file_id = 'YOUR_FILE_ID_HERE' 
        welcome_caption = (
            "Welcome to KazaBot!\n\n"
            "Report an Accident, Get Rewarded!\n"
            "You can report traffic accidents you see through this bot and earn rewards.\n\n"
            "🚗 Take a photo at the scene of the accident and send it along with the location information.\n"
            "✅ After the information is verified, you will receive a reward.\n"
            "📞 If the information is correct, our support team will contact you.\n\n"
            "Don't forget, you can both save lives and earn rewards!"
        )
        await context.bot.send_photo(
            chat_id=update.effective_chat.id,
            photo=photo_file_id,
            caption=welcome_caption
        )
        # --- End of new section ---
        
        # Onboard the user if they are new and set initial balance
        get_or_create_user(user.id, user.username)

        location_keyboard = KeyboardButton(text="Share Accident Location", request_location=True)
        custom_keyboard = [[location_keyboard]]
        reply_markup = ReplyKeyboardMarkup(custom_keyboard, resize_keyboard=True, one_time_keyboard=True)

        await update.message.reply_text(
            "Please press the button below to share the accident's location.",
            reply_markup=reply_markup,
        )
        return LOCATION
    ```

#### **Part B: Implement User Balance**

1.  **Update `database.py`:** Modify the user creation function to include the balance and add a function to update it.

    ```python
    # database.py

    def get_or_create_user(user_id, username):
        """
        Retrieves a user profile or creates a new one with an initial balance.
        """
        User = Query()
        user = users_table.get(User.telegram_user_id == user_id)

        if not user:
            user_profile = {
                'telegram_user_id': user_id,
                'username': username,
                'created_at': datetime.utcnow().isoformat(),
                'courier_company': None,
                'payment_method': None,
                'report_count': 0,
                'balance': 99  # NEW: Add initial balance of 99 Lira
            }
            users_table.insert(user_profile)
            return user_profile
        return user

    def update_user_balance(user_id, amount_to_add):
        """
        Increments a user's balance by a specified amount.
        """
        User = Query()
        user = users_table.get(User.telegram_user_id == user_id)
        if user:
            # Handle cases where older users might not have a balance field
            current_balance = user.get('balance', 0) 
            new_balance = current_balance + amount_to_add
            users_table.update({'balance': new_balance}, User.telegram_user_id == user_id)
            logger.info(f"Updated balance for user {user_id}. New balance: {new_balance}")
            return new_balance
        return None
    ```    *Note: You will also need to import `logger` in `database.py` if it's not already there: `import logging` and `logger = logging.getLogger(__name__)`.*

2.  **Update `handlers.py`:** Modify the `review_handler` to award Lira for approved reports.

    ```python
    # handlers.py

    # IMPORTANT: Add the new database function to the imports
    from database import ( 
        save_report, 
        get_or_create_user, 
        update_user_profile,
        get_report_by_id, 
        update_report_status,
        update_user_balance # <-- ADD THIS
    )

    async def review_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        # ... (keep the existing code until the user notification part)

        # Update status and notify the user
        new_status = "verified" if action == "approve" else "rejected"
        update_report_status(report_id, new_status, admin_user.id)
        
        # Update the admin's message to show the result
        final_text = query.message.text + f"\n\n--- Decision ---\nStatus set to *{new_status.upper()}* by @{admin_user.username}."
        await query.edit_message_text(text=final_text, parse_mode='Markdown')

        # Notify the original user
        original_user_id = report['telegram_user_id']
        user_notification = f"UPDATE: Your report (ID: {report_id}) has been *{new_status}*."
        
        if new_status == 'verified':
            # --- NEW: Update balance and notify user ---
            reward_amount = 150 # Define your reward amount here
            new_balance = update_user_balance(original_user_id, reward_amount)
            user_notification += (
                f"\n\nCongratulations! {reward_amount} Lira has been added to your account. "
                f"Your new balance is {new_balance} Lira."
            )
            # --- End of new section ---
        
        try:
            await context.bot.send_message(
                chat_id=original_user_id,
                text=user_notification,
                parse_mode='Markdown'
            )
        except Exception as e:
            logger.error(f"Failed to send status update to user {original_user_id}: {e}")
    ```

#### **Part C: Temporarily Disable "Company Name" Question**

1.  **Update `handlers.py`:** Comment out the logic that asks for the company name.

    ```python
    # handlers.py

    async def submit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """Submits the report, saves it, and ends the conversation."""
        user = update.message.from_user
        report_data = context.user_data.get('report')
        
        if not report_data:
            await update.message.reply_text("Something went wrong. Please start over with /start.")
            return ConversationHandler.END

        # Save the report
        report_id = save_report(user.id, report_data)
        logger.info("User %s submitted report %s", user.first_name, report_id)

        # Update user's report count
        user_profile = get_or_create_user(user.id, user.username)
        new_count = user_profile.get('report_count', 0) + 1
        update_user_profile(user.id, {'report_count': new_count})
        
        # Notify admins
        await notify_admins(context, user, report_id, report_data)
        
        # --- MODIFICATION: Temporarily disable company name question ---
        # if user_profile.get('courier_company') is None:
        #     await update.message.reply_text(
        #         "✅ Success! Your report has been submitted.\n\n"
        #         "To help us, could you tell us which courier company you work for? (e.g., 'Getir', 'Trendyol Go'). This is optional.",
        #          reply_markup=ReplyKeyboardRemove(),
        #     )
        #     return COMPANY_NAME
        # else:
        #     # If company name is known, end the conversation
        #     return await finish(update, context)
        return await finish(update, context) # Always go to the finish state
        # --- End of modification ---

    # --- MODIFICATION: Comment out the unused handler ---
    # async def company_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    #     """Saves the user's courier company and ends the conversation."""
    #     user_id = update.message.from_user.id
    #     company = update.message.text
        
    #     update_user_profile(user_id, {'courier_company': company})
    #     logger.info("User %s set their company to %s", update.message.from_user.first_name, company)
        
    #     await update.message.reply_text("Thank you! Your profile has been updated.")
        
    #     return await finish(update, context)
    # --- End of modification ---
    ```

2.  **Update `bot.py`:** Comment out the unused state in the `ConversationHandler`.

    ```python
    # bot.py

    # ... (other imports)
    from handlers import (
        # ... (other handlers)
        # company_name, # Comment out
        cancel,
        review_handler,
        LOCATION,
        PHOTO,
        DESCRIPTION,
        CRASH_TIME_DELTA,
        CONFIRMATION,
        # COMPANY_NAME, # Comment out
    )

    # ...

    def main() -> None:
        # ...

        conv_handler = ConversationHandler(
            # ...
            states={
                LOCATION: [MessageHandler(filters.LOCATION, location)],
                PHOTO: [MessageHandler(filters.PHOTO, photo)],
                DESCRIPTION: [
                    MessageHandler(filters.Regex(r"(?i)^skip$"), description_skip),
                    MessageHandler(filters.TEXT & ~filters.COMMAND, description),
                ],
                CRASH_TIME_DELTA: [MessageHandler(filters.TEXT & ~filters.COMMAND, crash_time_delta)],
                CONFIRMATION: [
                    MessageHandler(filters.Regex(r"(?i)^Submit Report$"), submit),
                    MessageHandler(filters.Regex(r"(?i)^Cancel$"), cancel),
                ],
                # COMPANY_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, company_name)], # Comment out this line
            },
            fallbacks=[CommandHandler("cancel", cancel)],
            per_message=False 
        )
        # ...
    ```

---

### **3. Database Storage on Railway.app for an MVP**

For an MVP hosted on Railway, you have two excellent choices for handling your `kazabot_db.json` file. Here’s a comparison to help you decide:

#### **Option 1: Railway Persistent Volume (Recommended for MVP)**

Railway allows you to mount a persistent disk, called a "volume," to your service. This volume acts like a small, attached hard drive that doesn't get erased when you deploy new code or restart your service.

*   **How it Works:** You would configure a volume in your Railway project settings and mount it at a specific path (e.g., `/data`). You would then modify your `DATABASE_PATH` in `config.py` to point to this location (e.g., `DATABASE_PATH = '/data/kazabot_db.json'`).
*   **Pros:**
    *   **Simplicity:** It's the easiest and quickest setup. You stay entirely within the Railway ecosystem.
    *   **Low Latency:** The database file is stored on the same infrastructure as your bot, ensuring fast access.
    *   **Cost-Effective:** Using a small volume is generally included in Railway's free/hobby tier or is very inexpensive.
*   **Cons:**
    *   **Manual Backups:** You are responsible for backing up the JSON file yourself.
    *   **Scalability Limitations:** If your bot becomes extremely popular with high write volumes, a simple JSON file can become a bottleneck.

#### **Option 2: External Database Service (e.g., Supabase)**

Supabase is a "backend-as-a-service" platform that provides a full-featured PostgreSQL database, authentication, and more.

*   **How it Works:** You would create a project on Supabase, get your database connection credentials, and add them to your bot's environment variables on Railway. Your bot would then connect to Supabase over the internet. This would require replacing `TinyDB` with a PostgreSQL client library like `psycopg2-binary`.
*   **Pros:**
    *   **Highly Scalable:** A real SQL database can handle much more data and concurrent users.
    *   **Managed Service:** Supabase handles backups, security, and maintenance for you.
    *   **Powerful Features:** You get a data browser, user management, and API endpoints out of the box.
*   **Cons:**
    *   **Increased Complexity:** You would need to rewrite your entire `database.py` file to work with PostgreSQL instead of TinyDB. This is a significant code change.
    *   **Potential for Higher Latency:** The database connection happens over the network, which can be slightly slower than a local file.
    *   **Learning Curve:** Requires understanding SQL and managing a new service.

**Recommendation for Your MVP:**

**Stick with Railway's persistent volume and TinyDB.**

For an MVP, the primary goal is to test your idea quickly and with minimal complexity. The combination of TinyDB and a Railway volume is perfectly suited for this. It is robust enough to handle the initial user load, and the setup is incredibly straightforward. You can focus on building bot features rather than managing database infrastructure.

If your bot proves successful and you need to scale, migrating to a service like Supabase is a great next step, but it is unnecessary at this early stage.
</file>

<file path="tasks/markdown parsing issue.md">
# Current Task: user report fail bc of markdown render
Date: 31.07.2025

## What I Want to Fix:
When a user Saba tried to create a report, only a photo was being sent. Railway logs had this message:
2025-07-30 20:41:50,837 - handlers - INFO - User Saba Allahverdi submitted report 1793bd71-5dbb-48ce-9e73-c58973d76d6a

2025-07-30 20:41:50,897 - httpx - INFO - HTTP Request: POST https://api.telegram.org/bot7091434973:AAEdbbggzf8WQhYbZZIp4NLREfe6ajaq4OM/sendPhoto "HTTP/1.1 200 OK"

2025-07-30 20:41:50,901 - httpx - INFO - HTTP Request: POST https://api.telegram.org/bot7091434973:AAEdbbggzf8WQhYbZZIp4NLREfe6ajaq4OM/sendMessage "HTTP/1.1 400 Bad Request"

## Current Problem:
I don't know how to proceed with fixing it.

## Desired Outcome:
Saba should be able to create a crash report in the Telegram bot, and the admin should receive the full information from Saba.

## Gemini 2.5 Pro Plan:
Of course. It's frustrating when a bug like this appears. The "400 Bad Request" error is a classic sign of a specific problem, and we can fix it quickly.

Here’s a simple plan to get your bot working correctly.

### **The Problem Explained Simply**

The error `400 Bad Request` from Telegram's `sendMessage` API almost always means one thing: the text you're trying to send has formatting characters that Telegram doesn't understand.

In your `handlers.py` file, you are sending the admin notification using `parse_mode='Markdown'`. This tells Telegram to look for special characters like \` \_ \* \[ \] and treat them as formatting. Your code correctly uses backticks (\`) to format the `report_id` and `user.id`.

However, you also include the user's `username` and the report `description` directly in the message. If a user's name is `saba_a` or they write a description like "two cars, one is a mini-cooper.", the underscores (`_`) or dashes (`-`) will break Telegram's Markdown parser, causing the entire message to be rejected.

### **A Step-by-Step Plan to Fix This**

We will make a small change to the `notify_admins` function in `handlers.py`. The safest and quickest fix is to simply send the admin notification as plain text. The formatting is less important than the admin actually receiving the information.

**Step 1: Locate the Problematic Code**

1.  Open your project and find the file `handlers.py`.
2.  Inside that file, scroll down to the `notify_admins` function.
3.  Find the `await context.bot.send_message(...)` call inside the `for` loop. It looks like this:

    ```python
    # Inside notify_admins function in handlers.py

    await context.bot.send_message(
        chat_id=admin_id,
        text=admin_message,
        reply_markup=reply_markup,
        parse_mode='Markdown'  # <-- THIS IS THE PROBLEM
    )
    ```

**Step 2: Apply the Fix**

All you need to do is remove the `parse_mode` argument. The message will be sent as plain text, which will prevent any formatting errors.

1.  Change the code to look like this:

    ```python
    # Inside notify_admins function in handlers.py

    await context.bot.send_message(
        chat_id=admin_id,
        text=admin_message,
        reply_markup=reply_markup
    )
    ```
2.  Save the `handlers.py` file.
3.  Deploy the updated code to your server (e.g., Railway.app).

That's it. The bug should now be fixed.

### **What Could Go Wrong**

1.  **Admin message loses formatting**: The admin notification will now be plain text. The Report ID and User ID will no longer have the nice grey code block formatting. This is a minor trade-off for making the feature reliable.
2.  **The error persists**: This is very unlikely. If it does, it means a character in the `admin_message` text is somehow invalid for reasons other than Markdown. If this happens, the next step would be to log the `admin_message` text right before it's sent to see exactly what content is causing the failure.

### **How to Test It**

Follow these steps to ensure the fix is working as expected:

1.  **Restart the conversation**: Open your Telegram bot and type `/cancel` to clear any old session, then `/start` to begin a new report.
2.  **Submit a test report**:
    *   Send the location when prompted.
    *   Send a photo.
    *   When asked for a description, **use text with special characters**. For example, type: `A red car and a blue_car.`
3.  **Confirm submission**: Complete the final steps and submit the report.
4.  **Check the admin account**: Open the Telegram account of one of your admins.
    *   **Expected Outcome:** You should see the photo **and** the text notification arrive successfully. The text will be plain, without any bolding or code blocks, but all the information will be there.
5.  **Check your logs**: Look at your Railway.app logs. You should no longer see the `400 Bad Request` error. You should see two "200 OK" responses, one for `sendPhoto` and one for `sendMessage`.

By following this plan, you should be able to resolve the issue in less than 30 minutes.
## Implementation prompt
## What Worked:
Of course. Dealing with bugs like this can be tricky, but the plan is straightforward. Let's get your bot fixed.

### Step 1: Making the Admin Notification Robust

First, I'll address the core issue. To prevent special characters in usernames or report descriptions from crashing the bot, I will modify the `notify_admins` function. I am removing the Markdown formatting from the notification message, which includes taking out the backticks (`) around the `report_id` and `user.id` and removing the `parse_mode` argument from the `send_message` call.

This ensures the notification is sent as plain text, making it reliable.
Ran tool

Excellent. The fix has been applied to `handlers.py`. The `notify_admins` function will now send plain text messages, which resolves the `400 Bad Request` error.

Now that the main issue is resolved, I recommend we also address a related problem. The `review_handler` function, which processes admin decisions, still uses Markdown to update the admin's message. If a username contains special characters, this could cause a similar crash when an admin approves or rejects a report.

To prevent this, I will remove the Markdown formatting from the `review_handler` as well.
Ran tool

Great, that's another potential issue averted.

To complete the process and ensure the bot is fully robust against this type of error, I will make one final change. The notification sent to the original user after an admin reviews their report also uses Markdown. I'll update that to be plain text as well for consistency and to prevent any future issues.
Ran tool
That's the final change. We have now removed all instances of `parse_mode='Markdown'` that could cause issues with user-generated content. Your bot should now be much more robust.

The bug is fixed. Before you deploy, I recommend you follow the test plan outlined in `current-task.md` to be certain everything is working as expected. Let me know if you have any other questions.

## What Didn't Work:
- 

## For Next Time:
-
</file>

<file path=".gitignore">
cat > .gitignore << 'EOF'
.env
venv/
__pycache__/
*.pyc
db.json
.DS_Store
EOF
</file>

<file path="bot.py">
# bot.py - Simplified version after Railway teardown fix
import logging
import asyncio
from telegram.ext import (
    Application,
    ConversationHandler,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)
from config import TELEGRAM_BOT_TOKEN
from handlers import (
    start,
    location,
    photo,
    description,
    description_skip,
    crash_time_delta,
    submit,
    cancel,
    review_handler,
    LOCATION,
    PHOTO,
    DESCRIPTION,
    CRASH_TIME_DELTA,
    CONFIRMATION,
)

# Simple logging setup
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", 
    level=logging.INFO
)
logger = logging.getLogger(__name__)

def main() -> None:
    """Run the bot - simplified version."""
    
    # Create the Application with minimal timeout config
    application = (
        Application.builder()
        .token(TELEGRAM_BOT_TOKEN)
        .get_updates_read_timeout(30)
        .get_updates_write_timeout(30)
        .get_updates_connect_timeout(30)
        .build()
    )

    # Add conversation handler
    conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler("start", start),
            MessageHandler(filters.Regex(r"^➕ New Report$"), start),
        ],
        states={
            LOCATION: [MessageHandler(filters.LOCATION, location)],
            PHOTO: [MessageHandler(filters.PHOTO, photo)],
            DESCRIPTION: [
                MessageHandler(filters.Regex(r"(?i)^skip$"), description_skip),
                MessageHandler(filters.TEXT & ~filters.COMMAND, description),
            ],
            CRASH_TIME_DELTA: [MessageHandler(filters.TEXT & ~filters.COMMAND, crash_time_delta)],
            CONFIRMATION: [
                MessageHandler(filters.Regex(r"(?i)^Submit Report$"), submit),
                MessageHandler(filters.Regex(r"(?i)^Cancel$"), cancel),
            ],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
        per_message=False
    )

    application.add_handler(conv_handler)
    application.add_handler(CallbackQueryHandler(review_handler))

    logger.info("Starting KazaBot...")
    
    # Simple polling - no complex retry logic needed
    application.run_polling(
        poll_interval=2.0,
        drop_pending_updates=True
    )

if __name__ == "__main__":
    main()
</file>

<file path="config.py">
# config.py - Configuration management
import os
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Bot configuration - Changed from TELEGRAM_TOKEN to TELEGRAM_BOT_TOKEN
TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
if not TELEGRAM_BOT_TOKEN:
    raise ValueError("No TELEGRAM_BOT_TOKEN found in environment variables")

# Database configuration
# Use Railway volume for persistent storage
DATABASE_PATH = os.environ.get('RAILWAY_VOLUME_MOUNT_PATH', '')
if DATABASE_PATH:
    DATABASE_PATH = os.path.join(DATABASE_PATH, 'kazabot_db.json')
else:
    # Fallback for local development
    DATABASE_PATH = 'kazabot_db.json'

# Validation constraints
MAX_DESCRIPTION_LENGTH = 200
MIN_CRASH_TIME = 0  # minutes
MAX_CRASH_TIME = 60  # minutes
MAX_REPORTS_PER_DAY = 3

# Conversation states
LOCATION, PHOTO, DESCRIPTION, CRASH_TIME_DELTA, CONFIRMATION = range(5)

# --- Load Admin User IDs from .env file ---
admin_ids_str = os.getenv('ADMIN_IDS', '') # Get the comma-separated string

# Process the string into a list of integers
if admin_ids_str:
    try:
        # Split the string by commas and convert each part to an integer
        ADMIN_IDS = [int(admin_id.strip()) for admin_id in admin_ids_str.split(',')]
    except ValueError:
        print("Error: ADMIN_IDS in .env file contains non-numeric values. Please check it.")
        ADMIN_IDS = [] # Default to an empty list on error
else:
    # If the variable is not set, default to an empty list
    ADMIN_IDS = []

# It's good practice to log or print the loaded admins on startup to verify
if not ADMIN_IDS:
    print("Warning: No ADMIN_IDS found in .env file. Admin features will be disabled.")
else:
    print(f"Admin users loaded successfully: {ADMIN_IDS}")
</file>

<file path="database.py">
# database.py
import uuid
import logging
from datetime import datetime, timedelta
from tinydb import TinyDB, Query
from config import DATABASE_PATH

# Enable logging
logger = logging.getLogger(__name__)

# Initialize the database with the path from config
db = TinyDB(DATABASE_PATH, indent=4)
reports_table = db.table('reports')
users_table = db.table('users')

def save_report(user_id, report_data):
    """
    Saves a new accident report to the database.
    """
    report_id = str(uuid.uuid4())
    submitted_at = datetime.utcnow().isoformat()

    report = {
        'report_id': report_id,
        'telegram_user_id': user_id,
        'location_geo': report_data.get('location'),
        'location_time': report_data.get('location_timestamp'),
        'photo_file_id': report_data.get('photo'),
        'photo_time': report_data.get('photo_timestamp'),
        'description': report_data.get('description'),
        'crash_time_delta': report_data.get('crash_time_delta'),
        'submitted_at': submitted_at,
        'status': 'pending', # pending/verified/duplicate/rewarded
        'reward_sent': False
    }
    reports_table.insert(report)
    return report_id

def get_or_create_user(user_id, username):
    """
    Retrieves a user profile or creates a new one with an initial balance.
    """
    User = Query()
    user = users_table.get(User.telegram_user_id == user_id)

    if not user:
        user_profile = {
            'telegram_user_id': user_id,
            'username': username,
            'created_at': datetime.utcnow().isoformat(),
            'courier_company': None,
            'payment_method': None,
            'report_count': 0,
            'balance': 99  # NEW: Add initial balance of 99 Lira
        }
        users_table.insert(user_profile)
        return user_profile
    return user

def update_user_balance(user_id, amount_to_add):
    """
    Increments a user's balance by a specified amount.
    """
    User = Query()
    user = users_table.get(User.telegram_user_id == user_id)
    if user:
        # Handle cases where older users might not have a balance field
        current_balance = user.get('balance', 0) 
        new_balance = current_balance + amount_to_add
        users_table.update({'balance': new_balance}, User.telegram_user_id == user_id)
        logger.info(f"Updated balance for user {user_id}. New balance: {new_balance}")
        return new_balance
    return None

def update_user_profile(user_id, data_to_update):
    """
    Updates a user's profile with new information (e.g., company, report count).
    """
    User = Query()
    users_table.update(data_to_update, User.telegram_user_id == user_id)

def get_user_report_count_today(user_id):
    """
    Counts how many reports a user has submitted in the last 24 hours.
    """
    Report = Query()
    twenty_four_hours_ago = (datetime.utcnow() - timedelta(days=1)).isoformat()
    
    user_reports = reports_table.search(
        (Report.telegram_user_id == user_id) & 
        (Report.submitted_at >= twenty_four_hours_ago)
    )
    return len(user_reports)
    # database.py (add these functions)

def get_report_by_id(report_id):
    """Retrieves a single report by its unique ID."""
    Report = Query()
    report = reports_table.get(Report.report_id == report_id)
    return report

def update_report_status(report_id, new_status, admin_id):
    """Updates the status of a report and logs which admin did it."""
    Report = Query()
    reports_table.update(
        {'status': new_status, 'reviewed_by': admin_id}, 
        Report.report_id == report_id
    )
</file>

<file path="handlers.py">
# handlers.py
import logging
from datetime import datetime
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)
from database import save_report, get_or_create_user, update_user_profile, get_user_report_count_today
from config import ADMIN_IDS 
from database import ( 
    save_report, 
    get_or_create_user, 
    update_user_profile,
    get_report_by_id, 
    update_report_status,
    update_user_balance # <-- ADD THIS
)

# Enable logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# Define states for the conversation
(
    LOCATION,
    PHOTO,
    DESCRIPTION,
    CRASH_TIME_DELTA,
    CONFIRMATION,
    COMPANY_NAME,
) = range(6)
# --- NEW: Reusable keyboard for starting a new report ---
NEW_REPORT_KEYBOARD = ReplyKeyboardMarkup([["➕ New Report"]], resize_keyboard=True, one_time_keyboard=False)

# --- Start & Cancel ---

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Starts the conversation, shows a welcome message, and asks for the accident location."""
    user = update.message.from_user
    logger.info("User %s started the conversation.", user.first_name)
    
    # --- NEW: Send welcome message and image ---
    # Replace 'YOUR_FILE_ID_HERE' with the actual file_id you obtained
    photo_file_id = 'AgACAgQAAxkBAAPCaIu8_FQu7pFVNR7X8AAB5O_shWW2AALfxzEbZKFhUOKlznwiwuHuAQADAgADeAADNgQ' 
    welcome_caption = (
        "Welcome to Kazabot! We've added a starting balance of 99 ₺ to your account for joining us. "
        "For every accident report you submit that is verified by our team, you will earn a 100 ₺ reward. "
        "You can withdraw your earnings once your total balance reaches 500 ₺.\n\n"
        "Let's get started! Please share the accident's location by pressing the button below."
    )
    get_or_create_user(user.id, user.username)

    location_keyboard = KeyboardButton(text="Share Accident Location", request_location=True)
    custom_keyboard = [[location_keyboard]]
    reply_markup = ReplyKeyboardMarkup(custom_keyboard, resize_keyboard=True, one_time_keyboard=True)

    await context.bot.send_photo(
        chat_id=update.effective_chat.id,
        photo=photo_file_id,
        caption=welcome_caption,
        reply_markup=reply_markup,
        read_timeout=20,
        write_timeout=20
    )
    # --- End of new section ---
    
    # Onboard the user if they are new and set initial balance
    

    return LOCATION

# --- Reporting Flow ---

async def location(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the location and asks for a photo."""
    user_location = update.message.location
    context.user_data['report'] = {
        'location': (user_location.latitude, user_location.longitude),
        'location_timestamp': datetime.utcnow().isoformat()
    }
    logger.info("Location from %s: %s", update.message.from_user.first_name, user_location)
    
    await update.message.reply_text(
        "Great! Now, please take a clear photo of the accident and send it to me.",
        reply_markup=ReplyKeyboardRemove(),
    )
    return PHOTO

async def photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the photo and asks for a description."""
    user_photo = update.message.photo[-1] # Get the highest resolution photo
    context.user_data['report']['photo'] = user_photo.file_id
    context.user_data['report']['photo_timestamp'] = datetime.utcnow().isoformat()
    
    logger.info("Photo received from %s", update.message.from_user.first_name)
    
    reply_keyboard = [["Skip"]]
    await update.message.reply_text(
        "Photo received. Now, please add a short description (e.g., 'two cars, rear-end'). "
        "This is optional. You can also type 'Skip'.",
        reply_markup=ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True, one_time_keyboard=True),
    )
    return DESCRIPTION

async def description(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the description and asks for the time delta."""
    user_description = update.message.text
    if user_description.lower() != 'skip':
        if len(user_description) > 200:
            await update.message.reply_text("The description is too long (max 200 characters). Please try again.")
            return DESCRIPTION
        context.user_data['report']['description'] = user_description
    else:
        context.user_data['report']['description'] = None
        
    logger.info("Description from %s: %s", update.message.from_user.first_name, user_description)
    await update.message.reply_text(
        "Got it. Roughly how many minutes ago did the crash happen? (Please enter a number from 0 to 60)",
        reply_markup=ReplyKeyboardRemove(),
    )
    return CRASH_TIME_DELTA

async def description_skip(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Skips the description and asks for the time delta."""
    context.user_data['report']['description'] = None
    logger.info("User %s skipped the description.", update.message.from_user.first_name)
    await update.message.reply_text(
        "Description skipped. Roughly how many minutes ago did the crash happen? (Please enter a number from 0 to 60)",
        reply_markup=ReplyKeyboardRemove(),
    )
    return CRASH_TIME_DELTA


async def crash_time_delta(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the time delta and asks for final confirmation."""
    text = update.message.text
    try:
        delta = int(text)
        if not (0 <= delta <= 60):
            raise ValueError
        context.user_data['report']['crash_time_delta'] = delta
    except (ValueError, TypeError):
        await update.message.reply_text("That's not a valid number. Please enter a number between 0 and 60.")
        return CRASH_TIME_DELTA

    # Show summary
    report = context.user_data['report']
    summary = (
        f"--- REVIEW YOUR REPORT ---\n"
        f"📍 Location: Sent\n"
        f"📸 Photo: Sent\n"
        f"📝 Description: {report.get('description', 'N/A')}\n"
        f"⏱️ Time Since Crash: ~{report.get('crash_time_delta')} minutes ago\n\n"
        "Is everything correct?"
    )
    reply_keyboard = [["Submit Report", "Cancel"]]
    await update.message.reply_text(
        summary,
        reply_markup=ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True, one_time_keyboard=True),
    )
    return CONFIRMATION

async def submit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Submits the report, saves it, and transitions to the final steps."""
    user = update.message.from_user
    report_data = context.user_data.get('report')
    
    if not report_data:
        await update.message.reply_text("Something went wrong. Please start over with /start.")
        return ConversationHandler.END

    # Save the report
    report_id = save_report(user.id, report_data)
    logger.info("User %s submitted report %s", user.first_name, report_id)

    # Update user's report count
    user_profile = get_or_create_user(user.id, user.username)
    new_count = user_profile.get('report_count', 0) + 1
    update_user_profile(user.id, {'report_count': new_count})
    
    # Notify admins
    await notify_admins(context, user, report_id, report_data)
    
    # --- MODIFICATION: Temporarily disable company name question ---
    # if user_profile.get('courier_company') is None:
    #     await update.message.reply_text(
    #         "✅ Success! Your report has been submitted.\n\n"
    #         "To help us, could you tell us which courier company you work for? (e.g., 'Getir', 'Trendyol Go'). This is optional.",
    #          reply_markup=ReplyKeyboardRemove(),
    #     )
    #     return COMPANY_NAME
    # else:
    #     # If company name is known, end the conversation
    #     return await finish(update, context)
    await update.message.reply_text("✅ Success! Your report has been submitted.\n\n")
    return await finish(update, context) # Always go to the finish state
    # --- End of modification ---


# --- MODIFICATION: Comment out the unused handler ---
# async def company_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
#     """Saves the user's courier company and ends the conversation."""
#     user_id = update.message.from_user.id
#     company = update.message.text
    
#     update_user_profile(user_id, {'courier_company': company})
#     logger.info("User %s set their company to %s", update.message.from_user.first_name, company)
    
#     await update.message.reply_text("Thank you! Your profile has been updated.")
    
#     return await finish(update, context)
# --- End of modification ---


async def finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Clears user data and shows the final message with the 'New Report' button."""
    context.user_data.clear()
    await update.message.reply_text(
        "You can now submit a new report or close this chat.",
        reply_markup=NEW_REPORT_KEYBOARD,
    )
    return ConversationHandler.END


async def notify_admins(context: ContextTypes.DEFAULT_TYPE, user, report_id, report_data):
    """Sends a notification to all admins about a new report."""
    admin_message = (
        f"🚨 New Accident Report Submitted 🚨\n\n"
        f"Report ID: {report_id}\n"
        f"Submitted By: @{user.username} (ID: {user.id})\n"
        f"Description: {report_data.get('description', 'N/A')}\n"
        f"Time Delta: ~{report_data.get('crash_time_delta')} minutes ago"
    )
    
    keyboard = [
        [
            InlineKeyboardButton("✅ Approve", callback_data=f"approve_{report_id}"),
            InlineKeyboardButton("❌ Reject", callback_data=f"reject_{report_id}"),
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    for admin_id in ADMIN_IDS:
        try:
            await context.bot.send_photo(chat_id=admin_id, photo=report_data['photo'])
            await context.bot.send_message(
                chat_id=admin_id,
                text=admin_message,
                reply_markup=reply_markup
            )
            logger.info(f"Sent notification for report {report_id} to admin {admin_id}")
        except Exception as e:
            logger.error(f"Failed to send notification to admin {admin_id}: {e}")


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancels the conversation and shows the 'New Report' button."""
    user = update.message.from_user
    logger.info("User %s canceled the conversation.", user.first_name)
    context.user_data.clear()
    await update.message.reply_text(
        "Report canceled. You can start a new one anytime.",
        reply_markup=NEW_REPORT_KEYBOARD, # Use our new keyboard
    )
    return ConversationHandler.END


async def review_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handles admin decisions from inline keyboard buttons."""
    query = update.callback_query
    await query.answer() # Acknowledge the button press

    admin_user = query.from_user
    action, report_id = query.data.split("_")

    if admin_user.id not in ADMIN_IDS:
        await query.edit_message_text(text="Sorry, you are not authorized to perform this action.")
        return

    report = get_report_by_id(report_id)
    if not report:
        await query.edit_message_text(text=f"Error: Report {report_id} not found.")
        return
    
    if report['status'] != 'pending':
        await query.edit_message_text(text=f"This report has already been reviewed. Status: {report['status']}.")
        return

    # Update status and notify the user
    new_status = "verified" if action == "approve" else "rejected"
    update_report_status(report_id, new_status, admin_user.id)
    
    # Update the admin's message to show the result
    final_text = query.message.text + f"\n\n--- Decision ---\nStatus set to {new_status.upper()} by @{admin_user.username}."
    await query.edit_message_text(text=final_text)

    # Notify the original user
    original_user_id = report['telegram_user_id']
    user_notification = f"UPDATE: Your report (ID: {report['report_id']}) has been {new_status}."
    
    if new_status == 'verified':
        # --- NEW: Update balance and notify user ---
        reward_amount = 100 # Define your reward amount here
        new_balance = update_user_balance(original_user_id, reward_amount)
        user_notification += (
            f"\n\nCongratulations! {reward_amount} TL has been added to your account. "
            f"Your new balance is {new_balance} TL."
        )
        # --- End of new section ---
    
    try:
        await context.bot.send_message(
            chat_id=original_user_id,
            text=user_notification
        )
    except Exception as e:
        logger.error(f"Failed to send status update to user {original_user_id}: {e}")
</file>

<file path="kazabot_db.json">
{
    "users": {
        "1": {
            "telegram_user_id": 4462330,
            "username": "mrvooooo",
            "created_at": "2025-07-30T18:05:09.870369",
            "courier_company": "Getir",
            "payment_method": null,
            "report_count": 1
        },
        "2": {
            "telegram_user_id": 7127606451,
            "username": "rewd0glamd",
            "created_at": "2025-07-30T19:24:09.028355",
            "courier_company": "Getir",
            "payment_method": null,
            "report_count": 11,
            "balance": 300
        }
    },
    "reports": {
        "1": {
            "report_id": "2d156c1b-68eb-49cb-af1b-00f27707b32d",
            "telegram_user_id": 4462330,
            "location_geo": [
                38.432951,
                27.162072
            ],
            "location_time": "2025-07-30T18:05:31.830144",
            "photo_file_id": "AgACAgIAAxkBAAMFaIpe_EWfcVoX0NSX0mgIQAZB-t0AAqv3MRvjwlFIKRrfjwEHeEIBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T18:05:48.250580",
            "description": "masterful coding",
            "crash_time_delta": 0,
            "submitted_at": "2025-07-30T18:06:15.584885",
            "status": "pending",
            "reward_sent": false
        },
        "2": {
            "report_id": "25405c14-5629-40cf-a3ac-69dd234f499b",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:24:25.945855",
            "photo_file_id": "AgACAgQAAxkBAAMUaIpxf_Nkuum2freWHeVOEQbhdagAAs_LMRtkoVlQR0RDdOuUEjYBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:24:47.503329",
            "description": null,
            "crash_time_delta": 5,
            "submitted_at": "2025-07-30T19:25:02.912718",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "3": {
            "report_id": "e436d6c3-679f-4e35-a3e6-b9a07f362818",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:41:32.081860",
            "photo_file_id": "AgACAgQAAxkBAAMmaIp1eebMWgl_HAN88HD6dyowyPQAAtXLMRtkoVlQZxNh-hoxm-gBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:41:45.601875",
            "description": "Test3: button add",
            "crash_time_delta": 0,
            "submitted_at": "2025-07-30T19:42:04.169922",
            "status": "rejected",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "4": {
            "report_id": "1fa7e2e7-1ae0-4c94-9fa6-7c6c4eb100fc",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:42:27.204362",
            "photo_file_id": "AgACAgQAAxkBAAM0aIp1vnXSYeWzKOGGtQdTR0cerAgAAtfLMRtkoVlQVAPjHxaAMeYBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:42:54.313088",
            "description": null,
            "crash_time_delta": 9,
            "submitted_at": "2025-07-30T19:43:15.203505",
            "status": "rejected",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "5": {
            "report_id": "7faf682c-b7d4-4ff3-89ae-58531ab819b8",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:51:19.351171",
            "photo_file_id": "AgACAgQAAxkBAAMUaIpxf_Nkuum2freWHeVOEQbhdagAAs_LMRtkoVlQR0RDdOuUEjYBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:51:27.247422",
            "description": "Hello",
            "crash_time_delta": 0,
            "submitted_at": "2025-07-30T19:51:39.011673",
            "status": "pending",
            "reward_sent": false
        },
        "6": {
            "report_id": "a12c1c62-c03b-44cd-bb7d-43b5a968c6a5",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T17:45:49.427828",
            "photo_file_id": "AgACAgQAAxkBAAOjaIur2MrnF_ZZcLHVOgeFv813gcgAAsXHMRtkoWFQ5qMeDqtMKSMBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T17:46:00.486139",
            "description": "Djdhdhdhd \ud83d\udc4c//// !!! #$$",
            "crash_time_delta": 9,
            "submitted_at": "2025-07-31T17:46:22.254973",
            "status": "pending",
            "reward_sent": false
        },
        "7": {
            "report_id": "3dc52cdf-b5c6-4696-a0ec-16b3ab8cf0ee",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T17:48:28.763276",
            "photo_file_id": "AgACAgQAAxkBAAOjaIur2MrnF_ZZcLHVOgeFv813gcgAAsXHMRtkoWFQ5qMeDqtMKSMBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T17:48:35.636265",
            "description": "\ud83d\ude0d\ud83d\ude01\ud83d\ude0d\ud83d\ude01\ud83d\udc8b\ud83d\ude2d\ud83d\ude33\ud83d\ude1d",
            "crash_time_delta": 0,
            "submitted_at": "2025-07-31T17:48:57.947763",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "8": {
            "report_id": "779ed8b2-7b0e-485b-93c7-37c0592f2d03",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T18:59:01.366378",
            "photo_file_id": "AgACAgQAAxkBAAPCaIu8_FQu7pFVNR7X8AAB5O_shWW2AALfxzEbZKFhUOKlznwiwuHuAQADAgADeAADNgQ",
            "photo_time": "2025-07-31T18:59:08.259151",
            "description": null,
            "crash_time_delta": 0,
            "submitted_at": "2025-07-31T18:59:15.958670",
            "status": "pending",
            "reward_sent": false
        },
        "9": {
            "report_id": "e96c69da-4df8-46e2-b068-4134bf39c919",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T19:04:44.449882",
            "photo_file_id": "AgACAgQAAxkBAAPSaIu-X_N96rb9pqgfNtU6bBEOoWYAAufHMRtkoWFQ8E_q13bdgZIBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T19:05:03.164804",
            "description": null,
            "crash_time_delta": 5,
            "submitted_at": "2025-07-31T19:05:12.681631",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "10": {
            "report_id": "8d0be8f4-697b-4f20-9f00-68cfcad7d79c",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T19:16:28.425785",
            "photo_file_id": "AgACAgQAAxkBAAPlaIvBGGXUvtjPw3uxGmg_If7jzZIAAunHMRtkoWFQLh9zKtTjSFoBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T19:16:40.508592",
            "description": null,
            "crash_time_delta": 9,
            "submitted_at": "2025-07-31T19:16:47.984138",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "11": {
            "report_id": "a7ab3df7-f31b-4ee9-aae1-82ddf9d3c0fb",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T19:17:30.376216",
            "photo_file_id": "AgACAgQAAxkBAAP2aIvBWBOOx0qV0PiMwmlj3hH5js0AAurHMRtkoWFQ-xoM50j9h94BAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T19:17:44.301290",
            "description": "Balance check",
            "crash_time_delta": 6,
            "submitted_at": "2025-07-31T19:17:57.308006",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "12": {
            "report_id": "fe95bb76-b908-476d-919a-30a97742dbe3",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.433063,
                27.164084
            ],
            "location_time": "2025-08-04T18:51:09.113514",
            "photo_file_id": "AgACAgQAAxkBAAIBO2iRASxIb96ZzY-Wu-IxPGFi1vuXAAJEyzEb1daIUHuIEb9Ro-N4AQADAgADeQADNgQ",
            "photo_time": "2025-08-04T18:51:24.285511",
            "description": null,
            "crash_time_delta": 9,
            "submitted_at": "2025-08-04T18:51:32.320416",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        }
    }
}
</file>

<file path="next-actions.md">
# **Daenah Bot Development Plan**
#### **1. Implement Payout Logic**
*   **Verdict:** **Essential.** The core loop of your bot is "Report -> Get Verified -> Get Paid." Without a way to manage payouts, the balance becomes meaningless.
*   **Criticism/Suggestion:** Instead of just "withdrawing" money, think of it as "recording a payout." The admin performs a payout outside the bot (e.g., a bank transfer) and then uses a command to update the bot's database.
*   **MVP Action:** Create a simple admin-only command: `/odeme <user_id> <amount>`.
    *   This command should first check if the person using it is an admin.
    *   It subtracts the `<amount>` from the user's balance in `database.py`.
    *   It sends a confirmation message to the admin (`"Payout of 150 ₺ for user 12345 has been recorded. New balance: 350 ₺"`).
    *   It sends a notification to the user (`"A payout of 150 ₺ has been processed! Your new balance is 350 ₺."`).

#### **2. Add Stable Database Using Railway.app Volumes**
*   **Verdict:** **CRITICAL.** This is non-negotiable. Without this, your bot will lose all user data on every restart or deploy, making it completely unusable.
*   **Criticism/Suggestion:** Your plan is perfect. Using Railway volumes with TinyDB is the ideal intersection of simplicity and persistence for an MVP.
*   **MVP Action:** Follow these exact steps:
    1.  In your Railway project, go to your service settings and add a **Volume**.
    2.  Set the **Mount Path** to `/data`.
    3.  In your `config.py` file, change the database path to use this volume:
        `DATABASE_PATH = '/data/kazabot_db.json'`
    4.  Deploy your bot. Railway will now ensure that the `kazabot_db.json` file persists across restarts.

#### **3. Handle User Deletion/Restart**
*   **Verdict:** **Already solved!** This is a great thing to worry about, but your current implementation handles it correctly.
*   **Clarification:** You are currently using `user.id` (`update.message.from_user.id`) as the unique identifier. This `user_id` is a permanent integer assigned by Telegram to each user account. It **does not change** if a user deletes the chat, blocks the bot, or even changes their @username. Your system will always recognize them correctly when they return.
*   **MVP Action:** No action needed. Be confident that using `user.id` is the correct and robust method.

#### **4. Decide if We Need to Ask for Their Phone Number**
*   **Verdict:** **No, not for the MVP.**
*   **Reasoning:** Every extra piece of information you ask for increases the chance a user will quit. For an MVP, you need to be ruthless about removing friction. You don't have a clear use for the phone number yet. Payouts will likely be done via IBAN, not a phone number. Support can be handled via Telegram itself.
*   **MVP Action:** Postpone this. Only add it later if a clear, unavoidable business need arises.

#### **5. Implement Contact Support Button**
*   **Verdict:** **Essential.** Users will always have questions or issues. A dead end with no support option is frustrating and leads to users abandoning the bot.
*   **MVP Action:** Create a simple `/destek` command in `handlers.py`.
    *   When a user types `/destek`, the bot should reply with a simple message.
    *   **Option A (Easiest):** `"Herhangi bir sorun veya sorun için destek ekibimize destek@yourcompany.com adresinden e-posta gönderebilirsiniz."` (For any questions or issues, you can email our support team at...).
    *   **Option B (Better):** `"Destek talebinizi bu gruba iletebilirsiniz: [Link to a private Telegram group where admins are members]"` (You can forward your support request to this group: ...).

#### **6. Completely Remove the Code for the Company Name Field**
*   **Verdict:** **Excellent idea.** This is good code hygiene.
*   **Reasoning:** Commented-out "dead code" adds clutter and can confuse future development.
*   **MVP Action:**
    1.  Delete the `company_name` function from `handlers.py`.
    2.  Delete the `COMPANY_NAME` state variable from the top of `handlers.py` and from the `ConversationHandler` in `bot.py`.
    3.  In `database.py`, remove `'courier_company': None,` from the `user_profile` dictionary in the `get_or_create_user` function.

#### **7. Add Instructions for Serviceable Zones**
*   **Verdict:** **Essential.** This manages user expectations perfectly and will save you and your users a lot of frustration from rejected reports.
*   **MVP Action:** Add the zone information in two key places:
    1.  **Bot Description (BotFather):** Edit the `/setdescription` text to include a line like: `"(!) Şu anda sadece **İzmir'in Konak ve Bornova** ilçelerindeki raporları kabul ediyoruz."` ((!) We currently only accept reports from the Konak and Bornova districts of Izmir.).
    2.  **Welcome Message (`/start`):** Add the same sentence to the welcome message in `handlers.py` to reinforce it.

#### **8. Implement Automatic Zone Check**
*   **Verdict:** **Postpone.** This is a "nice-to-have" automation, not an MVP essential.
*   **Reasoning:** For an MVP, the admin can and should do this manually. It takes 5 seconds to look at the location on a map. You should only automate this *after* you've proven that:
    a) The bot is getting enough reports to make manual checking a burden.
    b) Out-of-zone reports are a common problem.
*   **MVP Action:** Do nothing. Let the admins manually check the location and reject reports that are out of bounds.

#### **9. Implement Spam Prevention**
*   **Verdict:** **High Priority.** This is a simple and effective protection.
*   **Reasoning:** You've already done the hard work of writing the code!
*   **MVP Action:** In `handlers.py`, find the `start` function and **uncomment** the code block that checks the daily report limit.

    ```python
    # In handlers.py -> start()
    # UNCOMMENT THIS BLOCK
    report_count = get_user_report_count_today(user.id)
    if report_count >= MAX_REPORTS_PER_DAY:
        await update.message.reply_text(
            f"Günlük rapor limitinize ({MAX_REPORTS_PER_DAY}) ulaştınız. Lütfen yarın tekrar deneyin."
        )
        return ConversationHandler.END
    ```

---

### **Further MVP Suggestions**

Here are a few more simple, high-impact features to consider for your MVP:

*   **Add a `/bakiye` (Balance) Command:** Users will want to check their balance without starting a new report. This is a very simple handler that gets the user's profile and replies with their current balance.
*   **Add a `/kurallar` (Rules) Command:** A simple command that reminds the user of the key rules: reward amount, payout threshold (500 ₺), and serviceable zones.
*   **Improve Admin Notifications:** In `notify_admins` in `handlers.py`, you can easily add a Google Maps link to the location. This makes the admin's job much easier.

    ```python
    # In handlers.py -> notify_admins()
    lat, lon = report_data['location']
    maps_link = f"https://www.google.com/maps/search/?api=1&query={lat},{lon}"
    admin_message = (
        f"🚨 New Accident Report Submitted 🚨\n\n"
        f"📍 Location: [Open on Google Maps]({maps_link})\n" # Add this link
        # ... rest of the message
    )
    ```

### **Prioritized MVP Roadmap**

Based on this analysis, here is your action plan, sorted by priority:

**Tier 1: Do Immediately (Foundation)**
1.  **Stable Database:** Configure Railway Volumes.
2.  **Remove Company Code:** Clean up the codebase.
3.  **Add Serviceable Zones:** Update BotFather and the `/start` message.
4.  **Implement Spam Prevention:** Uncomment the existing code.

**Tier 2: Do Next (Core Functionality)**
5.  **Implement Payout Logic:** Create the `/odeme` admin command.
6.  **Implement Support:** Create the `/destek` command.
7.  **Add Balance Check:** Create the `/bakiye` command.

**Tier 3: Postpone for Later**
8.  ~~Ask for Phone Number~~ (Decided against for now).
9.  **Automatic Zone Check:** Wait until this becomes a proven pain point.
</file>

<file path="Procfile">
worker: python bot.py
</file>

<file path="project-description.md">
### **DaenahBot: A Real-Time Car Accident Reporting Telegram Bot**

This document outlines the technical implementation of DaenahBot, a Telegram bot designed for motor couriers in Turkey to report minor car accidents in real-time. This MVP focuses on rapid data collection and user engagement.

### 1. Core Technologies

*   **Programming Language:** Python
*   **Telegram Bot Framework:** The project uses `python-telegram-bot`, a comprehensive library for building Telegram bots.
*   **Database:** `TinyDB` is employed as a lightweight, file-based database, suitable for the project's current scale.

### 2. Project Structure

The project is organized into several Python files, ensuring a modular and maintainable codebase:

*   `bot.py`: The main application entry point that initializes the bot and its handlers.
*   `handlers.py`: Defines all the conversation and command handlers, managing the user interaction flow.
*   `database.py`: Manages all interactions with the `TinyDB` database, including saving and retrieving user and report data.
*   `config.py`: Stores configuration variables, such as the Telegram bot token and admin user IDs, loaded from an environment file.
*   `requirements.txt`: Lists all Python dependencies for the project.
*   `Procfile`: Specifies the command to be executed by the web server to run the application.
*   `kazabot_db.json`: The TinyDB JSON file that serves as the database.
*   `.gitignore`: Specifies intentionally untracked files to be ignored by Git.

### 3. Detailed Implementation

#### **Step 1: Environment and Configuration**

The project uses a `.env` file to manage environment variables, most notably the `TELEGRAM_BOT_TOKEN`. The `config.py` file loads these variables and defines application-wide constants such as database path, validation constraints, and conversation states. It also loads a list of admin user IDs for administrative features.

#### **Step 2: Database and Data Management**

The `database.py` script initializes a `TinyDB` database stored in `kazabot_db.json`. It provides functions to:

*   Save new accident reports with a unique ID, user information, and timestamps.
*   Create or retrieve user profiles, storing their Telegram ID, username, and report count.
*   Update user profiles, for instance, to add their courier company or increment their report count.
*   Retrieve a specific report by its ID.
*   Update a report's status (e.g., to 'verified' or 'rejected') and record which admin reviewed it.

A notable deviation from the initial plan is the absence of a dedicated `models.py` file with Pydantic models for data validation. Data validation is instead handled within the handler functions.

#### **Step 3: Bot Logic and User Flow**

The core of the bot's functionality is built around a `ConversationHandler` from the `python-telegram-bot` library. This manages the stateful, step-by-step process of submitting an accident report.

The implemented conversation states are:

*   **LOCATION:** Asks for and receives the user's location.
*   **PHOTO:** Prompts for and stores a photo of the accident.
*   **DESCRIPTION:** Asks for an optional text description of the incident.
*   **CRASH_TIME_DELTA:** Inquires about the time elapsed since the accident.
*   **CONFIRMATION:** Displays a summary of the report and asks for user confirmation before submission.
*   **COMPANY_NAME:** After the first report, it asks the user for their courier company to enrich their profile.

**User Onboarding:** The bot creates a user profile upon their first interaction. After a successful report, it prompts for the courier company they work for.

#### **Step 4: Admin Features and Notifications**

A significant feature implemented is the admin notification and review system:

*   **Admin Notification:** Upon a new report submission, a notification is sent to all admin users defined in the `ADMIN_IDS` configuration. This message includes the report details and a photo.
*   **Inline Keyboard for Review:** The admin notification includes an inline keyboard with "Approve" and "Reject" buttons.
*   **Review Handling:** A `CallbackQueryHandler` processes the admin's choice. It updates the report's status in the database and notifies the original user of the outcome.

#### **Step 5: User Interface and Experience**

The bot utilizes `ReplyKeyboardMarkup` for interactive buttons, such as "Share Accident Location" and a persistent "➕ New Report" button, which allows users to easily start a new report after completing or canceling a previous one.

### **Summary of Implemented vs. Planned Features**

| Feature | Initial Plan | Implemented Reality |
| :--- | :--- | :--- |
| **Core Framework** | `python-telegram-bot`, `TinyDB` | Fully implemented as planned. |
| **Data Models** | Pydantic models in `models.py` | Not implemented. Data validation is handled directly in handlers. |
| **User Flow** | `ConversationHandler` with states for location, photo, description, time delta, and confirmation. | Fully implemented, with an additional state for capturing the user's company name. |
| **User Onboarding** | Low-friction onboarding, asking for company name after the first report. | Implemented as planned. |
| **Spam Prevention**| Rate limiting of 3 reports per user per 24 hours. | The code for this is commented out in `handlers.py` and is therefore not active. |
| **Admin Features**| Direct database access for manual verification. | A more advanced system with Telegram notifications and an inline keyboard for report approval/rejection was built. |
| **Reward System** | A `status` field in the database to track report verification and reward status. | The `status` field (`pending`, `verified`, `rejected`) and a `reward_sent` boolean are in the database. A message about potential rewards is sent for verified reports. The actual payout logic is not implemented. |
</file>

<file path="railway.json">
{
  "$schema": "https://railway.app/railway.schema.json",
  "environments": {
    "production": {
      "variables": {
        "RAILWAY_DEPLOYMENT_OVERLAP_SECONDS": "0"
      }
    }
  }
}
</file>

<file path="repomix-output-stan-voo-daenahbot.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
tasks/
  Bot Welcome Message and Image.md
  markdown parsing issue.md
.gitignore
bot.py
config.py
database.py
handlers.py
kazabot_db.json
next-actions.md
Procfile
project-description.md
repomix-output-stan-voo-daenahbot.xml
requirements.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="tasks/Bot Welcome Message and Image.md">
Bot Welcome Message and Image.md
Of course. Here is the extracted text, translation, and a comprehensive plan to implement the requested features, along with recommendations for your database strategy.

### **1. Bot Welcome Message and Image**

Here is the extracted text from the image and its English translation.

**Original Turkish Text:**

> **Kazayı Bildir, Kazan!**
> Bu bot üzerinden gördüğünüz trafik kazalarını bize bildirebilir ve kazanç sağlayabilirsiniz.
> 
> 🚗 Kaza yerinden bir fotoğraf çekip, konum bilgisiyle birlikte gönderin.
> ✅ Bilgiler doğrulandıktan sonra, 24 saat içinde hesabınıza 1000 TL yatırılır.
> 📞 Bilgiler doğruysa, destek ekibimiz sizinle iletişime geçecektir.
> 
> Unutmayın, hem hayat kurtarın hem de kazanç sağlayın!

**English Translation:**

> **Report an Accident, Get Rewarded!**
> You can report traffic accidents you see through this bot and earn rewards.
> 
> 🚗 Take a photo at the scene of the accident and send it along with the location information.
> ✅ After the information is verified, 1000 TL will be deposited into your account within 24 hours.
> 📞 If the information is correct, our support team will contact you.
> 
> Don't forget, you can both save lives and earn rewards!

---

### **2. Implementation Plan**

Here is a step-by-step plan to implement all the requested changes in your codebase.

#### **Part A: Add the Welcome Image and Message**

1.  **Get the Image File ID:** To send the image without re-uploading it every time, you need its `file_id`.
    *   Send the image to your bot yourself.
    *   In the bot's console logs, you will see the incoming message data. Find the `file_id` for the photo you sent. It will be a long string of characters.
    *   Copy this `file_id`.

2.  **Update the `start` function in `handlers.py`:** Modify the `start` function to send the photo and the new welcome text.

    ```python
    # handlers.py

    async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """Starts the conversation, shows a welcome message, and asks for the accident location."""
        user = update.message.from_user
        logger.info("User %s started the conversation.", user.first_name)
        
        # --- NEW: Send welcome message and image ---
        # Replace 'YOUR_FILE_ID_HERE' with the actual file_id you obtained
        photo_file_id = 'YOUR_FILE_ID_HERE' 
        welcome_caption = (
            "Welcome to KazaBot!\n\n"
            "Report an Accident, Get Rewarded!\n"
            "You can report traffic accidents you see through this bot and earn rewards.\n\n"
            "🚗 Take a photo at the scene of the accident and send it along with the location information.\n"
            "✅ After the information is verified, you will receive a reward.\n"
            "📞 If the information is correct, our support team will contact you.\n\n"
            "Don't forget, you can both save lives and earn rewards!"
        )
        await context.bot.send_photo(
            chat_id=update.effective_chat.id,
            photo=photo_file_id,
            caption=welcome_caption
        )
        # --- End of new section ---
        
        # Onboard the user if they are new and set initial balance
        get_or_create_user(user.id, user.username)

        location_keyboard = KeyboardButton(text="Share Accident Location", request_location=True)
        custom_keyboard = [[location_keyboard]]
        reply_markup = ReplyKeyboardMarkup(custom_keyboard, resize_keyboard=True, one_time_keyboard=True)

        await update.message.reply_text(
            "Please press the button below to share the accident's location.",
            reply_markup=reply_markup,
        )
        return LOCATION
    ```

#### **Part B: Implement User Balance**

1.  **Update `database.py`:** Modify the user creation function to include the balance and add a function to update it.

    ```python
    # database.py

    def get_or_create_user(user_id, username):
        """
        Retrieves a user profile or creates a new one with an initial balance.
        """
        User = Query()
        user = users_table.get(User.telegram_user_id == user_id)

        if not user:
            user_profile = {
                'telegram_user_id': user_id,
                'username': username,
                'created_at': datetime.utcnow().isoformat(),
                'courier_company': None,
                'payment_method': None,
                'report_count': 0,
                'balance': 99  # NEW: Add initial balance of 99 Lira
            }
            users_table.insert(user_profile)
            return user_profile
        return user

    def update_user_balance(user_id, amount_to_add):
        """
        Increments a user's balance by a specified amount.
        """
        User = Query()
        user = users_table.get(User.telegram_user_id == user_id)
        if user:
            # Handle cases where older users might not have a balance field
            current_balance = user.get('balance', 0) 
            new_balance = current_balance + amount_to_add
            users_table.update({'balance': new_balance}, User.telegram_user_id == user_id)
            logger.info(f"Updated balance for user {user_id}. New balance: {new_balance}")
            return new_balance
        return None
    ```    *Note: You will also need to import `logger` in `database.py` if it's not already there: `import logging` and `logger = logging.getLogger(__name__)`.*

2.  **Update `handlers.py`:** Modify the `review_handler` to award Lira for approved reports.

    ```python
    # handlers.py

    # IMPORTANT: Add the new database function to the imports
    from database import ( 
        save_report, 
        get_or_create_user, 
        update_user_profile,
        get_report_by_id, 
        update_report_status,
        update_user_balance # <-- ADD THIS
    )

    async def review_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        # ... (keep the existing code until the user notification part)

        # Update status and notify the user
        new_status = "verified" if action == "approve" else "rejected"
        update_report_status(report_id, new_status, admin_user.id)
        
        # Update the admin's message to show the result
        final_text = query.message.text + f"\n\n--- Decision ---\nStatus set to *{new_status.upper()}* by @{admin_user.username}."
        await query.edit_message_text(text=final_text, parse_mode='Markdown')

        # Notify the original user
        original_user_id = report['telegram_user_id']
        user_notification = f"UPDATE: Your report (ID: {report_id}) has been *{new_status}*."
        
        if new_status == 'verified':
            # --- NEW: Update balance and notify user ---
            reward_amount = 150 # Define your reward amount here
            new_balance = update_user_balance(original_user_id, reward_amount)
            user_notification += (
                f"\n\nCongratulations! {reward_amount} Lira has been added to your account. "
                f"Your new balance is {new_balance} Lira."
            )
            # --- End of new section ---
        
        try:
            await context.bot.send_message(
                chat_id=original_user_id,
                text=user_notification,
                parse_mode='Markdown'
            )
        except Exception as e:
            logger.error(f"Failed to send status update to user {original_user_id}: {e}")
    ```

#### **Part C: Temporarily Disable "Company Name" Question**

1.  **Update `handlers.py`:** Comment out the logic that asks for the company name.

    ```python
    # handlers.py

    async def submit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """Submits the report, saves it, and ends the conversation."""
        user = update.message.from_user
        report_data = context.user_data.get('report')
        
        if not report_data:
            await update.message.reply_text("Something went wrong. Please start over with /start.")
            return ConversationHandler.END

        # Save the report
        report_id = save_report(user.id, report_data)
        logger.info("User %s submitted report %s", user.first_name, report_id)

        # Update user's report count
        user_profile = get_or_create_user(user.id, user.username)
        new_count = user_profile.get('report_count', 0) + 1
        update_user_profile(user.id, {'report_count': new_count})
        
        # Notify admins
        await notify_admins(context, user, report_id, report_data)
        
        # --- MODIFICATION: Temporarily disable company name question ---
        # if user_profile.get('courier_company') is None:
        #     await update.message.reply_text(
        #         "✅ Success! Your report has been submitted.\n\n"
        #         "To help us, could you tell us which courier company you work for? (e.g., 'Getir', 'Trendyol Go'). This is optional.",
        #          reply_markup=ReplyKeyboardRemove(),
        #     )
        #     return COMPANY_NAME
        # else:
        #     # If company name is known, end the conversation
        #     return await finish(update, context)
        return await finish(update, context) # Always go to the finish state
        # --- End of modification ---

    # --- MODIFICATION: Comment out the unused handler ---
    # async def company_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    #     """Saves the user's courier company and ends the conversation."""
    #     user_id = update.message.from_user.id
    #     company = update.message.text
        
    #     update_user_profile(user_id, {'courier_company': company})
    #     logger.info("User %s set their company to %s", update.message.from_user.first_name, company)
        
    #     await update.message.reply_text("Thank you! Your profile has been updated.")
        
    #     return await finish(update, context)
    # --- End of modification ---
    ```

2.  **Update `bot.py`:** Comment out the unused state in the `ConversationHandler`.

    ```python
    # bot.py

    # ... (other imports)
    from handlers import (
        # ... (other handlers)
        # company_name, # Comment out
        cancel,
        review_handler,
        LOCATION,
        PHOTO,
        DESCRIPTION,
        CRASH_TIME_DELTA,
        CONFIRMATION,
        # COMPANY_NAME, # Comment out
    )

    # ...

    def main() -> None:
        # ...

        conv_handler = ConversationHandler(
            # ...
            states={
                LOCATION: [MessageHandler(filters.LOCATION, location)],
                PHOTO: [MessageHandler(filters.PHOTO, photo)],
                DESCRIPTION: [
                    MessageHandler(filters.Regex(r"(?i)^skip$"), description_skip),
                    MessageHandler(filters.TEXT & ~filters.COMMAND, description),
                ],
                CRASH_TIME_DELTA: [MessageHandler(filters.TEXT & ~filters.COMMAND, crash_time_delta)],
                CONFIRMATION: [
                    MessageHandler(filters.Regex(r"(?i)^Submit Report$"), submit),
                    MessageHandler(filters.Regex(r"(?i)^Cancel$"), cancel),
                ],
                # COMPANY_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, company_name)], # Comment out this line
            },
            fallbacks=[CommandHandler("cancel", cancel)],
            per_message=False 
        )
        # ...
    ```

---

### **3. Database Storage on Railway.app for an MVP**

For an MVP hosted on Railway, you have two excellent choices for handling your `kazabot_db.json` file. Here’s a comparison to help you decide:

#### **Option 1: Railway Persistent Volume (Recommended for MVP)**

Railway allows you to mount a persistent disk, called a "volume," to your service. This volume acts like a small, attached hard drive that doesn't get erased when you deploy new code or restart your service.

*   **How it Works:** You would configure a volume in your Railway project settings and mount it at a specific path (e.g., `/data`). You would then modify your `DATABASE_PATH` in `config.py` to point to this location (e.g., `DATABASE_PATH = '/data/kazabot_db.json'`).
*   **Pros:**
    *   **Simplicity:** It's the easiest and quickest setup. You stay entirely within the Railway ecosystem.
    *   **Low Latency:** The database file is stored on the same infrastructure as your bot, ensuring fast access.
    *   **Cost-Effective:** Using a small volume is generally included in Railway's free/hobby tier or is very inexpensive.
*   **Cons:**
    *   **Manual Backups:** You are responsible for backing up the JSON file yourself.
    *   **Scalability Limitations:** If your bot becomes extremely popular with high write volumes, a simple JSON file can become a bottleneck.

#### **Option 2: External Database Service (e.g., Supabase)**

Supabase is a "backend-as-a-service" platform that provides a full-featured PostgreSQL database, authentication, and more.

*   **How it Works:** You would create a project on Supabase, get your database connection credentials, and add them to your bot's environment variables on Railway. Your bot would then connect to Supabase over the internet. This would require replacing `TinyDB` with a PostgreSQL client library like `psycopg2-binary`.
*   **Pros:**
    *   **Highly Scalable:** A real SQL database can handle much more data and concurrent users.
    *   **Managed Service:** Supabase handles backups, security, and maintenance for you.
    *   **Powerful Features:** You get a data browser, user management, and API endpoints out of the box.
*   **Cons:**
    *   **Increased Complexity:** You would need to rewrite your entire `database.py` file to work with PostgreSQL instead of TinyDB. This is a significant code change.
    *   **Potential for Higher Latency:** The database connection happens over the network, which can be slightly slower than a local file.
    *   **Learning Curve:** Requires understanding SQL and managing a new service.

**Recommendation for Your MVP:**

**Stick with Railway's persistent volume and TinyDB.**

For an MVP, the primary goal is to test your idea quickly and with minimal complexity. The combination of TinyDB and a Railway volume is perfectly suited for this. It is robust enough to handle the initial user load, and the setup is incredibly straightforward. You can focus on building bot features rather than managing database infrastructure.

If your bot proves successful and you need to scale, migrating to a service like Supabase is a great next step, but it is unnecessary at this early stage.
</file>

<file path="tasks/markdown parsing issue.md">
# Current Task: user report fail bc of markdown render
Date: 31.07.2025

## What I Want to Fix:
When a user Saba tried to create a report, only a photo was being sent. Railway logs had this message:
2025-07-30 20:41:50,837 - handlers - INFO - User Saba Allahverdi submitted report 1793bd71-5dbb-48ce-9e73-c58973d76d6a

2025-07-30 20:41:50,897 - httpx - INFO - HTTP Request: POST https://api.telegram.org/bot7091434973:AAEdbbggzf8WQhYbZZIp4NLREfe6ajaq4OM/sendPhoto "HTTP/1.1 200 OK"

2025-07-30 20:41:50,901 - httpx - INFO - HTTP Request: POST https://api.telegram.org/bot7091434973:AAEdbbggzf8WQhYbZZIp4NLREfe6ajaq4OM/sendMessage "HTTP/1.1 400 Bad Request"

## Current Problem:
I don't know how to proceed with fixing it.

## Desired Outcome:
Saba should be able to create a crash report in the Telegram bot, and the admin should receive the full information from Saba.

## Gemini 2.5 Pro Plan:
Of course. It's frustrating when a bug like this appears. The "400 Bad Request" error is a classic sign of a specific problem, and we can fix it quickly.

Here’s a simple plan to get your bot working correctly.

### **The Problem Explained Simply**

The error `400 Bad Request` from Telegram's `sendMessage` API almost always means one thing: the text you're trying to send has formatting characters that Telegram doesn't understand.

In your `handlers.py` file, you are sending the admin notification using `parse_mode='Markdown'`. This tells Telegram to look for special characters like \` \_ \* \[ \] and treat them as formatting. Your code correctly uses backticks (\`) to format the `report_id` and `user.id`.

However, you also include the user's `username` and the report `description` directly in the message. If a user's name is `saba_a` or they write a description like "two cars, one is a mini-cooper.", the underscores (`_`) or dashes (`-`) will break Telegram's Markdown parser, causing the entire message to be rejected.

### **A Step-by-Step Plan to Fix This**

We will make a small change to the `notify_admins` function in `handlers.py`. The safest and quickest fix is to simply send the admin notification as plain text. The formatting is less important than the admin actually receiving the information.

**Step 1: Locate the Problematic Code**

1.  Open your project and find the file `handlers.py`.
2.  Inside that file, scroll down to the `notify_admins` function.
3.  Find the `await context.bot.send_message(...)` call inside the `for` loop. It looks like this:

    ```python
    # Inside notify_admins function in handlers.py

    await context.bot.send_message(
        chat_id=admin_id,
        text=admin_message,
        reply_markup=reply_markup,
        parse_mode='Markdown'  # <-- THIS IS THE PROBLEM
    )
    ```

**Step 2: Apply the Fix**

All you need to do is remove the `parse_mode` argument. The message will be sent as plain text, which will prevent any formatting errors.

1.  Change the code to look like this:

    ```python
    # Inside notify_admins function in handlers.py

    await context.bot.send_message(
        chat_id=admin_id,
        text=admin_message,
        reply_markup=reply_markup
    )
    ```
2.  Save the `handlers.py` file.
3.  Deploy the updated code to your server (e.g., Railway.app).

That's it. The bug should now be fixed.

### **What Could Go Wrong**

1.  **Admin message loses formatting**: The admin notification will now be plain text. The Report ID and User ID will no longer have the nice grey code block formatting. This is a minor trade-off for making the feature reliable.
2.  **The error persists**: This is very unlikely. If it does, it means a character in the `admin_message` text is somehow invalid for reasons other than Markdown. If this happens, the next step would be to log the `admin_message` text right before it's sent to see exactly what content is causing the failure.

### **How to Test It**

Follow these steps to ensure the fix is working as expected:

1.  **Restart the conversation**: Open your Telegram bot and type `/cancel` to clear any old session, then `/start` to begin a new report.
2.  **Submit a test report**:
    *   Send the location when prompted.
    *   Send a photo.
    *   When asked for a description, **use text with special characters**. For example, type: `A red car and a blue_car.`
3.  **Confirm submission**: Complete the final steps and submit the report.
4.  **Check the admin account**: Open the Telegram account of one of your admins.
    *   **Expected Outcome:** You should see the photo **and** the text notification arrive successfully. The text will be plain, without any bolding or code blocks, but all the information will be there.
5.  **Check your logs**: Look at your Railway.app logs. You should no longer see the `400 Bad Request` error. You should see two "200 OK" responses, one for `sendPhoto` and one for `sendMessage`.

By following this plan, you should be able to resolve the issue in less than 30 minutes.
## Implementation prompt
## What Worked:
Of course. Dealing with bugs like this can be tricky, but the plan is straightforward. Let's get your bot fixed.

### Step 1: Making the Admin Notification Robust

First, I'll address the core issue. To prevent special characters in usernames or report descriptions from crashing the bot, I will modify the `notify_admins` function. I am removing the Markdown formatting from the notification message, which includes taking out the backticks (`) around the `report_id` and `user.id` and removing the `parse_mode` argument from the `send_message` call.

This ensures the notification is sent as plain text, making it reliable.
Ran tool

Excellent. The fix has been applied to `handlers.py`. The `notify_admins` function will now send plain text messages, which resolves the `400 Bad Request` error.

Now that the main issue is resolved, I recommend we also address a related problem. The `review_handler` function, which processes admin decisions, still uses Markdown to update the admin's message. If a username contains special characters, this could cause a similar crash when an admin approves or rejects a report.

To prevent this, I will remove the Markdown formatting from the `review_handler` as well.
Ran tool

Great, that's another potential issue averted.

To complete the process and ensure the bot is fully robust against this type of error, I will make one final change. The notification sent to the original user after an admin reviews their report also uses Markdown. I'll update that to be plain text as well for consistency and to prevent any future issues.
Ran tool
That's the final change. We have now removed all instances of `parse_mode='Markdown'` that could cause issues with user-generated content. Your bot should now be much more robust.

The bug is fixed. Before you deploy, I recommend you follow the test plan outlined in `current-task.md` to be certain everything is working as expected. Let me know if you have any other questions.

## What Didn't Work:
- 

## For Next Time:
-
</file>

<file path=".gitignore">
cat > .gitignore << 'EOF'
.env
venv/
__pycache__/
*.pyc
db.json
.DS_Store
EOF
</file>

<file path="bot.py">
# bot.py

import logging
from telegram.ext import (
    Application,
    ConversationHandler,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)
from config import TELEGRAM_BOT_TOKEN
from handlers import (
    start,
    location,
    photo,
    description,
    description_skip,
    crash_time_delta,
    submit,
        # company_name, # Comment out
    cancel,
    review_handler,
    LOCATION,
    PHOTO,
    DESCRIPTION,
    CRASH_TIME_DELTA,
    CONFIRMATION,
        # COMPANY_NAME, # Comment out
)

# Enable logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)


def main() -> None:
    """Run the bot."""
    # Create the Application and pass it your bot's token.
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()

    # Add conversation handler with the states
    conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler("start", start),
            # NEW: Add an entry point for our button
            MessageHandler(filters.Regex(r"^➕ New Report$"), start),
        ],
        states={
            LOCATION: [MessageHandler(filters.LOCATION, location)],
            PHOTO: [MessageHandler(filters.PHOTO, photo)],
            DESCRIPTION: [
                MessageHandler(filters.Regex(r"(?i)^skip$"), description_skip),
                MessageHandler(filters.TEXT & ~filters.COMMAND, description),
            ],
            CRASH_TIME_DELTA: [MessageHandler(filters.TEXT & ~filters.COMMAND, crash_time_delta)],
            CONFIRMATION: [
                MessageHandler(filters.Regex(r"(?i)^Submit Report$"), submit),
                MessageHandler(filters.Regex(r"(?i)^Cancel$"), cancel),
            ],
            # COMPANY_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, company_name)], # Comment out this line
        },
        fallbacks=[CommandHandler("cancel", cancel)],
        per_message=False # Ensures conversation context is consistent
    )

    application.add_handler(conv_handler)
    application.add_handler(CallbackQueryHandler(review_handler))

    # Run the bot until the user presses Ctrl-C
    logger.info("Starting bot...")
    application.run_polling()
    logger.info("Bot stopped.")


if __name__ == "__main__":
    main()
</file>

<file path="config.py">
# config.py - Configuration management
import os
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Bot configuration - Changed from TELEGRAM_TOKEN to TELEGRAM_BOT_TOKEN
TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
if not TELEGRAM_BOT_TOKEN:
    raise ValueError("No TELEGRAM_BOT_TOKEN found in environment variables")

# Database configuration
DATABASE_PATH = 'db.json'

# Validation constraints
MAX_DESCRIPTION_LENGTH = 200
MIN_CRASH_TIME = 0  # minutes
MAX_CRASH_TIME = 60  # minutes
MAX_REPORTS_PER_DAY = 3

# Conversation states
LOCATION, PHOTO, DESCRIPTION, CRASH_TIME_DELTA, CONFIRMATION = range(5)

# --- Load Admin User IDs from .env file ---
admin_ids_str = os.getenv('ADMIN_IDS', '') # Get the comma-separated string

# Process the string into a list of integers
if admin_ids_str:
    try:
        # Split the string by commas and convert each part to an integer
        ADMIN_IDS = [int(admin_id.strip()) for admin_id in admin_ids_str.split(',')]
    except ValueError:
        print("Error: ADMIN_IDS in .env file contains non-numeric values. Please check it.")
        ADMIN_IDS = [] # Default to an empty list on error
else:
    # If the variable is not set, default to an empty list
    ADMIN_IDS = []

# It's good practice to log or print the loaded admins on startup to verify
if not ADMIN_IDS:
    print("Warning: No ADMIN_IDS found in .env file. Admin features will be disabled.")
else:
    print(f"Admin users loaded successfully: {ADMIN_IDS}")
</file>

<file path="database.py">
# database.py
import uuid
import logging
from datetime import datetime, timedelta
from tinydb import TinyDB, Query

# Enable logging
logger = logging.getLogger(__name__)

# Initialize the database
db = TinyDB('kazabot_db.json', indent=4)
reports_table = db.table('reports')
users_table = db.table('users')

def save_report(user_id, report_data):
    """
    Saves a new accident report to the database.
    """
    report_id = str(uuid.uuid4())
    submitted_at = datetime.utcnow().isoformat()

    report = {
        'report_id': report_id,
        'telegram_user_id': user_id,
        'location_geo': report_data.get('location'),
        'location_time': report_data.get('location_timestamp'),
        'photo_file_id': report_data.get('photo'),
        'photo_time': report_data.get('photo_timestamp'),
        'description': report_data.get('description'),
        'crash_time_delta': report_data.get('crash_time_delta'),
        'submitted_at': submitted_at,
        'status': 'pending', # pending/verified/duplicate/rewarded
        'reward_sent': False
    }
    reports_table.insert(report)
    return report_id

def get_or_create_user(user_id, username):
    """
    Retrieves a user profile or creates a new one with an initial balance.
    """
    User = Query()
    user = users_table.get(User.telegram_user_id == user_id)

    if not user:
        user_profile = {
            'telegram_user_id': user_id,
            'username': username,
            'created_at': datetime.utcnow().isoformat(),
            'courier_company': None,
            'payment_method': None,
            'report_count': 0,
            'balance': 99  # NEW: Add initial balance of 99 Lira
        }
        users_table.insert(user_profile)
        return user_profile
    return user

def update_user_balance(user_id, amount_to_add):
    """
    Increments a user's balance by a specified amount.
    """
    User = Query()
    user = users_table.get(User.telegram_user_id == user_id)
    if user:
        # Handle cases where older users might not have a balance field
        current_balance = user.get('balance', 0) 
        new_balance = current_balance + amount_to_add
        users_table.update({'balance': new_balance}, User.telegram_user_id == user_id)
        logger.info(f"Updated balance for user {user_id}. New balance: {new_balance}")
        return new_balance
    return None

def update_user_profile(user_id, data_to_update):
    """
    Updates a user's profile with new information (e.g., company, report count).
    """
    User = Query()
    users_table.update(data_to_update, User.telegram_user_id == user_id)

def get_user_report_count_today(user_id):
    """
    Counts how many reports a user has submitted in the last 24 hours.
    """
    Report = Query()
    twenty_four_hours_ago = (datetime.utcnow() - timedelta(days=1)).isoformat()
    
    user_reports = reports_table.search(
        (Report.telegram_user_id == user_id) & 
        (Report.submitted_at >= twenty_four_hours_ago)
    )
    return len(user_reports)
    # database.py (add these functions)

def get_report_by_id(report_id):
    """Retrieves a single report by its unique ID."""
    Report = Query()
    report = reports_table.get(Report.report_id == report_id)
    return report

def update_report_status(report_id, new_status, admin_id):
    """Updates the status of a report and logs which admin did it."""
    Report = Query()
    reports_table.update(
        {'status': new_status, 'reviewed_by': admin_id}, 
        Report.report_id == report_id
    )
</file>

<file path="handlers.py">
# handlers.py
import logging
from datetime import datetime
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)
from database import save_report, get_or_create_user, update_user_profile, get_user_report_count_today
from config import ADMIN_IDS 
from database import ( 
    save_report, 
    get_or_create_user, 
    update_user_profile,
    get_report_by_id, 
    update_report_status,
    update_user_balance # <-- ADD THIS
)

# Enable logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# Define states for the conversation
(
    LOCATION,
    PHOTO,
    DESCRIPTION,
    CRASH_TIME_DELTA,
    CONFIRMATION,
    COMPANY_NAME,
) = range(6)
# --- NEW: Reusable keyboard for starting a new report ---
NEW_REPORT_KEYBOARD = ReplyKeyboardMarkup([["➕ New Report"]], resize_keyboard=True, one_time_keyboard=False)

# --- Start & Cancel ---

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Starts the conversation, shows a welcome message, and asks for the accident location."""
    user = update.message.from_user
    logger.info("User %s started the conversation.", user.first_name)
    
    # --- NEW: Send welcome message and image ---
    # Replace 'YOUR_FILE_ID_HERE' with the actual file_id you obtained
    photo_file_id = 'AgACAgQAAxkBAAPCaIu8_FQu7pFVNR7X8AAB5O_shWW2AALfxzEbZKFhUOKlznwiwuHuAQADAgADeAADNgQ' 
    welcome_caption = (
        "Welcome to Kazabot! We've added a starting balance of 99 ₺ to your account for joining us. "
        "For every accident report you submit that is verified by our team, you will earn a 100 ₺ reward. "
        "You can withdraw your earnings once your total balance reaches 500 ₺.\n\n"
        "Let's get started! Please share the accident's location by pressing the button below."
    )
    get_or_create_user(user.id, user.username)

    location_keyboard = KeyboardButton(text="Share Accident Location", request_location=True)
    custom_keyboard = [[location_keyboard]]
    reply_markup = ReplyKeyboardMarkup(custom_keyboard, resize_keyboard=True, one_time_keyboard=True)

    await context.bot.send_photo(
        chat_id=update.effective_chat.id,
        photo=photo_file_id,
        caption=welcome_caption,
        reply_markup=reply_markup,
        read_timeout=20,
        write_timeout=20
    )
    # --- End of new section ---
    
    # Onboard the user if they are new and set initial balance
    

    return LOCATION

# --- Reporting Flow ---

async def location(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the location and asks for a photo."""
    user_location = update.message.location
    context.user_data['report'] = {
        'location': (user_location.latitude, user_location.longitude),
        'location_timestamp': datetime.utcnow().isoformat()
    }
    logger.info("Location from %s: %s", update.message.from_user.first_name, user_location)
    
    await update.message.reply_text(
        "Great! Now, please take a clear photo of the accident and send it to me.",
        reply_markup=ReplyKeyboardRemove(),
    )
    return PHOTO

async def photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the photo and asks for a description."""
    user_photo = update.message.photo[-1] # Get the highest resolution photo
    context.user_data['report']['photo'] = user_photo.file_id
    context.user_data['report']['photo_timestamp'] = datetime.utcnow().isoformat()
    
    logger.info("Photo received from %s", update.message.from_user.first_name)
    
    reply_keyboard = [["Skip"]]
    await update.message.reply_text(
        "Photo received. Now, please add a short description (e.g., 'two cars, rear-end'). "
        "This is optional. You can also type 'Skip'.",
        reply_markup=ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True, one_time_keyboard=True),
    )
    return DESCRIPTION

async def description(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the description and asks for the time delta."""
    user_description = update.message.text
    if user_description.lower() != 'skip':
        if len(user_description) > 200:
            await update.message.reply_text("The description is too long (max 200 characters). Please try again.")
            return DESCRIPTION
        context.user_data['report']['description'] = user_description
    else:
        context.user_data['report']['description'] = None
        
    logger.info("Description from %s: %s", update.message.from_user.first_name, user_description)
    await update.message.reply_text(
        "Got it. Roughly how many minutes ago did the crash happen? (Please enter a number from 0 to 60)",
        reply_markup=ReplyKeyboardRemove(),
    )
    return CRASH_TIME_DELTA

async def description_skip(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Skips the description and asks for the time delta."""
    context.user_data['report']['description'] = None
    logger.info("User %s skipped the description.", update.message.from_user.first_name)
    await update.message.reply_text(
        "Description skipped. Roughly how many minutes ago did the crash happen? (Please enter a number from 0 to 60)",
        reply_markup=ReplyKeyboardRemove(),
    )
    return CRASH_TIME_DELTA


async def crash_time_delta(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the time delta and asks for final confirmation."""
    text = update.message.text
    try:
        delta = int(text)
        if not (0 <= delta <= 60):
            raise ValueError
        context.user_data['report']['crash_time_delta'] = delta
    except (ValueError, TypeError):
        await update.message.reply_text("That's not a valid number. Please enter a number between 0 and 60.")
        return CRASH_TIME_DELTA

    # Show summary
    report = context.user_data['report']
    summary = (
        f"--- REVIEW YOUR REPORT ---\n"
        f"📍 Location: Sent\n"
        f"📸 Photo: Sent\n"
        f"📝 Description: {report.get('description', 'N/A')}\n"
        f"⏱️ Time Since Crash: ~{report.get('crash_time_delta')} minutes ago\n\n"
        "Is everything correct?"
    )
    reply_keyboard = [["Submit Report", "Cancel"]]
    await update.message.reply_text(
        summary,
        reply_markup=ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True, one_time_keyboard=True),
    )
    return CONFIRMATION

async def submit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Submits the report, saves it, and transitions to the final steps."""
    user = update.message.from_user
    report_data = context.user_data.get('report')
    
    if not report_data:
        await update.message.reply_text("Something went wrong. Please start over with /start.")
        return ConversationHandler.END

    # Save the report
    report_id = save_report(user.id, report_data)
    logger.info("User %s submitted report %s", user.first_name, report_id)

    # Update user's report count
    user_profile = get_or_create_user(user.id, user.username)
    new_count = user_profile.get('report_count', 0) + 1
    update_user_profile(user.id, {'report_count': new_count})
    
    # Notify admins
    await notify_admins(context, user, report_id, report_data)
    
    # --- MODIFICATION: Temporarily disable company name question ---
    # if user_profile.get('courier_company') is None:
    #     await update.message.reply_text(
    #         "✅ Success! Your report has been submitted.\n\n"
    #         "To help us, could you tell us which courier company you work for? (e.g., 'Getir', 'Trendyol Go'). This is optional.",
    #          reply_markup=ReplyKeyboardRemove(),
    #     )
    #     return COMPANY_NAME
    # else:
    #     # If company name is known, end the conversation
    #     return await finish(update, context)
    await update.message.reply_text("✅ Success! Your report has been submitted.\n\n")
    return await finish(update, context) # Always go to the finish state
    # --- End of modification ---


# --- MODIFICATION: Comment out the unused handler ---
# async def company_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
#     """Saves the user's courier company and ends the conversation."""
#     user_id = update.message.from_user.id
#     company = update.message.text
    
#     update_user_profile(user_id, {'courier_company': company})
#     logger.info("User %s set their company to %s", update.message.from_user.first_name, company)
    
#     await update.message.reply_text("Thank you! Your profile has been updated.")
    
#     return await finish(update, context)
# --- End of modification ---


async def finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Clears user data and shows the final message with the 'New Report' button."""
    context.user_data.clear()
    await update.message.reply_text(
        "You can now submit a new report or close this chat.",
        reply_markup=NEW_REPORT_KEYBOARD,
    )
    return ConversationHandler.END


async def notify_admins(context: ContextTypes.DEFAULT_TYPE, user, report_id, report_data):
    """Sends a notification to all admins about a new report."""
    admin_message = (
        f"🚨 New Accident Report Submitted 🚨\n\n"
        f"Report ID: {report_id}\n"
        f"Submitted By: @{user.username} (ID: {user.id})\n"
        f"Description: {report_data.get('description', 'N/A')}\n"
        f"Time Delta: ~{report_data.get('crash_time_delta')} minutes ago"
    )
    
    keyboard = [
        [
            InlineKeyboardButton("✅ Approve", callback_data=f"approve_{report_id}"),
            InlineKeyboardButton("❌ Reject", callback_data=f"reject_{report_id}"),
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    for admin_id in ADMIN_IDS:
        try:
            await context.bot.send_photo(chat_id=admin_id, photo=report_data['photo'])
            await context.bot.send_message(
                chat_id=admin_id,
                text=admin_message,
                reply_markup=reply_markup
            )
            logger.info(f"Sent notification for report {report_id} to admin {admin_id}")
        except Exception as e:
            logger.error(f"Failed to send notification to admin {admin_id}: {e}")


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancels the conversation and shows the 'New Report' button."""
    user = update.message.from_user
    logger.info("User %s canceled the conversation.", user.first_name)
    context.user_data.clear()
    await update.message.reply_text(
        "Report canceled. You can start a new one anytime.",
        reply_markup=NEW_REPORT_KEYBOARD, # Use our new keyboard
    )
    return ConversationHandler.END


async def review_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handles admin decisions from inline keyboard buttons."""
    query = update.callback_query
    await query.answer() # Acknowledge the button press

    admin_user = query.from_user
    action, report_id = query.data.split("_")

    if admin_user.id not in ADMIN_IDS:
        await query.edit_message_text(text="Sorry, you are not authorized to perform this action.")
        return

    report = get_report_by_id(report_id)
    if not report:
        await query.edit_message_text(text=f"Error: Report {report_id} not found.")
        return
    
    if report['status'] != 'pending':
        await query.edit_message_text(text=f"This report has already been reviewed. Status: {report['status']}.")
        return

    # Update status and notify the user
    new_status = "verified" if action == "approve" else "rejected"
    update_report_status(report_id, new_status, admin_user.id)
    
    # Update the admin's message to show the result
    final_text = query.message.text + f"\n\n--- Decision ---\nStatus set to {new_status.upper()} by @{admin_user.username}."
    await query.edit_message_text(text=final_text)

    # Notify the original user
    original_user_id = report['telegram_user_id']
    user_notification = f"UPDATE: Your report (ID: {report['report_id']}) has been {new_status}."
    
    if new_status == 'verified':
        # --- NEW: Update balance and notify user ---
        reward_amount = 100 # Define your reward amount here
        new_balance = update_user_balance(original_user_id, reward_amount)
        user_notification += (
            f"\n\nCongratulations! {reward_amount} TL has been added to your account. "
            f"Your new balance is {new_balance} TL."
        )
        # --- End of new section ---
    
    try:
        await context.bot.send_message(
            chat_id=original_user_id,
            text=user_notification
        )
    except Exception as e:
        logger.error(f"Failed to send status update to user {original_user_id}: {e}")
</file>

<file path="kazabot_db.json">
{
    "users": {
        "1": {
            "telegram_user_id": 4462330,
            "username": "mrvooooo",
            "created_at": "2025-07-30T18:05:09.870369",
            "courier_company": "Getir",
            "payment_method": null,
            "report_count": 1
        },
        "2": {
            "telegram_user_id": 7127606451,
            "username": "rewd0glamd",
            "created_at": "2025-07-30T19:24:09.028355",
            "courier_company": "Getir",
            "payment_method": null,
            "report_count": 10,
            "balance": 200
        }
    },
    "reports": {
        "1": {
            "report_id": "2d156c1b-68eb-49cb-af1b-00f27707b32d",
            "telegram_user_id": 4462330,
            "location_geo": [
                38.432951,
                27.162072
            ],
            "location_time": "2025-07-30T18:05:31.830144",
            "photo_file_id": "AgACAgIAAxkBAAMFaIpe_EWfcVoX0NSX0mgIQAZB-t0AAqv3MRvjwlFIKRrfjwEHeEIBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T18:05:48.250580",
            "description": "masterful coding",
            "crash_time_delta": 0,
            "submitted_at": "2025-07-30T18:06:15.584885",
            "status": "pending",
            "reward_sent": false
        },
        "2": {
            "report_id": "25405c14-5629-40cf-a3ac-69dd234f499b",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:24:25.945855",
            "photo_file_id": "AgACAgQAAxkBAAMUaIpxf_Nkuum2freWHeVOEQbhdagAAs_LMRtkoVlQR0RDdOuUEjYBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:24:47.503329",
            "description": null,
            "crash_time_delta": 5,
            "submitted_at": "2025-07-30T19:25:02.912718",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "3": {
            "report_id": "e436d6c3-679f-4e35-a3e6-b9a07f362818",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:41:32.081860",
            "photo_file_id": "AgACAgQAAxkBAAMmaIp1eebMWgl_HAN88HD6dyowyPQAAtXLMRtkoVlQZxNh-hoxm-gBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:41:45.601875",
            "description": "Test3: button add",
            "crash_time_delta": 0,
            "submitted_at": "2025-07-30T19:42:04.169922",
            "status": "rejected",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "4": {
            "report_id": "1fa7e2e7-1ae0-4c94-9fa6-7c6c4eb100fc",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:42:27.204362",
            "photo_file_id": "AgACAgQAAxkBAAM0aIp1vnXSYeWzKOGGtQdTR0cerAgAAtfLMRtkoVlQVAPjHxaAMeYBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:42:54.313088",
            "description": null,
            "crash_time_delta": 9,
            "submitted_at": "2025-07-30T19:43:15.203505",
            "status": "rejected",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "5": {
            "report_id": "7faf682c-b7d4-4ff3-89ae-58531ab819b8",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:51:19.351171",
            "photo_file_id": "AgACAgQAAxkBAAMUaIpxf_Nkuum2freWHeVOEQbhdagAAs_LMRtkoVlQR0RDdOuUEjYBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:51:27.247422",
            "description": "Hello",
            "crash_time_delta": 0,
            "submitted_at": "2025-07-30T19:51:39.011673",
            "status": "pending",
            "reward_sent": false
        },
        "6": {
            "report_id": "a12c1c62-c03b-44cd-bb7d-43b5a968c6a5",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T17:45:49.427828",
            "photo_file_id": "AgACAgQAAxkBAAOjaIur2MrnF_ZZcLHVOgeFv813gcgAAsXHMRtkoWFQ5qMeDqtMKSMBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T17:46:00.486139",
            "description": "Djdhdhdhd \ud83d\udc4c//// !!! #$$",
            "crash_time_delta": 9,
            "submitted_at": "2025-07-31T17:46:22.254973",
            "status": "pending",
            "reward_sent": false
        },
        "7": {
            "report_id": "3dc52cdf-b5c6-4696-a0ec-16b3ab8cf0ee",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T17:48:28.763276",
            "photo_file_id": "AgACAgQAAxkBAAOjaIur2MrnF_ZZcLHVOgeFv813gcgAAsXHMRtkoWFQ5qMeDqtMKSMBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T17:48:35.636265",
            "description": "\ud83d\ude0d\ud83d\ude01\ud83d\ude0d\ud83d\ude01\ud83d\udc8b\ud83d\ude2d\ud83d\ude33\ud83d\ude1d",
            "crash_time_delta": 0,
            "submitted_at": "2025-07-31T17:48:57.947763",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "8": {
            "report_id": "779ed8b2-7b0e-485b-93c7-37c0592f2d03",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T18:59:01.366378",
            "photo_file_id": "AgACAgQAAxkBAAPCaIu8_FQu7pFVNR7X8AAB5O_shWW2AALfxzEbZKFhUOKlznwiwuHuAQADAgADeAADNgQ",
            "photo_time": "2025-07-31T18:59:08.259151",
            "description": null,
            "crash_time_delta": 0,
            "submitted_at": "2025-07-31T18:59:15.958670",
            "status": "pending",
            "reward_sent": false
        },
        "9": {
            "report_id": "e96c69da-4df8-46e2-b068-4134bf39c919",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T19:04:44.449882",
            "photo_file_id": "AgACAgQAAxkBAAPSaIu-X_N96rb9pqgfNtU6bBEOoWYAAufHMRtkoWFQ8E_q13bdgZIBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T19:05:03.164804",
            "description": null,
            "crash_time_delta": 5,
            "submitted_at": "2025-07-31T19:05:12.681631",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "10": {
            "report_id": "8d0be8f4-697b-4f20-9f00-68cfcad7d79c",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T19:16:28.425785",
            "photo_file_id": "AgACAgQAAxkBAAPlaIvBGGXUvtjPw3uxGmg_If7jzZIAAunHMRtkoWFQLh9zKtTjSFoBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T19:16:40.508592",
            "description": null,
            "crash_time_delta": 9,
            "submitted_at": "2025-07-31T19:16:47.984138",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "11": {
            "report_id": "a7ab3df7-f31b-4ee9-aae1-82ddf9d3c0fb",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-31T19:17:30.376216",
            "photo_file_id": "AgACAgQAAxkBAAP2aIvBWBOOx0qV0PiMwmlj3hH5js0AAurHMRtkoWFQ-xoM50j9h94BAAMCAAN5AAM2BA",
            "photo_time": "2025-07-31T19:17:44.301290",
            "description": "Balance check",
            "crash_time_delta": 6,
            "submitted_at": "2025-07-31T19:17:57.308006",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        }
    }
}
</file>

<file path="next-actions.md">
# **Daenah Bot Development Plan**
#### **1. Implement Payout Logic**
*   **Verdict:** **Essential.** The core loop of your bot is "Report -> Get Verified -> Get Paid." Without a way to manage payouts, the balance becomes meaningless.
*   **Criticism/Suggestion:** Instead of just "withdrawing" money, think of it as "recording a payout." The admin performs a payout outside the bot (e.g., a bank transfer) and then uses a command to update the bot's database.
*   **MVP Action:** Create a simple admin-only command: `/odeme <user_id> <amount>`.
    *   This command should first check if the person using it is an admin.
    *   It subtracts the `<amount>` from the user's balance in `database.py`.
    *   It sends a confirmation message to the admin (`"Payout of 150 ₺ for user 12345 has been recorded. New balance: 350 ₺"`).
    *   It sends a notification to the user (`"A payout of 150 ₺ has been processed! Your new balance is 350 ₺."`).

#### **2. Add Stable Database Using Railway.app Volumes**
*   **Verdict:** **CRITICAL.** This is non-negotiable. Without this, your bot will lose all user data on every restart or deploy, making it completely unusable.
*   **Criticism/Suggestion:** Your plan is perfect. Using Railway volumes with TinyDB is the ideal intersection of simplicity and persistence for an MVP.
*   **MVP Action:** Follow these exact steps:
    1.  In your Railway project, go to your service settings and add a **Volume**.
    2.  Set the **Mount Path** to `/data`.
    3.  In your `config.py` file, change the database path to use this volume:
        `DATABASE_PATH = '/data/kazabot_db.json'`
    4.  Deploy your bot. Railway will now ensure that the `kazabot_db.json` file persists across restarts.

#### **3. Handle User Deletion/Restart**
*   **Verdict:** **Already solved!** This is a great thing to worry about, but your current implementation handles it correctly.
*   **Clarification:** You are currently using `user.id` (`update.message.from_user.id`) as the unique identifier. This `user_id` is a permanent integer assigned by Telegram to each user account. It **does not change** if a user deletes the chat, blocks the bot, or even changes their @username. Your system will always recognize them correctly when they return.
*   **MVP Action:** No action needed. Be confident that using `user.id` is the correct and robust method.

#### **4. Decide if We Need to Ask for Their Phone Number**
*   **Verdict:** **No, not for the MVP.**
*   **Reasoning:** Every extra piece of information you ask for increases the chance a user will quit. For an MVP, you need to be ruthless about removing friction. You don't have a clear use for the phone number yet. Payouts will likely be done via IBAN, not a phone number. Support can be handled via Telegram itself.
*   **MVP Action:** Postpone this. Only add it later if a clear, unavoidable business need arises.

#### **5. Implement Contact Support Button**
*   **Verdict:** **Essential.** Users will always have questions or issues. A dead end with no support option is frustrating and leads to users abandoning the bot.
*   **MVP Action:** Create a simple `/destek` command in `handlers.py`.
    *   When a user types `/destek`, the bot should reply with a simple message.
    *   **Option A (Easiest):** `"Herhangi bir sorun veya sorun için destek ekibimize destek@yourcompany.com adresinden e-posta gönderebilirsiniz."` (For any questions or issues, you can email our support team at...).
    *   **Option B (Better):** `"Destek talebinizi bu gruba iletebilirsiniz: [Link to a private Telegram group where admins are members]"` (You can forward your support request to this group: ...).

#### **6. Completely Remove the Code for the Company Name Field**
*   **Verdict:** **Excellent idea.** This is good code hygiene.
*   **Reasoning:** Commented-out "dead code" adds clutter and can confuse future development.
*   **MVP Action:**
    1.  Delete the `company_name` function from `handlers.py`.
    2.  Delete the `COMPANY_NAME` state variable from the top of `handlers.py` and from the `ConversationHandler` in `bot.py`.
    3.  In `database.py`, remove `'courier_company': None,` from the `user_profile` dictionary in the `get_or_create_user` function.

#### **7. Add Instructions for Serviceable Zones**
*   **Verdict:** **Essential.** This manages user expectations perfectly and will save you and your users a lot of frustration from rejected reports.
*   **MVP Action:** Add the zone information in two key places:
    1.  **Bot Description (BotFather):** Edit the `/setdescription` text to include a line like: `"(!) Şu anda sadece **İzmir'in Konak ve Bornova** ilçelerindeki raporları kabul ediyoruz."` ((!) We currently only accept reports from the Konak and Bornova districts of Izmir.).
    2.  **Welcome Message (`/start`):** Add the same sentence to the welcome message in `handlers.py` to reinforce it.

#### **8. Implement Automatic Zone Check**
*   **Verdict:** **Postpone.** This is a "nice-to-have" automation, not an MVP essential.
*   **Reasoning:** For an MVP, the admin can and should do this manually. It takes 5 seconds to look at the location on a map. You should only automate this *after* you've proven that:
    a) The bot is getting enough reports to make manual checking a burden.
    b) Out-of-zone reports are a common problem.
*   **MVP Action:** Do nothing. Let the admins manually check the location and reject reports that are out of bounds.

#### **9. Implement Spam Prevention**
*   **Verdict:** **High Priority.** This is a simple and effective protection.
*   **Reasoning:** You've already done the hard work of writing the code!
*   **MVP Action:** In `handlers.py`, find the `start` function and **uncomment** the code block that checks the daily report limit.

    ```python
    # In handlers.py -> start()
    # UNCOMMENT THIS BLOCK
    report_count = get_user_report_count_today(user.id)
    if report_count >= MAX_REPORTS_PER_DAY:
        await update.message.reply_text(
            f"Günlük rapor limitinize ({MAX_REPORTS_PER_DAY}) ulaştınız. Lütfen yarın tekrar deneyin."
        )
        return ConversationHandler.END
    ```

---

### **Further MVP Suggestions**

Here are a few more simple, high-impact features to consider for your MVP:

*   **Add a `/bakiye` (Balance) Command:** Users will want to check their balance without starting a new report. This is a very simple handler that gets the user's profile and replies with their current balance.
*   **Add a `/kurallar` (Rules) Command:** A simple command that reminds the user of the key rules: reward amount, payout threshold (500 ₺), and serviceable zones.
*   **Improve Admin Notifications:** In `notify_admins` in `handlers.py`, you can easily add a Google Maps link to the location. This makes the admin's job much easier.

    ```python
    # In handlers.py -> notify_admins()
    lat, lon = report_data['location']
    maps_link = f"https://www.google.com/maps/search/?api=1&query={lat},{lon}"
    admin_message = (
        f"🚨 New Accident Report Submitted 🚨\n\n"
        f"📍 Location: [Open on Google Maps]({maps_link})\n" # Add this link
        # ... rest of the message
    )
    ```

### **Prioritized MVP Roadmap**

Based on this analysis, here is your action plan, sorted by priority:

**Tier 1: Do Immediately (Foundation)**
1.  **Stable Database:** Configure Railway Volumes.
2.  **Remove Company Code:** Clean up the codebase.
3.  **Add Serviceable Zones:** Update BotFather and the `/start` message.
4.  **Implement Spam Prevention:** Uncomment the existing code.

**Tier 2: Do Next (Core Functionality)**
5.  **Implement Payout Logic:** Create the `/odeme` admin command.
6.  **Implement Support:** Create the `/destek` command.
7.  **Add Balance Check:** Create the `/bakiye` command.

**Tier 3: Postpone for Later**
8.  ~~Ask for Phone Number~~ (Decided against for now).
9.  **Automatic Zone Check:** Wait until this becomes a proven pain point.
</file>

<file path="Procfile">
worker: python bot.py
</file>

<file path="project-description.md">
### **DaenahBot: A Real-Time Car Accident Reporting Telegram Bot**

This document outlines the technical implementation of DaenahBot, a Telegram bot designed for motor couriers in Turkey to report minor car accidents in real-time. This MVP focuses on rapid data collection and user engagement.

### 1. Core Technologies

*   **Programming Language:** Python
*   **Telegram Bot Framework:** The project uses `python-telegram-bot`, a comprehensive library for building Telegram bots.
*   **Database:** `TinyDB` is employed as a lightweight, file-based database, suitable for the project's current scale.

### 2. Project Structure

The project is organized into several Python files, ensuring a modular and maintainable codebase:

*   `bot.py`: The main application entry point that initializes the bot and its handlers.
*   `handlers.py`: Defines all the conversation and command handlers, managing the user interaction flow.
*   `database.py`: Manages all interactions with the `TinyDB` database, including saving and retrieving user and report data.
*   `config.py`: Stores configuration variables, such as the Telegram bot token and admin user IDs, loaded from an environment file.
*   `requirements.txt`: Lists all Python dependencies for the project.
*   `Procfile`: Specifies the command to be executed by the web server to run the application.
*   `kazabot_db.json`: The TinyDB JSON file that serves as the database.
*   `.gitignore`: Specifies intentionally untracked files to be ignored by Git.

### 3. Detailed Implementation

#### **Step 1: Environment and Configuration**

The project uses a `.env` file to manage environment variables, most notably the `TELEGRAM_BOT_TOKEN`. The `config.py` file loads these variables and defines application-wide constants such as database path, validation constraints, and conversation states. It also loads a list of admin user IDs for administrative features.

#### **Step 2: Database and Data Management**

The `database.py` script initializes a `TinyDB` database stored in `kazabot_db.json`. It provides functions to:

*   Save new accident reports with a unique ID, user information, and timestamps.
*   Create or retrieve user profiles, storing their Telegram ID, username, and report count.
*   Update user profiles, for instance, to add their courier company or increment their report count.
*   Retrieve a specific report by its ID.
*   Update a report's status (e.g., to 'verified' or 'rejected') and record which admin reviewed it.

A notable deviation from the initial plan is the absence of a dedicated `models.py` file with Pydantic models for data validation. Data validation is instead handled within the handler functions.

#### **Step 3: Bot Logic and User Flow**

The core of the bot's functionality is built around a `ConversationHandler` from the `python-telegram-bot` library. This manages the stateful, step-by-step process of submitting an accident report.

The implemented conversation states are:

*   **LOCATION:** Asks for and receives the user's location.
*   **PHOTO:** Prompts for and stores a photo of the accident.
*   **DESCRIPTION:** Asks for an optional text description of the incident.
*   **CRASH_TIME_DELTA:** Inquires about the time elapsed since the accident.
*   **CONFIRMATION:** Displays a summary of the report and asks for user confirmation before submission.
*   **COMPANY_NAME:** After the first report, it asks the user for their courier company to enrich their profile.

**User Onboarding:** The bot creates a user profile upon their first interaction. After a successful report, it prompts for the courier company they work for.

#### **Step 4: Admin Features and Notifications**

A significant feature implemented is the admin notification and review system:

*   **Admin Notification:** Upon a new report submission, a notification is sent to all admin users defined in the `ADMIN_IDS` configuration. This message includes the report details and a photo.
*   **Inline Keyboard for Review:** The admin notification includes an inline keyboard with "Approve" and "Reject" buttons.
*   **Review Handling:** A `CallbackQueryHandler` processes the admin's choice. It updates the report's status in the database and notifies the original user of the outcome.

#### **Step 5: User Interface and Experience**

The bot utilizes `ReplyKeyboardMarkup` for interactive buttons, such as "Share Accident Location" and a persistent "➕ New Report" button, which allows users to easily start a new report after completing or canceling a previous one.

### **Summary of Implemented vs. Planned Features**

| Feature | Initial Plan | Implemented Reality |
| :--- | :--- | :--- |
| **Core Framework** | `python-telegram-bot`, `TinyDB` | Fully implemented as planned. |
| **Data Models** | Pydantic models in `models.py` | Not implemented. Data validation is handled directly in handlers. |
| **User Flow** | `ConversationHandler` with states for location, photo, description, time delta, and confirmation. | Fully implemented, with an additional state for capturing the user's company name. |
| **User Onboarding** | Low-friction onboarding, asking for company name after the first report. | Implemented as planned. |
| **Spam Prevention**| Rate limiting of 3 reports per user per 24 hours. | The code for this is commented out in `handlers.py` and is therefore not active. |
| **Admin Features**| Direct database access for manual verification. | A more advanced system with Telegram notifications and an inline keyboard for report approval/rejection was built. |
| **Reward System** | A `status` field in the database to track report verification and reward status. | The `status` field (`pending`, `verified`, `rejected`) and a `reward_sent` boolean are in the database. A message about potential rewards is sent for verified reports. The actual payout logic is not implemented. |
</file>

<file path="repomix-output-stan-voo-daenahbot.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
bot.py
config.py
database.py
handlers.py
kazabot_db.json
Procfile
requirements.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
cat > .gitignore << 'EOF'
.env
venv/
__pycache__/
*.pyc
db.json
.DS_Store
EOF
</file>

<file path="bot.py">
# bot.py

import logging
from telegram.ext import (
    Application,
    ConversationHandler,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)
from config import TELEGRAM_BOT_TOKEN
from handlers import (
    start,
    location,
    photo,
    description,
    description_skip,
    crash_time_delta,
    submit,
    company_name,
    cancel,
    review_handler,
    LOCATION,
    PHOTO,
    DESCRIPTION,
    CRASH_TIME_DELTA,
    CONFIRMATION,
    COMPANY_NAME,
)

# Enable logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)


def main() -> None:
    """Run the bot."""
    # Create the Application and pass it your bot's token.
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()

    # Add conversation handler with the states
    conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler("start", start),
            # NEW: Add an entry point for our button
            MessageHandler(filters.Regex(r"^➕ New Report$"), start),
        ],
        states={
            LOCATION: [MessageHandler(filters.LOCATION, location)],
            PHOTO: [MessageHandler(filters.PHOTO, photo)],
            DESCRIPTION: [
                MessageHandler(filters.Regex(r"(?i)^skip$"), description_skip),
                MessageHandler(filters.TEXT & ~filters.COMMAND, description),
            ],
            CRASH_TIME_DELTA: [MessageHandler(filters.TEXT & ~filters.COMMAND, crash_time_delta)],
            CONFIRMATION: [
                MessageHandler(filters.Regex(r"(?i)^Submit Report$"), submit),
                MessageHandler(filters.Regex(r"(?i)^Cancel$"), cancel),
            ],
            COMPANY_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, company_name)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
        per_message=False # Ensures conversation context is consistent
    )

    application.add_handler(conv_handler)
    application.add_handler(CallbackQueryHandler(review_handler))

    # Run the bot until the user presses Ctrl-C
    logger.info("Starting bot...")
    application.run_polling()
    logger.info("Bot stopped.")


if __name__ == "__main__":
    main()
</file>

<file path="config.py">
# config.py - Configuration management
import os
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Bot configuration - Changed from TELEGRAM_TOKEN to TELEGRAM_BOT_TOKEN
TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
if not TELEGRAM_BOT_TOKEN:
    raise ValueError("No TELEGRAM_BOT_TOKEN found in environment variables")

# Database configuration
DATABASE_PATH = 'db.json'

# Validation constraints
MAX_DESCRIPTION_LENGTH = 200
MIN_CRASH_TIME = 0  # minutes
MAX_CRASH_TIME = 60  # minutes
MAX_REPORTS_PER_DAY = 3

# Conversation states
LOCATION, PHOTO, DESCRIPTION, CRASH_TIME_DELTA, CONFIRMATION = range(5)

# --- Load Admin User IDs from .env file ---
admin_ids_str = os.getenv('ADMIN_IDS', '') # Get the comma-separated string

# Process the string into a list of integers
if admin_ids_str:
    try:
        # Split the string by commas and convert each part to an integer
        ADMIN_IDS = [int(admin_id.strip()) for admin_id in admin_ids_str.split(',')]
    except ValueError:
        print("Error: ADMIN_IDS in .env file contains non-numeric values. Please check it.")
        ADMIN_IDS = [] # Default to an empty list on error
else:
    # If the variable is not set, default to an empty list
    ADMIN_IDS = []

# It's good practice to log or print the loaded admins on startup to verify
if not ADMIN_IDS:
    print("Warning: No ADMIN_IDS found in .env file. Admin features will be disabled.")
else:
    print(f"Admin users loaded successfully: {ADMIN_IDS}")
</file>

<file path="database.py">
# database.py
import uuid
from datetime import datetime, timedelta
from tinydb import TinyDB, Query

# Initialize the database
db = TinyDB('kazabot_db.json', indent=4)
reports_table = db.table('reports')
users_table = db.table('users')

def save_report(user_id, report_data):
    """
    Saves a new accident report to the database.
    """
    report_id = str(uuid.uuid4())
    submitted_at = datetime.utcnow().isoformat()

    report = {
        'report_id': report_id,
        'telegram_user_id': user_id,
        'location_geo': report_data.get('location'),
        'location_time': report_data.get('location_timestamp'),
        'photo_file_id': report_data.get('photo'),
        'photo_time': report_data.get('photo_timestamp'),
        'description': report_data.get('description'),
        'crash_time_delta': report_data.get('crash_time_delta'),
        'submitted_at': submitted_at,
        'status': 'pending', # pending/verified/duplicate/rewarded
        'reward_sent': False
    }
    reports_table.insert(report)
    return report_id

def get_or_create_user(user_id, username):
    """
    Retrieves a user profile or creates a new one if it doesn't exist.
    """
    User = Query()
    user = users_table.get(User.telegram_user_id == user_id)

    if not user:
        user_profile = {
            'telegram_user_id': user_id,
            'username': username,
            'created_at': datetime.utcnow().isoformat(),
            'courier_company': None,
            'payment_method': None,
            'report_count': 0
        }
        users_table.insert(user_profile)
        return user_profile
    return user

def update_user_profile(user_id, data_to_update):
    """
    Updates a user's profile with new information (e.g., company, report count).
    """
    User = Query()
    users_table.update(data_to_update, User.telegram_user_id == user_id)

def get_user_report_count_today(user_id):
    """
    Counts how many reports a user has submitted in the last 24 hours.
    """
    Report = Query()
    twenty_four_hours_ago = (datetime.utcnow() - timedelta(days=1)).isoformat()
    
    user_reports = reports_table.search(
        (Report.telegram_user_id == user_id) & 
        (Report.submitted_at >= twenty_four_hours_ago)
    )
    return len(user_reports)
    # database.py (add these functions)

def get_report_by_id(report_id):
    """Retrieves a single report by its unique ID."""
    Report = Query()
    report = reports_table.get(Report.report_id == report_id)
    return report

def update_report_status(report_id, new_status, admin_id):
    """Updates the status of a report and logs which admin did it."""
    Report = Query()
    reports_table.update(
        {'status': new_status, 'reviewed_by': admin_id}, 
        Report.report_id == report_id
    )
</file>

<file path="handlers.py">
# handlers.py
import logging
from datetime import datetime
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)
from database import save_report, get_or_create_user, update_user_profile, get_user_report_count_today
from config import ADMIN_IDS 
from database import ( 
    save_report, 
    get_or_create_user, 
    update_user_profile,
    get_report_by_id, 
    update_report_status
)

# Enable logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# Define states for the conversation
(
    LOCATION,
    PHOTO,
    DESCRIPTION,
    CRASH_TIME_DELTA,
    CONFIRMATION,
    COMPANY_NAME,
) = range(6)
# --- NEW: Reusable keyboard for starting a new report ---
NEW_REPORT_KEYBOARD = ReplyKeyboardMarkup([["➕ New Report"]], resize_keyboard=True, one_time_keyboard=False)

# --- Start & Cancel ---

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Starts the conversation and asks for the accident location."""
    user = update.message.from_user
    logger.info("User %s started the conversation.", user.first_name)
    
    # Onboard the user if they are new
    get_or_create_user(user.id, user.username)

    # Check report limit
    # Note: A more robust implementation would check this *before* starting.
    # We place it here for simplicity in the conversation flow.
    # report_count = get_user_report_count_today(user.id)
    # if report_count >= 3:
    #     await update.message.reply_text("You have reached your daily report limit (3). Please try again tomorrow.")
    #     return ConversationHandler.END

    location_keyboard = KeyboardButton(text="Share Accident Location", request_location=True)
    custom_keyboard = [[location_keyboard]]
    reply_markup = ReplyKeyboardMarkup(custom_keyboard, resize_keyboard=True, one_time_keyboard=True)

    await update.message.reply_text(
        "Welcome to KazaBot! Help us by reporting minor accidents and get rewarded.\n\n"
        "Please press the button below to share the accident's location.",
        reply_markup=reply_markup,
    )
    return LOCATION

# --- Reporting Flow ---

async def location(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the location and asks for a photo."""
    user_location = update.message.location
    context.user_data['report'] = {
        'location': (user_location.latitude, user_location.longitude),
        'location_timestamp': datetime.utcnow().isoformat()
    }
    logger.info("Location from %s: %s", update.message.from_user.first_name, user_location)
    
    await update.message.reply_text(
        "Great! Now, please take a clear photo of the accident and send it to me.",
        reply_markup=ReplyKeyboardRemove(),
    )
    return PHOTO

async def photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the photo and asks for a description."""
    user_photo = update.message.photo[-1] # Get the highest resolution photo
    context.user_data['report']['photo'] = user_photo.file_id
    context.user_data['report']['photo_timestamp'] = datetime.utcnow().isoformat()
    
    logger.info("Photo received from %s", update.message.from_user.first_name)
    
    reply_keyboard = [["Skip"]]
    await update.message.reply_text(
        "Photo received. Now, please add a short description (e.g., 'two cars, rear-end'). "
        "This is optional. You can also type 'Skip'.",
        reply_markup=ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True, one_time_keyboard=True),
    )
    return DESCRIPTION

async def description(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the description and asks for the time delta."""
    user_description = update.message.text
    if user_description.lower() != 'skip':
        if len(user_description) > 200:
            await update.message.reply_text("The description is too long (max 200 characters). Please try again.")
            return DESCRIPTION
        context.user_data['report']['description'] = user_description
    else:
        context.user_data['report']['description'] = None
        
    logger.info("Description from %s: %s", update.message.from_user.first_name, user_description)
    await update.message.reply_text(
        "Got it. Roughly how many minutes ago did the crash happen? (Please enter a number from 0 to 60)",
        reply_markup=ReplyKeyboardRemove(),
    )
    return CRASH_TIME_DELTA

async def description_skip(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Skips the description and asks for the time delta."""
    context.user_data['report']['description'] = None
    logger.info("User %s skipped the description.", update.message.from_user.first_name)
    await update.message.reply_text(
        "Description skipped. Roughly how many minutes ago did the crash happen? (Please enter a number from 0 to 60)",
        reply_markup=ReplyKeyboardRemove(),
    )
    return CRASH_TIME_DELTA


async def crash_time_delta(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Stores the time delta and asks for final confirmation."""
    text = update.message.text
    try:
        delta = int(text)
        if not (0 <= delta <= 60):
            raise ValueError
        context.user_data['report']['crash_time_delta'] = delta
    except (ValueError, TypeError):
        await update.message.reply_text("That's not a valid number. Please enter a number between 0 and 60.")
        return CRASH_TIME_DELTA

    # Show summary
    report = context.user_data['report']
    summary = (
        f"--- REVIEW YOUR REPORT ---\n"
        f"📍 Location: Sent\n"
        f"📸 Photo: Sent\n"
        f"📝 Description: {report.get('description', 'N/A')}\n"
        f"⏱️ Time Since Crash: ~{report.get('crash_time_delta')} minutes ago\n\n"
        "Is everything correct?"
    )
    reply_keyboard = [["Submit Report", "Cancel"]]
    await update.message.reply_text(
        summary,
        reply_markup=ReplyKeyboardMarkup(reply_keyboard, resize_keyboard=True, one_time_keyboard=True),
    )
    return CONFIRMATION

async def submit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Submits the report, saves it, and transitions to the final steps."""
    user = update.message.from_user
    report_data = context.user_data.get('report')
    
    if not report_data:
        await update.message.reply_text("Something went wrong. Please start over with /start.")
        return ConversationHandler.END

    # Save the report
    report_id = save_report(user.id, report_data)
    logger.info("User %s submitted report %s", user.first_name, report_id)

    # Update user's report count
    user_profile = get_or_create_user(user.id, user.username)
    new_count = user_profile.get('report_count', 0) + 1
    update_user_profile(user.id, {'report_count': new_count})
    
    # Notify admins
    await notify_admins(context, user, report_id, report_data)
    
    # Check if company name is needed
    if user_profile.get('courier_company') is None:
        await update.message.reply_text(
            "✅ Success! Your report has been submitted.\n\n"
            "To help us, could you tell us which courier company you work for? (e.g., 'Getir', 'Trendyol Go'). This is optional.",
             reply_markup=ReplyKeyboardRemove(),
        )
        return COMPANY_NAME
    else:
        # If company name is known, end the conversation
        return await finish(update, context)


async def company_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Saves the user's courier company and ends the conversation."""
    user_id = update.message.from_user.id
    company = update.message.text
    
    update_user_profile(user_id, {'courier_company': company})
    logger.info("User %s set their company to %s", update.message.from_user.first_name, company)
    
    await update.message.reply_text("Thank you! Your profile has been updated.")
    
    return await finish(update, context)


async def finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Clears user data and shows the final message with the 'New Report' button."""
    context.user_data.clear()
    await update.message.reply_text(
        "You can now submit a new report or close this chat.",
        reply_markup=NEW_REPORT_KEYBOARD,
    )
    return ConversationHandler.END


async def notify_admins(context: ContextTypes.DEFAULT_TYPE, user, report_id, report_data):
    """Sends a notification to all admins about a new report."""
    admin_message = (
        f"🚨 New Accident Report Submitted 🚨\n\n"
        f"Report ID: `{report_id}`\n"
        f"Submitted By: @{user.username} (ID: `{user.id}`)\n"
        f"Description: {report_data.get('description', 'N/A')}\n"
        f"Time Delta: ~{report_data.get('crash_time_delta')} minutes ago"
    )
    
    keyboard = [
        [
            InlineKeyboardButton("✅ Approve", callback_data=f"approve_{report_id}"),
            InlineKeyboardButton("❌ Reject", callback_data=f"reject_{report_id}"),
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    for admin_id in ADMIN_IDS:
        try:
            await context.bot.send_photo(chat_id=admin_id, photo=report_data['photo'])
            await context.bot.send_message(
                chat_id=admin_id,
                text=admin_message,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
            logger.info(f"Sent notification for report {report_id} to admin {admin_id}")
        except Exception as e:
            logger.error(f"Failed to send notification to admin {admin_id}: {e}")


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancels the conversation and shows the 'New Report' button."""
    user = update.message.from_user
    logger.info("User %s canceled the conversation.", user.first_name)
    context.user_data.clear()
    await update.message.reply_text(
        "Report canceled. You can start a new one anytime.",
        reply_markup=NEW_REPORT_KEYBOARD, # Use our new keyboard
    )
    return ConversationHandler.END


async def review_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handles admin decisions from inline keyboard buttons."""
    query = update.callback_query
    await query.answer() # Acknowledge the button press

    admin_user = query.from_user
    action, report_id = query.data.split("_")

    if admin_user.id not in ADMIN_IDS:
        await query.edit_message_text(text="Sorry, you are not authorized to perform this action.")
        return

    report = get_report_by_id(report_id)
    if not report:
        await query.edit_message_text(text=f"Error: Report {report_id} not found.")
        return
    
    if report['status'] != 'pending':
        await query.edit_message_text(text=f"This report has already been reviewed. Status: {report['status']}.")
        return

    # Update status and notify the user
    new_status = "verified" if action == "approve" else "rejected"
    update_report_status(report_id, new_status, admin_user.id)
    
    # Update the admin's message to show the result
    final_text = query.message.text + f"\n\n--- Decision ---\nStatus set to *{new_status.upper()}* by @{admin_user.username}."
    await query.edit_message_text(text=final_text, parse_mode='Markdown')

    # Notify the original user
    original_user_id = report['telegram_user_id']
    user_notification = f"UPDATE: Your report (ID: {report_id}) has been *{new_status}*."
    
    if new_status == 'verified':
        user_notification += "\n\nCongratulations! You may be eligible for a reward. We will be in touch about payouts soon."
        # Here you would trigger the payout logic in the future
    
    try:
        await context.bot.send_message(
            chat_id=original_user_id,
            text=user_notification,
            parse_mode='Markdown'
        )
    except Exception as e:
        logger.error(f"Failed to send status update to user {original_user_id}: {e}")
</file>

<file path="kazabot_db.json">
{
    "users": {
        "1": {
            "telegram_user_id": 4462330,
            "username": "mrvooooo",
            "created_at": "2025-07-30T18:05:09.870369",
            "courier_company": "Getir",
            "payment_method": null,
            "report_count": 1
        },
        "2": {
            "telegram_user_id": 7127606451,
            "username": "rewd0glamd",
            "created_at": "2025-07-30T19:24:09.028355",
            "courier_company": "Getir",
            "payment_method": null,
            "report_count": 4
        }
    },
    "reports": {
        "1": {
            "report_id": "2d156c1b-68eb-49cb-af1b-00f27707b32d",
            "telegram_user_id": 4462330,
            "location_geo": [
                38.432951,
                27.162072
            ],
            "location_time": "2025-07-30T18:05:31.830144",
            "photo_file_id": "AgACAgIAAxkBAAMFaIpe_EWfcVoX0NSX0mgIQAZB-t0AAqv3MRvjwlFIKRrfjwEHeEIBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T18:05:48.250580",
            "description": "masterful coding",
            "crash_time_delta": 0,
            "submitted_at": "2025-07-30T18:06:15.584885",
            "status": "pending",
            "reward_sent": false
        },
        "2": {
            "report_id": "25405c14-5629-40cf-a3ac-69dd234f499b",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:24:25.945855",
            "photo_file_id": "AgACAgQAAxkBAAMUaIpxf_Nkuum2freWHeVOEQbhdagAAs_LMRtkoVlQR0RDdOuUEjYBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:24:47.503329",
            "description": null,
            "crash_time_delta": 5,
            "submitted_at": "2025-07-30T19:25:02.912718",
            "status": "verified",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "3": {
            "report_id": "e436d6c3-679f-4e35-a3e6-b9a07f362818",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:41:32.081860",
            "photo_file_id": "AgACAgQAAxkBAAMmaIp1eebMWgl_HAN88HD6dyowyPQAAtXLMRtkoVlQZxNh-hoxm-gBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:41:45.601875",
            "description": "Test3: button add",
            "crash_time_delta": 0,
            "submitted_at": "2025-07-30T19:42:04.169922",
            "status": "rejected",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "4": {
            "report_id": "1fa7e2e7-1ae0-4c94-9fa6-7c6c4eb100fc",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:42:27.204362",
            "photo_file_id": "AgACAgQAAxkBAAM0aIp1vnXSYeWzKOGGtQdTR0cerAgAAtfLMRtkoVlQVAPjHxaAMeYBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:42:54.313088",
            "description": null,
            "crash_time_delta": 9,
            "submitted_at": "2025-07-30T19:43:15.203505",
            "status": "rejected",
            "reward_sent": false,
            "reviewed_by": 4462330
        },
        "5": {
            "report_id": "7faf682c-b7d4-4ff3-89ae-58531ab819b8",
            "telegram_user_id": 7127606451,
            "location_geo": [
                38.432996,
                27.163818
            ],
            "location_time": "2025-07-30T19:51:19.351171",
            "photo_file_id": "AgACAgQAAxkBAAMUaIpxf_Nkuum2freWHeVOEQbhdagAAs_LMRtkoVlQR0RDdOuUEjYBAAMCAAN5AAM2BA",
            "photo_time": "2025-07-30T19:51:27.247422",
            "description": "Hello",
            "crash_time_delta": 0,
            "submitted_at": "2025-07-30T19:51:39.011673",
            "status": "pending",
            "reward_sent": false
        }
    }
}
</file>

<file path="Procfile">
worker: python bot.py
</file>

<file path="requirements.txt">
python-telegram-bot==21.3
tinydb==4.8.0
python-dotenv==1.0.0
pydantic==2.5.0
</file>

</files>
</file>

<file path="requirements.txt">
python-telegram-bot==21.3
tinydb==4.8.0
python-dotenv==1.0.0
pydantic==2.5.0
</file>

</files>
</file>

<file path="requirements.txt">
python-telegram-bot==21.3
tinydb==4.8.0
python-dotenv==1.0.0
pydantic==2.5.0
</file>

</files>
</file>

<file path="requirements.txt">
python-telegram-bot==21.3
tinydb==4.8.0
python-dotenv==1.0.0
pydantic==2.5.0
</file>

</files>
</file>

<file path="requirements.txt">
python-telegram-bot==21.3
tinydb==4.8.0
python-dotenv==1.0.0
pydantic==2.5.0
</file>

</files>
</file>

<file path="requirements.txt">
python-telegram-bot==21.3
tinydb==4.8.0
python-dotenv==1.0.0
pydantic==2.5.0
</file>

</files>
